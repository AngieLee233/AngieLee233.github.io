<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络网课笔记-应用层</title>
      <link href="/2022/03/22/computerInternet-6/"/>
      <url>/2022/03/22/computerInternet-6/</url>
      
        <content type="html"><![CDATA[<p>最后一层啦！小黎快完成啦！</p><p>粗略浏览了一下运输层的笔记，怎么全都是涂涂改改（</p><p>可能是不太正经，这章争取正经一些！</p><p><s>你信吗，反正我不信</s></p><span id="more"></span><h1>概述</h1><ul><li>应用层是计算机网络体系结构的<strong>最顶层</strong>，是设<strong>计和建立计算机网络的最终目的</strong>，也是计算机网络中发展最快的部分。<ul><li>早期基于文本的应用（电子邮件、远程登录、文件传输、新闻组）</li><li>20世纪90年代将因特网带入干家万户的万维网WWW</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用</li><li>计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台。</li></ul></li><li>在本章中，我们以一些经典的网络应用为例来学习有关网络应用的原理、协议和实现方面的知识。</li></ul><p><a href="https://imgtu.com/i/qMNbeU"><img src="https://s1.ax1x.com/2022/03/22/qMNbeU.md.png" alt="qMNbeU.md.png"></a></p><h1>客户/服务器方式（C/S方式）和对等方式（P2P方式）</h1><ul><li>网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。</li><li>开发一种新的网络应用首先要考虑的问题就是<strong>网络应用程序在各种端系统上的组织方式和它们之间的关系</strong>。目前流行的主要有以下两种：</li><li><strong>客户/服务器</strong>（Client/Server，C/S）方式</li><li><strong>对等</strong>（Peer-to-Peer，P2P）方式</li></ul><h2 id="客户-服务器（Client-Server，C-S）方式">客户/服务器（Client/Server，C/S）方式</h2><ul><li>客户和服务器是指通信中所涉及的两个应用进程。</li><li>客户/服务器方式所描述的是进程之间服务和被服务的关系。</li><li><strong>客户是服务请求方，服务器是服务提供方。</strong></li><li><strong>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80），而运行服务器的主机也具有固定的IP地址。</strong></li></ul><p><a href="https://imgtu.com/i/qMdYLV"><img src="https://s1.ax1x.com/2022/03/22/qMdYLV.md.png" alt="qMdYLV.md.png"></a></p><p>C/S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C/S方式。包括万维网WWW、电子邮件、文件传输FTP等。</p><p>基于C/S方式的应用服务通常是<strong>服务集中型</strong>的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上。</p><ul><li>由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，<strong>常会出现服务器计算机跟不上众多客户机请求的情况</strong>。<s>比如抢课时的你和土豆</s></li><li>为此，在C/S应用中，常用<strong>计算机群集</strong>（或服务器场）构建一个强大的<strong>虚拟服务器</strong>。</li></ul><h2 id="对等（Peer-to-Peer，P2P）方式">对等（Peer-to-Peer，P2P）方式</h2><p>在P2P方式中，<strong>没有固定的服务请求者和服务提供者</strong>，分布在网络边缘各端系统中的应用进程是对等的，被称为<strong>对等方</strong>。<strong>对等方相互之间直接通信</strong>，每个对等方既是服务的请求者，又是服务的提供者。</p><p><a href="https://imgtu.com/i/qMwOnx"><img src="https://s1.ax1x.com/2022/03/22/qMwOnx.md.png" alt="qMwOnx.md.png"></a></p><ul><li>目前，在因特网上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等。</li><li>基于P2P的应用是<strong>服务分散型</strong>的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。</li><li>P2P方式的最突出特性之一就是它的<strong>可扩展性</strong>。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，<strong>系统性能不会因规模的增大而降低</strong>。</li><li>P2P方式<strong>具有成本上的优势</strong>，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大。</li></ul><h1>动态主机配置DHCP（Dynamic Host Configuration Protocol）</h1><p>如图所示，对于图中网络，应该给网络中的各主机设置网络相关配置信息（IP地址、子网掩码、默认网关、DNS服务器等）使其可以正常访问网络中的Web服务器。</p><p>如果网络中的主机数量比较多，则这种手工配置的工作量就比较大，并且容易出错。</p><p><a href="https://imgtu.com/i/qMsRTP"><img src="https://s1.ax1x.com/2022/03/22/qMsRTP.md.png" alt="qMsRTP.md.png"></a></p><p>如果给网络中添加一台DHCP服务器，在该服务器中设置好可为网络中其他各主机配置的网络配置信息。网络中各主机开机后自动启动DHCP程序，向DHCP服务器请求自己的网络配置信息。这样，网络中的各主机就可以自动从DHCP服务器自动获取网络配置信息而不用手工参与。</p><p><a href="https://imgtu.com/i/qMyUXj"><img src="https://s1.ax1x.com/2022/03/22/qMyUXj.md.png" alt="qMyUXj.md.png"></a></p><p>动态主机配置协议DHCP（Dynamic Host Configuration Protocol）提供了一种机制，称为即插即用连网。这种机制<strong>允许一台计算机加入新网络时可自动获取IP地址等网络配置信息而不用手工参与</strong>。</p><h2 id="工作过程">工作过程</h2><p>假设网络中有两台DHCP服务器和多台用户主机，为了简单而有效地描述DHCP的工作过程，画出网络中的两台DHCP服务器和一台用户主机。</p><p>DHCP使用客户/服务器方式，在DHCP服务器上运行DHCP服务器进程，也可简称为DHCP服务器；在用户主机上运行DHCP客户进程，也可简称为DHCP客户。DHCP是TCP/IP协议体系应用层中的协议，它使用运输层的UDP所提供的服务。也就是说，DHCP报文在运输层会被封装成为UDP用户数据报。DHCP服务器使用的UDP端口是67，DHCP客户使用的UDP端口是68，这两个UDP端口都是熟知端口。</p><p>封装有DHCP报文的UDP用户数据报在网络层会被封装成IP数据报，然后再根据所使用的网络接口，封装成相应的数据链路层的帧进行发送。为了简单起见，在后续描述过程中，除非有特别需要，否则将不再每次描述DHCP报文逐层封装的过程。</p><p>DHCP客户与DHCP服务器的交互过程包括寻找DHCP服务器、提供IP地址租用、接受IP地址租约、确认IP地址租约、IP地址续约和随时解除IP地址租约。如下图所示：</p><p><a href="https://imgtu.com/i/qMh0YR"><img src="https://s1.ax1x.com/2022/03/22/qMh0YR.md.png" alt="qMh0YR.md.png"></a></p><p>下面对各部分进行详细介绍。</p><h3 id="寻找DHCP服务器">寻找DHCP服务器</h3><p>当启用主机的DHCP后，DHCP客户将广播发送DHCP发现报文，封装该报文的IP数据报的源IP地址为<strong>0.0.0.0</strong>，这是因为<strong>主机目前还未分配到IP地址</strong>，因此使用该地址来代替。目的IP地址为广播地址255.255.255.255。之所以进行广播发送，是因为主机目前并不知道网络中有哪几个DHCP服务器，以及它们的IP地址各是什么。由于是广播的IP数据报，因此网络中的所有设备都会收到该IP数据报，并对其层层解封，解封出封装有DHCP发现报文的UDP用户数据报。对于DHCP客户，其应用层没有监听该UDP用户数据报的目的端口67的进程，也就是DHCP服务器进程。因此无法交付DHCP发现报文，只能丢弃。而对于DHCP服务器，其应用层始终运行着DHCP服务器进程，因此会接受该DHCP发现报文并作出响应。</p><p>DHCP报文的格式比较复杂，对于DHCP发现报文，我们只需要知道其内部封装有事务ID和DHCP客户端的MAC地址即可。</p><p><a href="https://imgtu.com/i/qMHFHK"><img src="https://s1.ax1x.com/2022/03/22/qMHFHK.md.png" alt="qMHFHK.md.png"></a></p><h3 id="提供IP地址租用">提供IP地址租用</h3><p>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，看<strong>是否有针对该MAC地址的配置信息</strong>。<br>* 如果有，则使用这些配置信息来构建并发送DHCP提供报文。<br>* 如果没有，则采用默认配置信息来构建并发送DHCP提供报文。</p><p>封装该报文的IP数据报的源IP地址为DHCP服务器的IP地址，目的IP地址仍为广播地址。仍然使用广播地址的原因是，主机目前还没有配置IP地址，为了使主机可以收到，只能发送广播。这样一来，网络中的所有设备都会收到该IP数据报，并对其层层解封，解封出封装有DHCP提供报文的用户数据报。对于DHCP服务器，其应用层没有监听该UDP用户数据报目的端口68的进程，也就是DHCP客户进程。因此无法交付DHCP提供报文，只能丢弃。而对于DHCP客户，其应用层运行着DHCP客户进程，因此会接受该DHCP提供报文并作出相应处理。</p><p>DHCP客户会<strong>根据DHCP提供报文中的事务ID来判断该报文是否是自己所请求的报文</strong>。<br>* 如果该事务ID与自己之前发送的DHCP发现报文中封装的事务ID相等，就表明这是自己所请求的报文，就可以接受该报文。<br>* 如果该事务ID与自己之前发送的DHCP发现报文中封装的事务ID不等，则就丢弃该报文。</p><p>DHCP提供报文中，还封装有配置信息，例如IP地址、子网掩码、地址租期、默认网关、DNS服务器等。需要注意的是，<strong>DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址时，会使用ARP来确保所选IP地址未被网络中其他主机占用</strong>。</p><p><a href="https://imgtu.com/i/qMbWWQ"><img src="https://s1.ax1x.com/2022/03/22/qMbWWQ.md.png" alt="qMbWWQ.md.png"></a></p><h3 id="接受IP地址租约">接受IP地址租约</h3><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的那个，并向所选择的DHCP服务器发送DHCP请求报文。<strong>封装该报文的IP数据报的源地址仍为0.0.0.0</strong>，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器，它<strong>首先需要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</strong>。目的IP地址仍为<strong>广播地址</strong>，这样做的目的是，不用向网络中的每一个DHCP服务器单播发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器。</p><p>DHCP请求报文中封装有事务ID、DHCP客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器端的IP地址等信息。</p><p><a href="https://imgtu.com/i/qMqkfe"><img src="https://s1.ax1x.com/2022/03/22/qMqkfe.md.png" alt="qMqkfe.md.png"></a></p><h3 id="确认IP地址租约">确认IP地址租约</h3><p>在本例中，假设DHCP客户选择DHCP服务器1作为自己的DHCP服务器，并且DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户发送DHCP确认报文。封装该报文的IP数据报的源IP地址为DHCP服务器1的IP地址；目的IP地址仍为广播地址。</p><p>DHCP客户收到该确认报文后，就可以使用所租用到的IP地址了。</p><p>需要注意的是，在使用租用到的IP地址之前，<strong>主机还会使用ARP检测该IP地址是否已被网络中其它主机占用</strong>。<br>* 若被占用，DHCP客户会给DHCP服务器发送DHCP谢绝报文，来谢绝IP地址租约，并重新发送DHCP发现报文。<br>* 若未被占用，则可以使用租约中的IP地址与网络中的其他主机通信了。</p><p><a href="https://imgtu.com/i/qMqjN8"><img src="https://s1.ax1x.com/2022/03/22/qMqjN8.md.png" alt="qMqjN8.md.png"></a></p><h3 id="IP地址续约">IP地址续约</h3><p>当租用期过了<strong>一半</strong>时，DHCP客户会向DHCP服务器发送DHCP请求报文来请求更新租用期。封装该报文的IP数据报的源IP地址为DHCP客户之前租用到的IP地址，目的IP地址为DHCP服务器1的地址。<br>* DHCP服务器若同意，则发回DHCP确认报文。这样，DHCP客户就得到了新的租用期。</p><pre><code>* DHCP服务器若不同意，则发回DHCP否认报文。这时，DHCP客户必须立即停止使用之前租用的IP地址，并重新发送DHCP发现报文来重新申请IP地址。* DHCP服务器若未作出响应，则在租用期过了87.5%时，DHCP客户必须重新发送DHCP请求报文，然后继续等到DHCP服务器可能作出的反应。若DHCP服务器未作出反应，则当租用期到期后，DHCP客户必须立即停止使用之前租用的IP地址，并重新发送DHCP发现报文来重新申请IP地址。</code></pre><p><a href="https://imgtu.com/i/qMLHGF"><img src="https://s1.ax1x.com/2022/03/22/qMLHGF.md.png" alt="qMLHGF.md.png"></a></p><h3 id="随时解除IP地址租约">随时解除IP地址租约</h3><p>DHCP客户可以随时提前终止DHCP服务器所提供的租用期，这时只需向DHCP服务器发送DHCP释放报文段即可。</p><p><a href="https://imgtu.com/i/qMOixH"><img src="https://s1.ax1x.com/2022/03/22/qMOixH.md.png" alt="qMOixH.md.png"></a></p><h3 id="注意事项">注意事项</h3><p>DHCP服务器在给DHCP客户挑选IP地址时，使用ARP来确保所挑选的IP地址未被网络中其他主机占用。而DHCP客户在使用所租用的IP地址之前，也会使用ARP来检测该IP地址是否已被网络中其他主机占用。</p><p><a href="https://imgtu.com/i/qMTP2R"><img src="https://s1.ax1x.com/2022/03/22/qMTP2R.md.png" alt="qMTP2R.md.png"></a></p><h2 id="DHCP中继代理">DHCP中继代理</h2><p>对于以下网络拓扑，选中的网络中的各主机不是都可以通过DHCP来自动获取到网络配置信息。因为该网络中的主机广播发送DHCP发现报文，但该广播报文不会被路由器转发，而是丢弃。</p><p><a href="https://imgtu.com/i/qMjPud"><img src="https://s1.ax1x.com/2022/03/22/qMjPud.md.png" alt="qMjPud.md.png"></a></p><p>解决方法是给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理。这样，该网络中的各主机就可以通过DHCP来自动获取到网络配置信息了。</p><p>当该路由器收到广播的DHCP报文后，会将其单播转发给DHCP服务器，DHCP客户和DHCP服务器通过该路由器的后续交互过程不再赘述。</p><p><a href="https://imgtu.com/i/qMjoIP"><img src="https://s1.ax1x.com/2022/03/22/qMjoIP.md.png" alt="qMjoIP.md.png"></a></p><p>使用DHCP中继代理的主要原因是，我们并不愿意在每一个网络上都设置一个DHCP服务器，因为这样会使DHCP服务器的数量太多。</p><p>在每一个网络上都设置一个DHCP服务器会使DHCP服务器的数量太多。因此现在是使每一个网络至少有一个<strong>DHCP中继代理（通常是一台路由器）</strong>，它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁。</p>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-运输层</title>
      <link href="/2022/03/20/computerInternet-5/"/>
      <url>/2022/03/20/computerInternet-5/</url>
      
        <content type="html"><![CDATA[<p>上次的网络层前前后后花了两天半，顺利完结撒花~</p><p>终于到爷最爱的运输层啦！（bushi</p><span id="more"></span><h1>概述</h1><ul><li>之前课程所介绍的计算机网络体系结构中的物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了<strong>主机到主机的通信</strong>。</li><li>但实际上在计算机网络中进行<strong>通信的真正实体是位于通信两端主机中的进程</strong>。</li><li><strong>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务</strong>，运输层协议又称为端到端协议。</li></ul><p><a href="https://imgtu.com/i/qezOfg"><img src="https://s1.ax1x.com/2022/03/20/qezOfg.md.png" alt="qezOfg.md.png"></a></p><p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就<strong>好像是在两个运输层实体之间有一条端到端的逻辑通信信道</strong>。</p><p>根据应用需求的不同，<strong>因特网的运输层</strong>为应用层提供了两种不同的运输协议，即<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>，这两种协议就是本章要讨论的主要内容。</p><h1>运输层端口号、复用与分用</h1><h2 id="端口号">端口号</h2><ul><li>运行在计算机上的进程使用<strong>进程标识符PID</strong>来标志。</li><li>因特网上的计算机并不是使用统一的操作系统，不同的操作系统（windows，Linux，Mac OS）又使用<strong>不同格式的进程标识符</strong>。</li><li>为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须<strong>使用统一的方法对TCP/IP体系的应用进程进行标识</strong>。</li><li>TCP/IP体系的运输层使用<strong>端口号</strong>来区分应用层的不同应用进程。<ul><li>端口号使用<strong>16比特</strong>表示，取值范围<strong>0~65535</strong>；<ul><li><strong>熟知端口号</strong>：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20，HTTP使用80，DNS使用53。</li><li><strong>登记端口号</strong>：1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复，例如：Microsoft RDP 微软远程桌面使用的端口是3389。</li><li><strong>短暂端口号</strong>：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ul></li><li><strong>端口号只具有本地意义</strong>，即端口号只是为了<strong>标识本计算机应用层中的各进程</strong>，在因特网中，<strong>不同计算机中的相同端口号是没有联系的</strong>。</li></ul></li></ul><h2 id="发送方的复用与接收方的分用">发送方的复用与接收方的分用</h2><p><a href="https://imgtu.com/i/qm9uFK"><img src="https://s1.ax1x.com/2022/03/20/qm9uFK.md.png" alt="qm9uFK.md.png"></a></p><h2 id="TCP-IP体系的应用层常用协议所使用的运输层熟知端口号">TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</h2><p><a href="https://imgtu.com/i/qm9cT0"><img src="https://s1.ax1x.com/2022/03/20/qm9cT0.md.png" alt="qm9cT0.md.png"></a></p><h2 id="端口号应用举例">端口号应用举例</h2><p>如图所示，用户PC、DNS服务器、Web服务器通过交换机进行互联，它们处于同一个以太网中。假设Web服务器域名如图，DNS服务器中记录有该域名所对应的IP地址。</p><p>我们在用户PC中使用网页浏览器来访问Web服务器的内容，在网页浏览器的地址栏中输入Web服务器的域名。用户PC中的DNS客户端进程会发送一个DNS查询请求报文，其内容如图。</p><p>DNS查询请求报文需要使用运输层的UDP协议封装成UDP用户数据报，其首部中的源端口字段中的值在短暂端口号49151-65535挑选一个未被占用的用来标识客户端进程，例如49152。目的端口字段的值设置为53，这是DNS服务器端进程使用的熟知端口号。</p><p>之后将UDP用户数据报封装在IP数据报中通过以太网发送给DNS服务器。</p><p><a href="https://imgtu.com/i/qmChUP"><img src="https://s1.ax1x.com/2022/03/20/qmChUP.md.png" alt="qmChUP.md.png"></a></p><p>DNS服务器收到该数据报后，从中解封出UDP用户数据报，UDP首部中的目的端口号为53，这表明应将UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程。</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址。之后，会给用户PC发送DNS响应报文，其内容如图。</p><p>DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报。其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报。目的端口字段的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号。</p><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC。</p><p><a href="https://imgtu.com/i/qmCXEq"><img src="https://s1.ax1x.com/2022/03/20/qmCXEq.md.png" alt="qmCXEq.md.png"></a></p><p>用户PC收到该数据报后，从中解封出UDP用户数据报。UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程。</p><p>DNS客户端进程解析DNS相应报文的内容，就可知道自己之前所请求的Web服务器的域名所对应的IP地址。</p><p><a href="https://imgtu.com/i/qmPn2D"><img src="https://s1.ax1x.com/2022/03/20/qmPn2D.md.png" alt="qmPn2D.md.png"></a></p><p>现在，用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文了，其内容如图所示。</p><p>HTTP请求报文需要使用运输层的TCP协议封装成TCP报文段，其首部中的源端口字段的值在短暂端口号49151-65535中挑选一个未被占用的，用来标识HTTP客户端进程。例如仍然使用之前用过的49152，目的端口字段的值设置为80，这是HTTP服务器端进程所使用的熟知端口号。</p><p>之后将TCP报文段封装在IP数据报中，通过以太网发送给Web服务器。</p><p><a href="https://imgtu.com/i/qmPuxe"><img src="https://s1.ax1x.com/2022/03/20/qmPuxe.md.png" alt="qmPuxe.md.png"></a></p><p>Web服务器收到该数据报后，从中解封出TCP报文段。TCP首部中的目的端口号为80，这表明应该将该TCP报文段的数据载荷部分，也就是HTTP请求报文，交付给本服务器中的HTTP服务器端进程。</p><p>HTTP服务器端进程解析HTTP请求报文的内容，然后按其要求查找首页内容。之后会给用户PC发送HTTP相应报文，其内容如图所示。HTTP相应报文需要使用运输层的TCP协议封装成TCP报文段，其首部中的源端口号字段的值设置为熟知端口号80，表明这是HTTP服务器端进程所发送的TCP报文段。目的端口字段的值设置为49152，这是之前用户PC中发送HTTP请求报文的HTTP客户端进程所使用的短暂端口号。</p><p>之后，将TCP报文段封装在IP数据报中，通过以太网发送给用户PC。</p><p><a href="https://imgtu.com/i/qmPYPf"><img src="https://s1.ax1x.com/2022/03/20/qmPYPf.md.png" alt="qmPYPf.md.png"></a></p><p>用户PC收到该数据报后，从中解封出TCP报文段，TCP首部中的目的端口号为49152，这表明应该将该TCP报文段的数据载荷部分，也就是HTTP相应报文，交付给用户PC中的HTTP客户端进程。</p><p>HTTP客户端进程解析HTTP相应报文的内容，并在网页浏览器中进行显示。这样，我们就可以在网页浏览器中看到Web服务器所提供的首页内容了。</p><p><a href="https://imgtu.com/i/qmiCJf"><img src="https://s1.ax1x.com/2022/03/20/qmiCJf.md.png" alt="qmiCJf.md.png"></a></p><h1>TCP和UDP的对比</h1><p>使用UDP协议的通信双方可以随时发送数据</p><p>使用TCP协议的通信双方在进行数据传输前，需要通过三报文握手建立TCP连接。TCP连接建立成功后才能进行数据传输。数据传输结束后，需要使用四报文挥手来释放TCP连接。</p><p>（这里的连接是指逻辑连接，而不是物理连接</p><p><a href="https://imgtu.com/i/qmrjPJ"><img src="https://s1.ax1x.com/2022/03/21/qmrjPJ.md.png" alt="qmrjPJ.md.png"></a></p><p>图中是使用UDP协议的四台主机，其中任意一个主机都可以向其他主机发送广播，也可以向某个多播组发送多播，还可以向某台主机发送单播。也就是说，UDP支持一对一、一对多和一对全的通信。</p><p>使用TCP协议的通信双方，在进行数据传输之前必须要使用三报文握手来建立连接，通信双方使用这条基于TCP连接的可靠信道进行通信。TCP仅支持单播，也就是一对一的通信。</p><p><a href="https://imgtu.com/i/qmsKqf"><img src="https://s1.ax1x.com/2022/03/21/qmsKqf.md.png" alt="qmsKqf.md.png"></a></p><p>发送方的应用进程将应用层报文交付给运输层的UDP，UDP直接给应用层报文添加一个UDP首部，使之成为UDP用户数据报，然后进行发送。接收方的UDP收到该UDP用户数据报后，去掉UDP首部，将应用层报文交付给应用进程。也就是说，UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界。</p><p>发送方的TCP把应用进程交付下来的数据块仅仅看作是一连串的、无结构的字节流。TCP仅将字节流编号，并存储在自己的发送缓存中。TCP根据发送策略从发送缓存中提取一定数量的字节构造TCP报文段进行发送。接收方的TCP一方面从接收到的TCP报文段中，取出数据载荷部分并存储在接收缓存中，一方面将接收缓存中的一些字节交付给应用进程。TCP不保证接收方应用进程所收到的数据块与发送方应用进程所发出的数据块具有对应大小的关系。但接收方的应用进程收到的字节流必须和发送方应用进程发出的字节流完全一样。这是TCP实现可靠传输、流量控制、拥塞控制的基础。</p><p><a href="https://imgtu.com/i/qm66Dx"><img src="https://s1.ax1x.com/2022/03/21/qm66Dx.md.png" alt="qm66Dx.md.png"></a></p><p>当运输层使用UDP协议时，向上提供无连接的不可靠传输服务。</p><p>当运输层使用TCP协议时，向上提供面向连接的可靠传输服务。</p><p><a href="https://imgtu.com/i/qmcus1"><img src="https://s1.ax1x.com/2022/03/21/qmcus1.md.png" alt="qmcus1.md.png"></a></p><p>由于UDP不提供可靠传输服务，它仅在网际层的基础上添加了用于区分应用进程的端口，因此首部非常简单，仅有8个字节。</p><p>TCP首部格式比UDP复杂得多，其最小长度为20字节，最大长度为60字节，因为TCP要实现可靠传输、流量控制、拥塞控制等服务，其首部自然会比较复杂。首部中的字段比较多、首部长度也比较长。</p><p><a href="https://imgtu.com/i/qmjIDx"><img src="https://s1.ax1x.com/2022/03/21/qmjIDx.md.png" alt="qmjIDx.md.png"></a></p><h1>TCP的流量控制</h1><ul><li>一般来说，我们总是希望数据传输得更快一些。<ul><li>但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</li></ul></li><li>所谓流量控制（flow control）就是<strong>让发送方的发送速率不要太快，要让接收方来得及接收</strong>。</li><li>利用<strong>滑动窗口</strong>机制可以很方便地在TCP连接上实现对发送方的流量控制。<ul><li>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。</li><li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。</li></ul></li></ul><p><a href="https://imgtu.com/i/qneKwF"><img src="https://s1.ax1x.com/2022/03/21/qneKwF.md.png" alt="qneKwF.md.png"></a></p><p><a href="https://imgtu.com/i/qneylt"><img src="https://s1.ax1x.com/2022/03/21/qneylt.md.png" alt="qneylt.md.png"></a></p><h1>TCP的拥塞控制</h1><ul><li>在某段时间，若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏</strong>。这种情况就叫做<strong>拥塞</strong>（congestion）。<ul><li>在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。</li></ul></li><li>若<strong>出现拥塞而不进行控制</strong>，整个网络的<strong>吞吐量将随输入负荷的增大而下降</strong>。</li></ul><p><a href="https://imgtu.com/i/quJsxO"><img src="https://s1.ax1x.com/2022/03/21/quJsxO.md.png" alt="quJsxO.md.png"></a></p><h2 id="拥塞控制算法">拥塞控制算法</h2><p>下面介绍四种拥塞控制算法的基本原理，假定如下条件：</p><ol><li>数据是单方向传送，而另一个方向只传送确认。</li><li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li><li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li></ol><p><a href="https://imgtu.com/i/quNBin"><img src="https://s1.ax1x.com/2022/03/21/quNBin.md.png" alt="quNBin.md.png"></a></p><ul><li>发送方维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值<strong>取决于网络的拥塞程度</strong>，并且<strong>动态变化</strong>。<ul><li>拥塞窗口<strong>cwnd的维护原则</strong>：只要网络<strong>没有出现拥塞</strong>，<strong>拥塞窗口</strong>就再<strong>增大</strong>一些；但只要网络<strong>出现拥塞</strong>，<strong>拥塞窗口就减少</strong>一些。</li><li>判断出现<strong>网络拥塞的依据</strong>：没有按时收到应当到达的确认报文（即发生<strong>超时重传</strong>）。</li></ul></li><li>发送方将拥塞窗口作为<strong>发送窗口swnd</strong>，即<strong>swnd＝cwnd</strong>。</li><li>维护一个慢开始门限<strong>ssthresh</strong>状态变量：<ul><li>当cwnd＜ssthresh时，使用慢开始算法；</li><li>当cwnd＞ssthresh时，停止使用慢开始算法而改用拥塞避免算法：</li><li>当cwnd＝ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></li></ul><h3 id="慢开始（slow-star）和拥塞避免（congestion-avoidance）">慢开始（slow-star）和拥塞避免（congestion avoidance）</h3><p><a href="https://imgtu.com/i/quaIKK"><img src="https://s1.ax1x.com/2022/03/21/quaIKK.md.png" alt="quaIKK.md.png"></a></p><ul><li>“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；</li><li>“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现</li></ul><h3 id="快重传（fast-retransmit）和快恢复（fast-recovery）">快重传（fast retransmit）和快恢复（fast recovery）</h3><ul><li>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法（TCP Tahoe版本）ا</li><li>1990年又增加了两个新的拥塞控制算法（<strong>改进TCP的性能</strong>），这就是快重传和快恢复（TCP Reno版本）<ul><li>有时，<strong>个别报文段</strong>会在网络中<strong>丢失</strong>，但实际上网络<strong>并未发生拥塞</strong>。<ul><li>这将导致<strong>发送方</strong>超时重传，并<strong>误认为</strong>网络发生了<strong>拥塞</strong>；</li><li><strong>发送方把拥塞窗口cwnd又设置为最小值1</strong>，并错误地启动慢开始算法，因而<strong>降低了传输效率</strong>。</li></ul></li></ul></li></ul><h4 id="快重传算法">快重传算法</h4><ul><li>采用快重传算法可以<strong>让发送方尽早知道发生了个别报文段的丢失</strong>。</li><li>所谓快重传，就是使发送方<strong>尽快进行重传</strong>，而<strong>不是等超时重传计时器超时</strong>再重传。<ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong></li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。</li><li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段<strong>立即重传</strong>，而不是等该报文段的超时重传计时器超时再重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1），使用快重传可以使整个网络的吞吐量提高约20%。</li></ul></li></ul><p><a href="https://imgtu.com/i/quryb6"><img src="https://s1.ax1x.com/2022/03/21/quryb6.md.png" alt="quryb6.md.png"></a></p><h4 id="快恢复算法">快恢复算法</h4><ul><li>发送方一旦<strong>收到3个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而<strong>执行快恢复算法</strong><ul><li><strong>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法</strong>。</li><li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh＋3。<ul><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络：</li><li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</li><li>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</li></ul></li></ul></li></ul><p><a href="https://imgtu.com/i/qus4FU"><img src="https://s1.ax1x.com/2022/03/21/qus4FU.md.png" alt="qus4FU.md.png"></a></p><h1>TCP超时重传时间的选择</h1><ul><li>超时重传时间的选择是TCP最复杂的问题之一<ul><li>超时重传时间RTO小于往返时间RTT，会引起报文段不必要的重传，使网络负荷增大。</li><li>超时重传时间RTO的值远大于往返时间RTT，会使网络的空闲时间增大，降低了传输效率。</li><li>综合以上两种情况可以得出，超时重传时间RTO的值应略大于往返时间RTT的值。</li></ul></li><li><strong>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO</strong>。<s>（网络传输速率不是固定不变的，RTT这事潘子你把握不住</s><br><a href="https://imgtu.com/i/qugOjH"><img src="https://s1.ax1x.com/2022/03/21/qugOjH.md.png" alt="qugOjH.md.png"></a></li></ul><h2 id="加权平均往返时间RTTs">加权平均往返时间RTTs</h2><ul><li>利用每次测量得到的RTT样本，计算<strong>加权平均往返时间RTTs</strong>（又称为平滑的往返时间）。<ul><li>起初，<strong>RTTs1=RTT1</strong>,</li><li>之后的更新公式为：<strong>新的RTTs = (1-α)x 旧的RTTs + α x 新的RTT样本</strong></li><li>在上式中，0≤a＜1：<ul><li>若α很接近于0，则新RTT样本对RTTs的影响不大；</li><li>若a很接近于1，则新RTT样本对RTTs的影响较大；</li></ul></li><li>已成为建议标准的RFC6298推荐的α值为1/8，即0.125。</li></ul></li><li>用这种方法得出的加权平均往返时间RTTs就比测量出的RTT值更加平滑。</li><li>显然，超时重传时间RTO应略大于加权平均往返时间RTTs。</li></ul><h2 id="RFC6298建议的超时重传时间RTO计算方法">RFC6298建议的超时重传时间RTO计算方法</h2><p><a href="https://imgtu.com/i/qu2srd"><img src="https://s1.ax1x.com/2022/03/21/qu2srd.md.png" alt="qu2srd.md.png"></a></p><p>可以发现，RTTs和RTTD都是基于新的RTT样本进行计算的，如果测量到的样本不正确，那么计算出来的数值也不正确。然而往返时间RTT的测量是比较复杂的。</p><p><a href="https://imgtu.com/i/quRVzD"><img src="https://s1.ax1x.com/2022/03/21/quRVzD.md.png" alt="quRVzD.md.png"></a></p><p>从上图可以看出，当出现超时重传后，主机无法准确测量RTT。</p><h2 id="karn算法及其修正">karn算法及其修正</h2><ul><li>针对<strong>出现超时重传时无法测准往返时间RTT</strong>的问题，<strong>Karn</strong>提出了一个<strong>算法</strong>：<strong>在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本</strong>。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。<ul><li>这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。</li></ul></li><li>因此，要对<strong>Karn算法进行修正</strong>。方法是：<strong>报文段每重传一次，就把超时重传时间RTO增大一些</strong>。典型的做法是将新RTO的值取为旧RTO值的2倍。</li></ul><p><a href="https://imgtu.com/i/quR7lD"><img src="https://s1.ax1x.com/2022/03/21/quR7lD.md.png" alt="quR7lD.md.png"></a></p><h1>TCP可靠传输的实现</h1><p>TCP基于<strong>以字节为单位的滑动窗口</strong>来实现可靠传输</p><p><a href="https://imgtu.com/i/quf94x"><img src="https://s1.ax1x.com/2022/03/21/quf94x.md.png" alt="quf94x.md.png"></a></p><p><a href="https://imgtu.com/i/quf1xS"><img src="https://s1.ax1x.com/2022/03/21/quf1xS.md.png" alt="quf1xS.md.png"></a></p><p>（还有一个图没放上来，主要就是说接收方收到失序的数据，比如说当前想要31–51号的数据，但是收到了32和33，也就是31丢了。接收方不高兴了，说爷的31去哪了，于是发送ack给发送方。发送方收到后视若无睹，因为<s>真正的程序员从来不看warning</s>收到三次相同的重传请求才会进行重传，感觉可能缺失的数据堵路上啥的，这不一定是咱的问题啊，于是就继续发送后面的数据。过了一会接收方收到了它最爱的31号数据，很开心地告诉发送方自己收到了，发送ack说要34号数据。于是移动自己的滑动窗口，把31-33号数据交付给上层，然后把这些数据从自己的缓存里<s>拉出来</s>移出。接收方知道了发送方已经收到31-33号数据了，同样地移动滑动窗口，移出数据。如果发送方把自己滑动窗口内的所有数据都发送出去了，在收到接收方的确认之前都不会再移动窗口和发送数据。如果发送方一直等不到接收方的确认，就会<s>生气</s>超时重传，重新发送窗口内的数据。</p><p><s>知道为啥我不放图了吗，因为动画实在是太多了</s></p><ul><li>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，<strong>发送方的发送窗口并不总是和接收方的接收窗口一样大</strong>。<ul><li>网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。</li><li>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。</li></ul></li><li>对于<strong>不按序到达的数据应如何处理</strong>，TCP并无明确规定。<ul><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。</li><li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong>。</li></ul></li><li>TCP要求接收方必须有<strong>累积确认和捎带确认机制</strong>，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<ul><li><strong>接收方不应过分推迟发送确认</strong>，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。</li><li>TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认［RFC 1122］。</li><li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ul></li><li><strong>TCP的通信是全双工通信</strong>。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</li></ul><h1>TCP的运输连接管理</h1><ul><li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li><li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li><li>TCP运输连接有以下三个阶段：<ol><li>“三报文握手”建立TCP连接</li><li>数据传送</li><li>“四报文挥手”释放TCP连接</li></ol></li><li>TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。</li></ul><h2 id="TCP的连接建立">TCP的连接建立</h2><ul><li>TCP的连接建立要解决以下三个问题：<ol><li>使TCP双方能够确知对方的存在；</li><li>使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）；</li><li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ol></li></ul><h3 id="“三报文握手”建立连接过程">“三报文握手”建立连接过程</h3><p>假设两台要基于TCP进行通信的主机，其中一台主机中的某应用进程主动发起TCP连接建立，称为TCP客户，另一台主机中被动等待TCP连接建立的应用进程，称为TCP服务器。我们可以将TCP建立连接的过程比喻为<strong>握手</strong>，握手需要在TCP客户和服务器之间<strong>交换三个TCP报文段</strong>。</p><p>最初，两端的TCP进程都处于<strong>关闭状态</strong>。一开始，TCP服务器进程首先<strong>创建传输控制块</strong>，用来存储TCP连接中的一些重要信息，例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前发送和接收序号等。之后，就<strong>准备接受TCP客户进程的连接请求</strong>。此时，TCP服务器进程就进入<strong>监听状态</strong>，等待TCP客户进程的连接请求。TCP服务器进程是<strong>被动等待来自TCP客户进程的连接请求</strong>，而不是主动发起。因此称为<strong>被动打开连接</strong>。</p><p>TCP客户进程也是<strong>首先创建传输控制块</strong>，然后在打算建立TCP连接时向TCP服务器进程发送<strong>TCP连接请求报文段</strong>，并进入<strong>同步已发送状态</strong>。TCP连接请求报文段首部中的<strong>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</strong>。序号字段seq被设置为一个初始值x作为TCP客户进程所选择的初始序号。请注意：TCP规定<strong>SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</strong>。由于TCP连接建立是由TCP客户进程主动发起的，因此称为<strong>主动打开连接</strong>。</p><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送<strong>TCP连接请求确认报文段</strong>，并进入<strong>同步已接收状态</strong>。该报文段首部中的同步位<strong>SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段</strong>。序号字段seq被设置为一个初始值y作为TCP服务器进程所选择的初始序号。确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号的确认。请注意：这<strong>个报文段也不能携带数据，因为它是SYN被设置为1的报文段</strong>，但同样要消耗掉一个序号。</p><p>TCP客户进程收到TCP连接请求确认报文段后，<strong>还要向TCP服务器进程发送一个普通的TCP确认报文段</strong>，并进入<strong>连接已建立状态</strong>。该报文段首部中的确认位<strong>ACK被设置为1，表明这是一个普通的TCP确认报文段</strong>。序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，并且不携带数据，因此第二个报文段的序号为x+1。请注意：<strong>TCP规定普通的TCP确认报文段可以携带数据</strong>。但如果<strong>不携带数据，则不消耗序号</strong>。在这种情况下，所发送的下一个数据报文段的序号仍是x+1。确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认。</p><p>TCP服务器进程收到该确认报文段后，也进入连接已建立状态。现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接进行可靠的数据传输了。</p><p><a href="https://imgtu.com/i/qubxSA"><img src="https://s1.ax1x.com/2022/03/21/qubxSA.md.png" alt="qubxSA.md.png"></a></p><h3 id="“两报文握手”不可行的原因">“两报文握手”不可行的原因</h3><p>假设使用两报文握手，此时TCP客户端进程一开始发送了一个TCP请求报文，但是由于网络状态不佳没有及时发送出去，TCP客户端进程<s>按捺不住</s>超时重传TCP报文，之后TCP服务器进程顺利收到了该TCP报文，于是快快乐乐地建立连接、传输数据、释放连接。此时最开始的<s>怨种</s>TCP报文弯弯绕绕终于到达了TCP服务器，之后TCP服务器以为还要再来一次，告诉TCP客户端进程<s>派大星我们去抓水母吧！我准备好了我准备好了</s>自己进入已连接状态，TCP客户端进程觉得莫名其妙<s>进入章鱼哥状态</s>不予理睬。这个时候TCP服务器进程一直星星眼地等待TCP客户端进程发送数据<s>但是到头来只是一个舔狗罢了</s>，导致<s>TCP服务器进程被伤透了心</s>资源被大量浪费。</p><p><a href="https://imgtu.com/i/quL5b6"><img src="https://s1.ax1x.com/2022/03/21/quL5b6.md.png" alt="quL5b6.md.png"></a></p><p>综上所述，<s>努力的结果可能只是让事情变得更糟</s>采用三报文握手而不是两报文握手来建立TCP连接，是为了防止<s>世界上多一个怨种</s>已失效的连接请求报文段突然又传送到了TCP服务器进程，因而导致错误。</p><h2 id="TCP的连接释放">TCP的连接释放</h2><h3 id="“四报文挥手”释放连接过程">“四报文挥手”释放连接过程</h3><p>假设TCP客户进程的应用进程通知其主动关闭TCP连接，TCP客户进程会<strong>发送TCP连接释放报文段</strong>，并进入<strong>终止等待1状态</strong>。该报文段首部中的<strong>终止位FIN和确认位ACK的值都被设置为1</strong>，表明这是一个<strong>TCP连接释放报文段</strong>，同时也对之前收到的报文段进行确认。序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号+1。请注意：<strong>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</strong>。确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的数据的最后一个字节的序号+1。</p><p><s>太长不看：TCP客户进程不想喜欢TCP服务器进程了，发脾气了</s></p><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个<strong>普通的TCP确认报文段</strong>并<strong>进入关闭等待状态</strong>。该报文段首部中的确认位<strong>ACK的值被设置为1</strong>，表明这是一个<strong>普通的TCP确认报文段</strong>。序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号+1。这也与之前收到的TCP连接释放报文段中的确认号匹配。确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。TCP服务器进程这时应通知高层应用进程：TCP用户进程要断开与自己的TCP连接。此时，<strong>从TCP客户进程到TCP服务器进程这个方向的连接就释放了</strong>。</p><p><s>太长不看：TCP服务器进程知道人家不开心，去哄人家，但是人家是个直男让TCP客户进程更生气了，于是TCP客户进程直接和TCP服务器进程冷战了</s></p><p>这时的<strong>TCP连接处于半关闭状态</strong>，也就是<strong>TCP客户进程已经没有数据要发送了，但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收</strong>。也就是说，<strong>从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</strong>。这个状态可能会持续一段时间。TCP客户进程收到TCP确认报文段后，就进入终止等待2状态。等待TCP服务器进程发出的TCP连接释放报文段。</p><p><s>太长不看：虽然TCP客户进程和TCP服务器进程冷战了，但是还没删联系方式，TCP服务器进程还能骚扰人家。TCP客户进程就等这个b啥时候能结束</s></p><p>若使用TCP服务器进程的应用进程已经<strong>没有数据要发送了，应用进程就通知其服务器进程释放连接</strong>。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为<strong>被动关闭连接</strong>。TCP服务器进程发送<strong>TCP连接释放报文段</strong>并进入<strong>最后确认状态</strong>，该报文段首部中的<strong>终止位FIN和确认位ACK的值都被设置为1</strong>，表明这是一个<strong>TCP连接释放报文段</strong>，同时也对之前收到的报文段进行确认。现在假定seq字段的值为w。这时因为在半关闭状态下TCP服务器进程可能又发送了一些数据。确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p><p><s>太长不看：TCP服务器进程骚扰不动了，累了，说咱就这样吧</s></p><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送<strong>普通的TCP确认报文段</strong>，之后进入<strong>时间等待状态</strong>。该报文段首部中的确认位<strong>ACK的值被设置为1</strong>，表明这是一个普通的TCP确认报文段。序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号。确认号ack字段的值设置为w+1，这时对所收到的TCP连接释放报文段的确认。TCP服务器进程收到该报文段后，就进入关闭状态。</p><p><s>太长不看：TCP客户进程答应了，TCP服务器进程感觉没有挽回余地了就撤了准备投入下一个应用进程的怀抱（不是</s></p><p>而TCP客户进程还要<strong>经过两倍的MSL后才能进入关闭状态</strong>。MSL的意思是最长报文段寿命，RFC793文档建议为两分钟。也就是说TCP客户进程进入时间等待状态后，还要经过四分钟才能进入关闭状态，这完全是从工程上来考虑的。对于现在的网络，MSL取为2分钟可能太长，因此TCP允许不同的时限，可根据具体情况使用更小的MSL值。</p><p><s>太长不看：TCP客户进程以为对方会挽留自己，等啊等啊等啊等，结果发现自己只是个怨种，也不干了投入下一个TCP服务器进程的怀抱（没有</s></p><p><a href="https://imgtu.com/i/qKRJvF"><img src="https://s1.ax1x.com/2022/03/22/qKRJvF.md.png" alt="qKRJvF.md.png"></a></p><h3 id="设置时间等待状态的原因">设置时间等待状态的原因</h3><p>如果TCP客户进程没有设置停止等待时间<s>也就是不存对方来挽留自己的幻想</s>，如果在TCP服务器进程处于最后确认时期，TCP客户进程发送的TCP确认报文丢失了<s>也就是TCP服务器进程没有等来对方的回应</s>。这时TCP客户进程已经<s>另寻新欢</s>进入关闭状态，而TCP服务器进程一直在苦苦地等待回应，不停地<s>骚扰人家</s>超时重传，但是TCP客户进程<s>想着哪来的舔狗真下头</s>不对该报文段进行回应，而TCP服务进程一直无法进入关闭状态。</p><p><s>所以舔狗不得house</s></p><p>因此，时间等待状态以及处于该状态2倍MSL的时长可以<strong>确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</strong>。另外，TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长就可以<strong>使本次连接持续时间内所产生的所有报文段都从网络中消失</strong>，这样就可以使<strong>下一个新的TCP连接中不会出现旧连接中的报文段</strong>。</p><p><a href="https://imgtu.com/i/qK4JiR"><img src="https://s1.ax1x.com/2022/03/22/qK4JiR.md.png" alt="qK4JiR.md.png"></a></p><h3 id="保活计时器">保活计时器</h3><p>设想一种情况：TCP双方已经建立了连接，后来TCP客户进程所在的主机突然出现了故障。显然，TCP服务器进程以后就不能再收到TCP客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。换句话说，TCP服务器进程应该如何发现这种情况？方法就是使用保活计时器。</p><ul><li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动<strong>保活计时器</strong>（2小时定时）</li><li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则<strong>当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段</strong>，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li></ul><p><s>也就是定期检测对方还活着，如果没有就赶紧跑路吧不要在一棵树上吊死</s></p><h1>TCP报文段的首部格式</h1><ul><li>为了实现可靠传输，TCP采用了<strong>面向字节流</strong>的方式。</li><li>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为<strong>TCP报文段</strong>后进行发送。<ul><li>一个TCP报文段由<strong>首部</strong>和<strong>数据载荷</strong>两部分构成；</li><li>TCP的全部功能都体现在它首部中各字段的作用。</li></ul></li></ul><p><a href="https://imgtu.com/i/qMe9US"><img src="https://s1.ax1x.com/2022/03/22/qMe9US.md.png" alt="qMe9US.md.png"></a></p><h2 id="源端口字段">源端口字段</h2><ul><li>占16比特，写入源端口号</li><li>用来<strong>标识发送该TCP报文段的应用进程</strong>。</li></ul><h2 id="目的端口字段">目的端口字段</h2><ul><li>目的端口：占16比特，写入目的端口号</li><li>用来<strong>标识接收该TCP报文段的应用进程</strong>。</li></ul><h2 id="序号字段">序号字段</h2><ul><li>占32比特，取值范围$[0,2^{32}—1]$，序号增加到最后一个后，下一个序号就又回到0。<strong>指出本TCP报文段数据载荷的第一个字节的序号。</strong><br><a href="https://imgtu.com/i/qMmFIO"><img src="https://s1.ax1x.com/2022/03/22/qMmFIO.md.png" alt="qMmFIO.md.png"></a></li></ul><h2 id="确认号字段">确认号字段</h2><ul><li>占32比特，取值范围$[0,2^{32}—1]$，确认号增加到最后一个后，下一个确认号就又回到0。</li><li><strong>指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</strong></li><li>若确认号=n，则表明<strong>到序号n-1为止的所有数据都已正确接收</strong>，期望<strong>接收序号为n的数据</strong>。</li></ul><h2 id="确认标志位ACK字段">确认标志位ACK字段</h2><ul><li>取值为1时确认号字段才有效；取值为0时确认号字段无效。</li><li><strong>TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1</strong>。</li></ul><h2 id="数据偏移字段">数据偏移字段</h2><ul><li>占4比特，并以4字节为单位。</li><li><strong>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。</strong></li><li>这个字段实际上是指出了<strong>TCP报文段的首部长度</strong>。<ul><li>首部固定长度为20字节，因此数据偏移字段的最小值为$(0101)_2$</li><li>首部最大长度为60字节，因此数据偏移字段的最大值为$(1111)_2$</li></ul></li></ul><h2 id="保留字段">保留字段</h2><ul><li>占6比特，保留为今后使用，但目前置为0</li></ul><p><s>果然人类都是喜欢为不确定的未来做点确定的无用功</s></p><h2 id="窗口字段">窗口字段</h2><ul><li>占16比特，以字节为单位。<strong>指出发送本报文段的一方的接收窗口</strong>。</li><li>窗口值作为接收方<strong>让发送方设置其发送窗口的依据</strong>。</li><li>这是<strong>以接收方的接收能力来控制发送方的发送能力</strong>，称为流量控制。</li></ul><p>（发送窗口的大小还取决于拥塞窗口的大小，取接收窗口和拥塞窗口的小者</p><h2 id="校验和字段">校验和字段</h2><ul><li>占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。</li><li>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</li></ul><h2 id="同步标志位SYN">同步标志位SYN</h2><ul><li>在TCP连接建立时用来同步序号</li></ul><p><a href="https://imgtu.com/i/qMKclQ"><img src="https://s1.ax1x.com/2022/03/22/qMKclQ.md.png" alt="qMKclQ.md.png"></a></p><h2 id="终止标志位FIN">终止标志位FIN</h2><p>用来释放TCP连接</p><p><a href="https://imgtu.com/i/qMK7pF"><img src="https://s1.ax1x.com/2022/03/22/qMK7pF.md.png" alt="qMK7pF.md.png"></a></p><h2 id="复位标志位RST">复位标志位RST</h2><ul><li>用来复位TCP连接。</li><li>当<strong>RST=1时，表明TCP连接出现了异常</strong>，必须释放连接，然后再重新建立连接。</li><li>RST置1还用来<strong>拒绝一个非法的报文段</strong>或<strong>拒绝打开一个TCP连接</strong>。</li></ul><h2 id="推送标志位PSH">推送标志位PSH</h2><p>接收方的TCP收到该标志位为1的报文段会<strong>尽快上交应用进程</strong>，而不必等到接收缓存都填满后再向上交付。</p><h2 id="紧急标志位URG、紧急指针字段">紧急标志位URG、紧急指针字段</h2><p>用于实现紧急操作</p><ul><li>紧急标志位URG：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。</li><li>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。</li></ul><p>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。</p><p>接收方收到紧急标志为1的报文段，会按照紧急指针字段的值从报文段数据载荷部分取出紧急数据，并直接上交应用进程，而不必在接收缓存中排队。</p><h2 id="选项字段">选项字段</h2><p>增加选项可以增加TCP的功能，目前有以下选项：</p><ul><li>最大报文段长度MSS选项：用于指出TCP报文段数据载荷部分的最大长度。</li><li>窗口扩大选项：为了扩大窗口（提高吞吐率）。</li><li>时间戳选项：<ul><li>用来计算往返时间RTT</li><li>用于处理序号超范围的情况，又称为防止序号绕回PAWS。</li></ul></li><li>选择确认选项：用来实现选择确认功能。</li></ul><h2 id="填充字段">填充字段</h2><p>由于选项的长度可变，因此使用填充来<strong>确保报文段首部能被4整除</strong>（因为数据偏移字段，也就是首部长度字段，是以4字节为单位的）。</p>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运输层 </tag>
            
            <tag> 端口号 </tag>
            
            <tag> 复用与分用 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
            <tag> 流量控制 </tag>
            
            <tag> 拥塞控制 </tag>
            
            <tag> 超时重传时间选择 </tag>
            
            <tag> 三报文握手 </tag>
            
            <tag> 四报文挥手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-网络层</title>
      <link href="/2022/03/18/computerInternet-4/"/>
      <url>/2022/03/18/computerInternet-4/</url>
      
        <content type="html"><![CDATA[<p>上一章的数据链路层内容真的好多，光md文件就有62KB</p><p>再加上中间跑去刷算法了，就鸽了很久</p><p>但是细心的可以发现，算法的最后一篇和这篇的发布时间是隔了一段时间的</p><p><s>就是小黎刷算法太累了给自己放了个小长假</s></p><p>总之终于开始新的一章啦！</p><span id="more"></span><h1>网络层概述</h1><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而实现<strong>数据包在各网络之间的传输</strong>。</li><li>要实现网络层任务，需要解决以下主要问题：<ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li><li>网络层寻址问题</li><li>路由选择问题</li></ul></li><li><strong>因特网</strong>（Internet）是目前全世界用户数量最多的互联网，它使用<strong>TCP/IP协议栈</strong>。</li><li>由于TCP/IP协议栈的网络层使用<strong>网际协议IP</strong>，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为<strong>网际层</strong>。</li><li>本章通过学习TCP/IP协议栈的网际层来学习网络层的理论知识和实践技术。</li></ul><p><a href="https://imgtu.com/i/qFBGmn"><img src="https://s1.ax1x.com/2022/03/18/qFBGmn.md.png" alt="qFBGmn.png"></a></p><h1>网络层提供的两种服务</h1><h2 id="面向连接的虚电路服务">面向连接的虚电路服务</h2><ul><li>核心思想：<strong>可靠通信由网络来保证</strong></li><li>必须建立<strong>网络层的连接</strong>——<strong>虚电路VC</strong>（Virtual Circuit）</li><li>通信双方<strong>沿着已建立的虚电路发送分组</strong></li><li>目的主机的地址仅在连接建立阶段使用，之后每个<strong>分组的首部只需携带一条虚电路的编号</strong>（构成虚电路的每一段链路都有一个虚电路编号）。</li><li>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）。</li><li><strong>通信结束后，需要释放之前所建立的虚电路</strong>。</li><li>很多广域分组交换网都使用面向连接的虚电路服务。例如，曾经的X．25和逐渐过时的帧中继FR、异步传输模式ATM等。</li></ul><p><a href="https://imgtu.com/i/qF66J0"><img src="https://s1.ax1x.com/2022/03/18/qF66J0.md.png" alt="qF66J0.md.png"></a></p><h2 id="无连接的数据报服务">无连接的数据报服务</h2><ul><li>核心思想：<strong>可靠通信应当由用户主机来保证</strong></li><li><strong>不需要建立网络层连接</strong></li><li><strong>每个分组可走不同的路径</strong></li><li>每个分组的<strong>首部必须携带目的主机的完整地址</strong></li><li>这种通信方式所传送的<strong>分组可能误码</strong>、<strong>丢失</strong>、<strong>重复</strong>和<strong>失序</strong>。</li><li>由于<strong>网络本身不提供端到端的可靠传输服务</strong>，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>因特网采用了这种设计思想，也就是<strong>将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层）</strong>，而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li></ul><p><a href="https://imgtu.com/i/qF6zTA"><img src="https://s1.ax1x.com/2022/03/18/qF6zTA.md.png" alt="qF6zTA.md.png"></a></p><h2 id="虚电路服务与数据报服务的比较">虚电路服务与数据报服务的比较</h2><table><thead><tr><th>对比方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须建立网络层连接</td><td>不需要建立网络层连接</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组可走不同的路由</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点时不一定按发送顺序</td></tr><tr><td>服务质量保证</td><td>可以将通信资源提前分配给每一个虚电路，容易实现</td><td>很难实现</td></tr></tbody></table><p>由于TCP/IP体系结构的因特网的网际层提供的是简单灵活、无连接的、尽最大努力交付的数据报服务，因此本章主要围绕网际层如何传送IP数据报这个主题进行讨论。</p><h1>IPv4地址</h1><ul><li><strong>IPv4地址</strong>就是给因特网（Internet）上的<strong>每一台主机（或路由器）的每一个接口</strong>分配一个在全世界范围内是<strong>唯一的32比特的标识符</strong>。</li><li>IP地址由因特网名字和数字分配机构ICANN（Internet Corporation for Assigned Names and Numbers）进行分配。<ul><li>我国用户可向亚太网络信息中心APNIC（Asia Pacific Network Information Center）申请IP地址，需要缴费。</li><li>2011年2月3日，互联网号码分配管理局IANA（由ICANN行使职能）宣布，IPv4地址已经分配完毕。</li><li>我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。</li></ul></li><li><strong>IPv4地址的编址方法经历了如下三个历史阶段：</strong></li></ul><p><a href="https://imgtu.com/i/qFWubF"><img src="https://s1.ax1x.com/2022/03/18/qFWubF.md.png" alt="qFWubF.md.png"></a></p><ul><li>32比特的IPv4地址不方便阅读、记录以及输入等，因此IPv4地址采用<strong>点分十进制表示方法</strong>以方便用户使用。</li></ul><p><a href="https://imgtu.com/i/qFRTBD"><img src="https://s1.ax1x.com/2022/03/18/qFRTBD.md.png" alt="qFRTBD.md.png"></a></p><h2 id="分类编址的IPv4地址">分类编址的IPv4地址</h2><p>分类编址的IPv4地址分为A、B、C、D、E五类</p><p><a href="https://imgtu.com/i/qkA6SJ"><img src="https://s1.ax1x.com/2022/03/18/qkA6SJ.md.png" alt="qkA6SJ.png"></a></p><p>需要注意的是：</p><ul><li>只有A类、B类和C类地址可分配给网络中的主机或路由器的各接口</li><li>主机号为“全0”的地址是网络地址，不能分配给主机或路由器的各接口</li><li>主机号为“全1”的地址是广播地址，不能分配给主机或路由器的各接口</li></ul><h3 id="A类地址">A类地址</h3><p><a href="https://imgtu.com/i/qkEIH0"><img src="https://s1.ax1x.com/2022/03/18/qkEIH0.png" alt="qkEIH0.png"></a></p><h3 id="B类地址">B类地址</h3><p><a href="https://imgtu.com/i/qkVGKs"><img src="https://s1.ax1x.com/2022/03/18/qkVGKs.png" alt="qkVGKs.png"></a></p><h3 id="C类地址">C类地址</h3><p><a href="https://imgtu.com/i/qkZPZq"><img src="https://s1.ax1x.com/2022/03/18/qkZPZq.png" alt="qkZPZq.png"></a></p><h3 id="ABC类IP地址类别判断">ABC类IP地址类别判断</h3><ol><li><p>根据地址左起第一个十进制数的值，可以判断出网络类别（小于127的为A类，128～191的为B类，192～223的为C类）</p></li><li><p>根据网络类别，就可找出地址中的网络号部分和主机号部分（A类地址网络号为左起第一个字节，B类地址网络号为左起前两个字节，C类地址网络号为左起前三个字节）</p></li><li><p>以下三种情况的地址不能指派给主机或路由器接口：</p><ol><li>A类网络号0和127</li><li>主机号为“全0”，这是网络地址</li><li>主机号为“全1”，这是广播地址</li></ol></li></ol><h3 id="特殊的IPv4地址">特殊的IPv4地址</h3><p>地址0.0.0.0是一个特殊的IPv4地址，只能作为源地址使用，表示“在本网络上的本主机”封装有DHCP Discovery报文的IP分组的源地址使用0.0.0.0。</p><p>以127开头且后面三个字节非“全0”或“全1”的IP地址是一类特殊的IPv4地址，既可以作为源地址使用，也可以作为目的地址使用，用于本地软件环回测试，例如常用的环回测试地址127.0.0.1。</p><p>地址255.255.255.255是一个特殊的IPv4地址，只能作为目的地址使用，表示“只在本网络上进行广播（各路由器均不转发）”。</p><p>还有一些一般不使用的特殊IP地址如下：</p><table><thead><tr><th>网络号</th><th>主机号</th><th>作为源地址</th><th>作为目的地址</th><th>代表的含义</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上的本主机(DHCP协议)</td></tr><tr><td>0</td><td>host-id</td><td>可以</td><td>不可</td><td>在本网络上的某台主机host-id</td></tr><tr><td>全1</td><td>全1</td><td>不可</td><td>可以</td><td>只在本网络上进行广播(各路由器均不转发)</td></tr><tr><td>net-id</td><td>全1</td><td>不可</td><td>可以</td><td>对net-id上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0或全1</td><td>可以</td><td>可以</td><td>用于本地软件环回测试</td></tr></tbody></table><h2 id="划分子网的IPv4地址">划分子网的IPv4地址</h2><ul><li>为新增网络申请新的网络号会带来以下弊端：<ul><li>需要等待时间和花费更多的费用</li><li>会增加其他路由器中路由表记录的数量</li><li>浪费原有网络号中剩余的大量IP地址</li></ul></li><li>可以从主机号部分借用一部分比特作为子网号</li></ul><h3 id="子网掩码">子网掩码</h3><p><strong>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号</strong>：</p><ul><li>子网掩码使用<strong>连续的比特1来对应网络号和子网号</strong></li><li>子网掩码使用<strong>连续的比特0来对应主机号</strong></li><li>将划分子网的<strong>IPv4地址</strong>与其相应的<strong>子网掩码</strong>进行<strong>逻辑与运算</strong>就可得到IPv4地址<strong>所在子网的网络地址</strong></li></ul><p><a href="https://imgtu.com/i/qkn0T1"><img src="https://s1.ax1x.com/2022/03/18/qkn0T1.md.png" alt="qkn0T1.md.png"></a></p><h3 id="子网划分细节">子网划分细节</h3><p>给定一个分类的IP地址和其相应的子网掩码，就可知道子网划分的细节：</p><ul><li>划分出的子网数量</li><li>每个子网可分配的IP地址数量</li><li>每个子网的网络地址和广播地址</li><li>每个子网可分配的最小和最大地址</li></ul><p>例如，已知某个网络的地址为<strong>218.75.230.0</strong>，使用子网掩码<strong>255.255.255.128</strong>对其进行划分：</p><p><a href="https://imgtu.com/i/qkuZA1"><img src="https://s1.ax1x.com/2022/03/18/qkuZA1.md.png" alt="qkuZA1.md.png"></a></p><p><a href="https://imgtu.com/i/qkuOgO"><img src="https://s1.ax1x.com/2022/03/18/qkuOgO.png" alt="qkuOgO.png"></a></p><h3 id="默认子网掩码">默认子网掩码</h3><p>默认子网掩码是指在未划分子网的情况下使用的子网掩码</p><p><a href="https://imgtu.com/i/qkMEJx"><img src="https://s1.ax1x.com/2022/03/18/qkMEJx.md.png" alt="qkMEJx.md.png"></a></p><h2 id="无分类编址的IPv4地址">无分类编址的IPv4地址</h2><p>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是<strong>数量巨大的C类网</strong>因为其<strong>地址空间太小</strong>并<strong>没有得到充分使用</strong>，而因特网的IP地址仍在加速消耗，整个<strong>IPv4地址空间面临全部耗尽的威胁</strong>。</p><p>为此，因特网工程任务组IETF又提出了采用<strong>无分类编址</strong>的方法来解决IP地址紧张的问题，同时还专门成立IPv6工作组负责研究新版本IP以彻底解决IP地址耗尽问题。</p><p>1993年，IETF发布了<strong>无分类域间路由选择CIDR</strong>（Classless Inter-Domain Routing）的RFC文档：RFC 1517~1519和1520。</p><ul><li><strong>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念</strong>；</li><li><strong>CIDR可以更加有效地分配IPv4的地址空间</strong>，并且可以在新的IPv6使用之前允许因特网的规模继续增长。</li></ul><p>CIDR使用“<strong>斜线记法</strong>”，或称CIDR记法。即在IPv4地址后面加上斜线“/”，在<strong>斜线后面写上网络前缀所占的比特数量</strong>。</p><p><a href="https://imgtu.com/i/qk35DO"><img src="https://s1.ax1x.com/2022/03/18/qk35DO.md.png" alt="qk35DO.md.png"></a></p><p>CIDR实际上是<strong>将网络前缀都相同的连续的IP地址组成一个“CIDR地址块”</strong>。</p><h3 id="CIDR地址块细节">CIDR地址块细节</h3><p>我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节：</p><ul><li>地址块的最小地址</li><li>地址块的最大地址</li><li>地址块中的地址数量</li><li>地址块聚合某类网络（A类、B类或C类）的数量地址掩码（也可继续称为子网掩码）</li></ul><p>例如对于CIDR地址块<strong>128.14.35.7/20</strong></p><p><a href="https://imgtu.com/i/qk8XFJ"><img src="https://s1.ax1x.com/2022/03/18/qk8XFJ.png" alt="qk8XFJ.png"></a></p><h3 id="路由聚合（构造超网）">路由聚合（构造超网）</h3><p>保留共同前缀，后面都取0，再加上“/共同前缀长度”，即为聚合地址块。</p><p><a href="https://imgtu.com/i/qkJxr6"><img src="https://s1.ax1x.com/2022/03/18/qkJxr6.png" alt="qkJxr6.png"></a></p><p><strong>网络前缀越长，地址块越小，路由越具体</strong>；</p><p>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为<strong>最长前缀匹配</strong>，因为这样的路由更具体。</p><h2 id="IPv4地址的应用规划">IPv4地址的应用规划</h2><h3 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）">定长的子网掩码FLSM（Fixed Length Subnet Mask）</h3><ul><li>使用<strong>同一个子网掩码</strong>来划分子网</li><li>子网<strong>划分方式不灵活</strong>：只能划分出2^n个子网（n是从主机号部分借用的用来作为子网号的比特数量）</li><li>每个子网所<strong>分配的IP地址数量相同</strong>，容易造成<strong>IP地址浪费</strong>。</li></ul><p><a href="https://imgtu.com/i/qka69e"><img src="https://s1.ax1x.com/2022/03/18/qka69e.png" alt="qka69e.png"></a></p><h3 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）">变长的子网掩码VLSM（Variable Length Subnet Mask）</h3><ul><li>使用<strong>不同的子网掩码</strong>来划分子网</li><li>子网<strong>划分方式灵活</strong>：可以<strong>按需分配</strong></li><li>每个子网所<strong>分配的IP地址数量可以不同</strong>，尽可能<strong>减少对IP地址的浪费</strong>。</li></ul><p><a href="https://imgtu.com/i/qkaQ00"><img src="https://s1.ax1x.com/2022/03/18/qkaQ00.png" alt="qkaQ00.png"></a></p><h1>IP数据报的发送和转发过程</h1><p>IP数据报的发送和转发过程包含以下两部分：</p><ul><li>主机发送IP数据报</li><li>路由器转发IP数据报</li></ul><h2 id="主机发送IP数据报">主机发送IP数据报</h2><ul><li>若在同一个网络，则属于直接交付；</li><li>若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发；</li></ul><p><a href="https://imgtu.com/i/qAxKCn"><img src="https://s1.ax1x.com/2022/03/19/qAxKCn.md.png" alt="qAxKCn.md.png"></a></p><h3 id="源主机判断目的主机是否与自己在同一网络">源主机判断目的主机是否与自己在同一网络</h3><p>将目的IP地址与自身掩码相与，与自身IP地址与自身掩码相与的结果作对比，若不相等则不在同一网络中，为间接交付。</p><p><a href="https://imgtu.com/i/qAzkGR"><img src="https://s1.ax1x.com/2022/03/19/qAzkGR.md.png" alt="qAzkGR.md.png"></a></p><h3 id="源主机判断间接交付所用路由器">源主机判断间接交付所用路由器</h3><p>当本网络中主机要与其他网络中主机进行通信时，会将IP数据报传输给默认网关，由默认网关将IP数据报转发出去。</p><p><a href="https://imgtu.com/i/qESzEF"><img src="https://s1.ax1x.com/2022/03/19/qESzEF.md.png" alt="qESzEF.md.png"></a></p><h2 id="路由器转发IP数据报">路由器转发IP数据报</h2><ol><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机；</li><li>若没有出错，则进行转发；</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳；</li><li>若找不到，则丢弃该IP数据报并通告源主机；</li></ul></li></ol><p><a href="https://imgtu.com/i/qE9es0"><img src="https://s1.ax1x.com/2022/03/19/qE9es0.md.png" alt="qE9es0.md.png"></a></p><p>路由器不对广播数据报进行转发，是隔离广播域的</p><p><a href="https://imgtu.com/i/qE9WTS"><img src="https://s1.ax1x.com/2022/03/19/qE9WTS.md.png" alt="qE9WTS.md.png"></a></p><p><a href="https://imgtu.com/i/qEEqgg"><img src="https://s1.ax1x.com/2022/03/19/qEEqgg.md.png" alt="qEEqgg.md.png"></a></p><h1>静态路由配置及其可能产生的路由环路问题</h1><ul><li>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器<strong>人工配置路由表</strong>。<ul><li>这种人工配置方式简单、开销小。但<strong>不能及时适应网络状态（流量、拓扑等）的变化</strong>。</li><li>一般只在小规模网络中采用。</li></ul></li><li>使用静态路由配置可能出现以下导致产生路由环路的错误<ul><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ul></li></ul><h2 id="静态路由配置">静态路由配置</h2><p>对于如下网络，由于路由器接口与网络直连，可以直接将网络及其接口加入路由表，类型属于直连。</p><p><a href="https://imgtu.com/i/qEAFiT"><img src="https://s1.ax1x.com/2022/03/19/qEAFiT.md.png" alt="qEAFiT.md.png"></a></p><p>假设R1要发送数据报到192.168.2.0/24网络中的某个主机，应该将数据报转发给R2的接口0，但R1的路由表中并没有关于该目的网络的路由条目，即R1并不知道目的网络的存在。因此，可以使用路由器相关的配置命令，给R1添加一条到达该目的网络的路由条目。</p><p><a href="https://imgtu.com/i/qEA2mn"><img src="https://s1.ax1x.com/2022/03/19/qEA2mn.md.png" alt="qEA2mn.md.png"></a></p><p>同理如下：</p><p><a href="https://imgtu.com/i/qEA76J"><img src="https://s1.ax1x.com/2022/03/19/qEA76J.md.png" alt="qEA76J.md.png"></a></p><h2 id="默认路由">默认路由</h2><p>假设R1要转发一个IP数据报给因特网中某个网络中的某个主机，从图中可以看出，R1应该将该IP数据报转发给路由器R2的接口0.由于因特网中包含了众多的网络，如果我们给R1添加针对这些网络的每一条路由条目，则会给人工配置带来巨大的工作量，并且使R1的路由表变得非常大，降低了查表转发的速度。</p><p>实际上，对于具有相同下一跳的不同目的网络的路由条目，我们可以用一条默认路由条目来替代。默认路由条目中的目的网络地址为0.0.0.0，地址掩码也为0.0.0.0，CIDR形式为0.0.0.0/0。对于本例，默认路由条目中的下一跳是路由器R2的接口0的地址。由于默认路由也是由人工配置的，因此其类型也为静态。</p><p><a href="https://imgtu.com/i/qEesNq"><img src="https://s1.ax1x.com/2022/03/19/qEesNq.md.png" alt="qEesNq.md.png"></a></p><h2 id="特定主机路由">特定主机路由</h2><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目。一般用于网络管理人员对网络的管理和测试。另外，在需要考虑某种安全问题时，也可以采用特定主机路由。</p><p><a href="https://imgtu.com/i/qEmlxU"><img src="https://s1.ax1x.com/2022/03/19/qEmlxU.md.png" alt="qEmlxU.md.png"></a></p><h2 id="静态路由配置错误导致路由环路">静态路由配置错误导致路由环路</h2><p><a href="https://imgtu.com/i/qEmOJ0"><img src="https://s1.ax1x.com/2022/03/19/qEmOJ0.md.png" alt="qEmOJ0.md.png"></a></p><p>为了<strong>防止IP数据报在路由环路中永久兜圈</strong>，在IP数据报首部设有<strong>生存时间TTL</strong>字段。IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃。</p><h2 id="聚合不存在网络而导致路由环路">聚合不存在网络而导致路由环路</h2><p><a href="https://imgtu.com/i/qEu9c8"><img src="https://s1.ax1x.com/2022/03/19/qEu9c8.md.png" alt="qEu9c8.md.png"></a></p><p><a href="https://imgtu.com/i/qEuIEj"><img src="https://s1.ax1x.com/2022/03/19/qEuIEj.md.png" alt="qEuIEj.md.png"></a></p><p>针对这种情况，可以添加针对所聚合的、不存在的网络的黑洞路由。黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，数据报进入该虚拟接口后路由器会将其丢弃（就像个黑洞，有去无回的那种</p><p>对于下例，根据最长前缀匹配原则，IP数据报就会直接进入黑洞</p><p><a href="https://imgtu.com/i/qEKVqe"><img src="https://s1.ax1x.com/2022/03/19/qEKVqe.md.png" alt="qEKVqe.md.png"></a></p><h2 id="网络故障而导致路由环路">网络故障而导致路由环路</h2><p>假设路由器R1检测到其接口0所直连的网络出现了故障而不可达，就会自动在其路由表中删除其直连网络的路由条目。之后R2要转发IP数据报到该网络，从而导致路由环路。</p><p><a href="https://imgtu.com/i/qEM9eg"><img src="https://s1.ax1x.com/2022/03/19/qEM9eg.md.png" alt="qEM9eg.md.png"></a></p><p>针对这种情况，可以在R1的路由表中添加针对该直连网络的黑洞路由。</p><p><a href="https://imgtu.com/i/qEQLxP"><img src="https://s1.ax1x.com/2022/03/19/qEQLxP.md.png" alt="qEQLxP.md.png"></a></p><p>假设过一段时间后故障消失，黑洞路由就会自动失效，路由器自动添加针对该直连网络的路由条目。如果再次出现故障，则路由器自动删除针对该直连网络的路由条目，黑洞路由也会自动生效。<s>于是只有路由器受伤的世界完成了</s></p><h1>路由选择协议</h1><h2 id="路由选择协议概述">路由选择协议概述</h2><h3 id="静态路由选择：">静态路由选择：</h3><ul><li>由<strong>人工配置</strong>的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由。</li><li>这种人工配置方式简单、开销小。但<strong>不能及时适应网络状态（流量、拓扑等）的变化</strong>。</li><li>一般只在<strong>小规模网络</strong>中采用。</li></ul><h3 id="动态路由选择：">动态路由选择：</h3><ul><li>路由器通过路由选择协议<strong>自动获取路由信息</strong>。</li><li>比较复杂、开销比较大。<strong>能较好地适应网络状态的变化</strong>。</li><li>适用于<strong>大规模网络</strong>。</li></ul><h3 id="因特网所采用的路由选择协议的主要特点：">因特网所采用的路由选择协议的主要特点：</h3><p><strong>自适应</strong>：动态路由选择，能较好地适应网络状态的变化<br><strong>分布式</strong>：路由器之间交换路由信息<br><strong>分层次</strong>：将整个因特网划分为许多较小的自治系统AS（Autonomous System）</p><p><a href="https://imgtu.com/i/qEJzZV"><img src="https://s1.ax1x.com/2022/03/19/qEJzZV.md.png" alt="qEJzZV.md.png"></a></p><h3 id="常见的路由选择协议：">常见的路由选择协议：</h3><p><a href="https://imgtu.com/i/qEJTIS"><img src="https://s1.ax1x.com/2022/03/19/qEJTIS.md.png" alt="qEJTIS.md.png"></a></p><h3 id="路由器的基本结构">路由器的基本结构</h3><p>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。</p><p>路由器结构可以划分为两大部分，一个是<strong>路由选择部分</strong>，另一个是<strong>分组转发部分</strong>。</p><p>路由选择部分的核心构件是<strong>路由选择处理机</strong>，它的任务是根据所使用的路由选择协议，周期性地与其他路由器进行路由信息的交互来更新路由表。</p><p>分组转发部分由三部分构成，分别是交换结构、一组输入端口和一组输出端口。信号从某个输入端口进入路由器，物理层将信号转换成比特流送交数据链路层处理。数据链路层从比特流中识别出帧，去掉帧头和帧尾后送交网络层处理。</p><p>如果送交网络层的分组是<strong>普通待转发的数据分组</strong>，则根据分组首部中的目的地址进行<strong>查表转发</strong>，若找不到匹配的转发条目，则丢弃该分组；否则按照匹配条目中所指示的端口进行转发。网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1。然后送交数据链路层进行封装。数据链路层将数据分组封装成帧，送交物理层处理。物理层将帧看作是比特流，将其变换成相应的电信号进行发送。</p><p>如果送交网络层的分组是路由器之间交换路由信息的<strong>路由报文</strong>，则把这种分组<strong>送交路由选择处理机</strong>，路由选择处理机根据分组的内容，来更新自己的路由表。路由表一般仅包含<strong>从目的网络到下一跳的映射</strong>，路由表需要对网络拓扑变化的计算最优化。而转发表是从路由表得出的，转发表的结构应当使查找过程最优化。</p><p>路由选择处理机除了处理收到的路由报文外，还会<strong>周期性地给其他路由器发送自己所知道的路由信息</strong>。路由器的各端口还应具有输入缓冲区和输出缓冲区。输入缓冲区用来暂存新进入路由器但还来不及处理的分组，输出缓冲区用来暂存已经处理完毕，但还来不及发送的分组。需要说明的是，路由器的端口一般都具有输入和输出的功能，我们图中分别给出输入端口和输出端口目的在于更好地演示路由器的基本工作过程。</p><p><a href="https://imgtu.com/i/qEUpIf"><img src="https://s1.ax1x.com/2022/03/19/qEUpIf.md.png" alt="qEUpIf.md.png"></a></p><h2 id="路由信息协议RIP（Routing-Information-Protocol）">路由信息协议RIP（Routing Information Protocol）</h2><p>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“<strong>距离向量D-V（Distance-Vector）</strong>”。</p><p>RIP使用<strong>跳数</strong>（Hop Count）作为度量（Metric）来衡量到达目的网络的距离。</p><ul><li>路由器到直连网络的距离定义为1。</li><li>路由器到非直连网络的距离定义为所经过的路由器数加1。口允许一条路径最多只能包含15个路由器。</li><li>“距离”等于16时相当于不可达。因此，RIP只适用于小型互联网。</li></ul><p><a href="https://imgtu.com/i/qELPt1"><img src="https://s1.ax1x.com/2022/03/19/qELPt1.md.png" alt="qELPt1.md.png"></a></p><p>RIP认为好的路由就是“<strong>距离短</strong>”的路由，也就是<strong>所通过路由器数量最少的路由</strong>。当到达同一目的网络有多条“距离相等”的路由时，可以进行<strong>等价负载均衡</strong>。</p><p>RIP包含以下三个要点：</p><ul><li>和谁交换信息：仅和<strong>相邻路由器</strong>交换信息</li><li>交换什么信息：自己的<strong>路由表</strong></li><li>何时交换信息：<strong>周期性交换</strong>（例如每30秒）</li></ul><p><a href="https://imgtu.com/i/qEODIA"><img src="https://s1.ax1x.com/2022/03/19/qEODIA.md.png" alt="qEODIA.md.png"></a></p><h3 id="RIP的基本工作过程">RIP的基本工作过程</h3><ol><li><p>路由器刚开始工作时，<strong>只知道自己到直连网络的距离为1</strong>。</p></li><li><p>每个路由器仅<strong>和相邻路由器周期性地交换并更新路由信息</strong>。</p></li><li><p>若干次交换和更新后，<strong>每个路由器都知道到达本AS内各网络的最短距离和下一跳地址</strong>，称为收敛。</p></li></ol><p><a href="https://imgtu.com/i/qEjB9I"><img src="https://s1.ax1x.com/2022/03/19/qEjB9I.md.png" alt="qEjB9I.md.png"></a></p><h3 id="RIP的路由条目更新规则">RIP的路由条目更新规则</h3><p>路由器C和D互为相邻路由器，它们之间周期性地交换并更新路由信息。路由器C的路由表中到达各目的网络的下一跳都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容。</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D。我们可以简单地理解为路由器C将自己的路由表发送给了路由器D。</p><p><a href="https://imgtu.com/i/qVp1O0"><img src="https://s1.ax1x.com/2022/03/19/qVp1O0.md.png" alt="qVp1O0.md.png"></a></p><p>路由器D收到后对其进行改造，将到达各目的网络的下一跳都改为C，距离都增加1。</p><p><a href="https://imgtu.com/i/qVpBOx"><img src="https://s1.ax1x.com/2022/03/19/qVpBOx.md.png" alt="qVpBOx.md.png"></a></p><p>现在路由器D根据改造的路由表来更新自己的路由表，更新规则如下图。</p><p><a href="https://imgtu.com/i/qVpnYQ"><img src="https://s1.ax1x.com/2022/03/19/qVpnYQ.md.png" alt="qVpnYQ.md.png"></a></p><h3 id="“坏消息传得慢”的问题">“坏消息传得慢”的问题</h3><p>RIP存在“<strong>坏消息传播得慢</strong>”的问题。“坏消息传播得慢”又称为<strong>路由环路</strong>或<strong>距离无穷计数问题</strong>，这是<strong>距离向量算法的一个固有问题</strong>。</p><p>如图所示，假设R1到达其直连网络的链路出现了故障，当R1检测出该故障后会将到达N1的路由条目中的距离修改为16，表示N1不可达。并等待RIP更新周期到时后发送该路由信息给R2。而此时R2的路由表中关于N1的路由条目仍然是先前通过RIP协议获取到的，也就是到达N1的距离为2，下一跳通过R1转发。</p><p>假设R2的RIP更新周期先到时，也就是R2的这条路由信息先到达R1，而R1的这条路由信息后到达R2。当R1收到R2的路由信息后，就会被该谣言误导，认为可以通过R2到达N1，距离为3，并在自己的RIP更新信息到时后，发送给R2。如此循环往复，直到R1和R2的路由表中到达N1的路由条目的距离都增加到16后，R1和R2才知道N1不可达（收敛）。在此过程中，R1和R2之间会出现<strong>路由环路</strong>，时间长达数分钟。</p><p><a href="https://imgtu.com/i/qVitD1"><img src="https://s1.ax1x.com/2022/03/19/qVitD1.md.png" alt="qVitD1.md.png"></a></p><p>可以采取多种措施<strong>减少</strong>出现该问题的概率或减小该问题带来的危害，但<strong>不能完全避免</strong>。</p><ul><li><strong>限制最大路径距离</strong>为15（16表示不可达）</li><li>当路由表发生变化时就立即发送更新报文（即“<strong>触发更新</strong>”），而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“<strong>水平分割</strong>”）</li></ul><h2 id="开放最短路径优先OSFP（Open-Shortest-Path-First）的基本工作原理">开放最短路径优先OSFP（Open Shortest Path First）的基本工作原理</h2><ul><li><p>开放最短路径优先OSPF（Open Shortest Path First），是为克服RIP的缺点在1989年开发出来的。</p><ul><li>“开放”表明OSPF协议不是受某一家厂商控制，而是<strong>公开发表</strong>的。</li><li>“最短路径优先”是因为使用了Dijkstra提出的<strong>最短路径算法</strong>SPF。</li></ul></li><li><p>OSPF是基于<strong>链路状态</strong>的，而不像RIP那样是基于距离向量的。</p></li><li><p>OSPF采用SPF算法计算路由，从算法上保证了<strong>不会产生路由环路</strong>。</p></li><li><p>OSPF<strong>不限制网络规模</strong>，更新效率高，<strong>收敛速度快</strong>。</p></li><li><p>链路状态是指本路由器都<strong>和哪些路由器相邻</strong>，以及相应<strong>链路的“代价”</strong>（cost）。</p><ul><li>“代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定。</li><li><a href="https://imgtu.com/i/qVAvPf"><img src="https://s1.ax1x.com/2022/03/19/qVAvPf.md.png" alt="qVAvPf.md.png"></a></li></ul></li></ul><h3 id="OSPF中的邻居关系">OSPF中的邻居关系</h3><ul><li>OSPF相邻路由器之间通过交互<strong>问候（Hello）分组</strong>，建立和维护<strong>邻居关系</strong>。<ul><li>Hello分组封装在IP数据报中，发往组播地址224.0.0.5；</li><li><a href="https://imgtu.com/i/qVEjm9"><img src="https://s1.ax1x.com/2022/03/19/qVEjm9.md.png" alt="qVEjm9.md.png"></a></li><li>发送周期为10秒</li><li>40秒未收到来自邻居路由器的Hello分组，则认为该邻居路由器不可达。</li></ul></li></ul><p><a href="https://imgtu.com/i/qVVmkt"><img src="https://s1.ax1x.com/2022/03/19/qVVmkt.md.png" alt="qVVmkt.md.png"></a></p><h3 id="OSPF的LSA和LSU">OSPF的LSA和LSU</h3><ul><li>使用OSPF的每个路由器都会产生<strong>链路状态通告LSA</strong>（Link State Advertisement）。LSA中包含以下内容：<ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul></li><li>LSA被封装在<strong>链路状态更新分组LSU</strong>中，采用<strong>洪泛法</strong>发送，也就是进行洪泛转发。这样，自治系统中每个路由器所发送的封装有链路状态通告的链路状态更新分组会传递给系统中其他所有路由器。</li></ul><p><a href="https://imgtu.com/i/qVZEgU"><img src="https://s1.ax1x.com/2022/03/19/qVZEgU.md.png" alt="qVZEgU.md.png"></a></p><h3 id="OSPF的LDB">OSPF的LDB</h3><ul><li>使用OSPF的每个路由器都有一个<strong>链路状态数据库LSDB</strong>，用于存储LSA。</li><li>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致。</li></ul><p><a href="https://imgtu.com/i/qVZr28"><img src="https://s1.ax1x.com/2022/03/19/qVZr28.md.png" alt="qVZr28.md.png"></a></p><h3 id="OSPF中最短路径的获取">OSPF中最短路径的获取</h3><p>使用OSPF的各路由器<strong>基于LSDB进行最短路径优先SPF计算</strong>，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</p><p><a href="https://imgtu.com/i/qVnaVJ"><img src="https://s1.ax1x.com/2022/03/19/qVnaVJ.md.png" alt="qVnaVJ.md.png"></a></p><h3 id="OSPF的分组类型">OSPF的分组类型</h3><ul><li>OSPF有以下五种分组类型：<ul><li><strong>问候</strong>（Hello）分组：用来发现和维护邻居路由器的可达性。</li><li><strong>数据库描述</strong>（Database Description）分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li><strong>链路状态请求</strong>（Link State Request）分组：向邻居路由器请求发送某些链路状态项目的详细信息。</li><li><strong>链路状态更新</strong>（Link State Update）分组：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态。</li><li><strong>链路状态确认</strong>（Link State Acknowledgment）分组：这是对链路状态更新分组的确认分组。</li></ul></li></ul><h3 id="OSPF的基本工作过程">OSPF的基本工作过程</h3><p><a href="https://imgtu.com/i/qVKtAJ"><img src="https://s1.ax1x.com/2022/03/19/qVKtAJ.md.png" alt="qVKtAJ.md.png"></a></p><h3 id="OSPF在多点接入网络中路由器邻居关系的建立">OSPF在多点接入网络中路由器邻居关系的建立</h3><ul><li>当OSPF路由器在多点接入网络中建立邻居关系时，如果不采用其他机制，将会产生大量的多播分组。<ul><li>为了减少所发送分组的数量，OSPF选举<strong>指定路由器DR</strong>（designated router）和<strong>备用的指定路由器BDR</strong>（backup designated router）</li><li><strong>所有的非DR/BDR只与DR/BDR建立邻居关系</strong></li><li>非DR/BDR之间通过DR/BDR交换信息</li><li>当DR出现故障，则由BDR顶替DR</li></ul></li></ul><p><a href="https://imgtu.com/i/qVM4i9"><img src="https://s1.ax1x.com/2022/03/19/qVM4i9.md.png" alt="qVM4i9.md.png"></a></p><h3 id="OSPF分层次划分区域">OSPF分层次划分区域</h3><p>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>（Area）</p><p>如图所示，这是一个规模很大的网络，我们将其划分成一个自治系统。在该自治系统内，所有路由器都使用OSPF协议。OSPF将该自治系统再划分成四个更小的区域。每个区域都有一个32比特的区域标识符，可以用点分十进制表示。例如，<strong>主干区域的标识符必须为0</strong>，也可以表示为点分十进制的0.0.0.0。主干区域用于连通其他区域，<strong>其他区域的标识符不能为0且互不相同</strong>。</p><p>每个区域的规模不应太大，一般所包含的路由器不应超过200个。划分区域的好处就是<strong>把利用洪泛法交换链路状态信息的范围局限于每一个区域</strong>，而不是整个自治系统，这样就<strong>减少了整个网络上的通信量</strong>。</p><p>如果路由器的所有接口都在同一个区域内，则该路由器称为<strong>区域内路由器</strong>。为了本区域可以和自治系统内的其他区域连通，每个区域都会有一个<strong>区域边界路由器</strong>，它的一个接口用于连接自身所在区域，另一个接口用于连接主干区域。主干区域内的路由器称为<strong>主干路由器</strong>。我们可以把区域边界路由器看作是主干路由器。在主干区域内还要有一个路由器，专门和本自治系统外的其他自治系统交换路由信息，这样的路由器称为<strong>自治系统边界路由器</strong>。</p><p>采用分层次划分区域的方法，虽然使<strong>交换信息的种类增多</strong>了，同时也<strong>使OSPF协议更加复杂</strong>了，但这样做却能<strong>使每一个区域内部交换路由信息的通信量大大减小</strong>，因而使OSPF协议能够用于规模很大的自治系统中。</p><p><a href="https://imgtu.com/i/qVQsFH"><img src="https://s1.ax1x.com/2022/03/19/qVQsFH.md.png" alt="qVQsFH.md.png"></a></p><h2 id="边界网关协议BGP（Border-Gateway-Protocol）">边界网关协议BGP（Border Gateway Protocol）</h2><ul><li>内部网关协议IGP（例如路由信息协议RIP或开放最短路径优先OSPF）<ul><li>设法使分组在一个自治系统内尽可能有效地从源网络传输到目的网络</li><li>无需考虑自治系统外部其他方面的策略</li></ul></li><li>外部网关协议EGP（例如边界网关协议BGP）<ul><li>在不同自治系统内，度量路由的“代价”（距离，带宽，费用等）可能不同。因此，对于自治系统之间的路由选择，使用“代价”作为度量来寻找最佳路由是不行的。<br><a href="https://imgtu.com/i/qV1LZT"><img src="https://s1.ax1x.com/2022/03/19/qV1LZT.md.png" alt="qV1LZT.md.png"></a></li><li>自治系统之间的路由选择必须考虑相关策略（政治，经济，安全等）<br><a href="https://imgtu.com/i/qV3VFe"><img src="https://s1.ax1x.com/2022/03/19/qV3VFe.md.png" alt="qV3VFe.md.png"></a></li><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</li></ul></li></ul><h3 id="BGP发言人">BGP发言人</h3><ul><li>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“<strong>BGP发言人</strong>”</li><li>不同自治系统的BGP发言人要交换路由信息，首先必须建立<strong>TCP连接</strong>，端口号为179<ul><li>在此TCP连接上交换BGP报文以建立<strong>BGP会话</strong></li><li>利用BGP会话<strong>交换路由信息</strong>（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的<strong>邻站</strong>（neighbor）或<strong>对等站</strong>（peer）</li></ul></li><li>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。</li><li>BGP发言人<strong>交换网络可达性的信息</strong>（要到达某个网络所要经过的一系列自治系统）</li><li>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中<strong>找出到达各自治系统的较好的路由</strong>。也就是构造出树形结构、<strong>不存在回路的自治系统连通图</strong>。</li></ul><p><a href="https://imgtu.com/i/qV3jnP"><img src="https://s1.ax1x.com/2022/03/19/qV3jnP.md.png" alt="qV3jnP.md.png"></a></p><h3 id="BGP发言人交换路径向量">BGP发言人交换路径向量</h3><p><a href="https://imgtu.com/i/qV8i1s"><img src="https://s1.ax1x.com/2022/03/19/qV8i1s.md.png" alt="qV8i1s.md.png"></a></p><h3 id="BGP-4的四种报文">BGP-4的四种报文</h3><ul><li><strong>OPEN（打开）报文</strong>：用来与相邻的另一个BGP发言人建立关系，使通信初始化。</li><li><strong>UPDATE（更新）报文</strong>：用来通告某一路由的信息，以及列出要撤销的多条路由。</li><li><strong>KEEPALIVE（保活）报文</strong>：用来周期性地证实邻站的连通性。</li><li><strong>NOTIFICATION（通知）报文</strong>：用来发送检测到的差错。</li></ul><p>在BGP协议刚刚运行时，BGP的邻站交换整个BGP路由表。但以后<strong>只需要在发生变化时更新有变化的部分</strong>，这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><h2 id="RIP、OSPF、BGP的封装">RIP、OSPF、BGP的封装</h2><p><a href="https://imgtu.com/i/qV8f3j"><img src="https://s1.ax1x.com/2022/03/19/qV8f3j.md.png" alt="qV8f3j.md.png"></a></p><h1>IPv4数据报的首部格式</h1><p>（以下IPv4数据报简称为IP数据报</p><p>如图所示，这是IP数据报的首部格式。它由20字节的固定部分和最大40字节的可变部分组成。所谓固定部分，是指每个IP数据报首部都必须包含的部分。而某些IP数据报的首部，除了包含20字节的固定部分外，还包含一些可选的字段来增加IP数据报的功能。IP数据报的首部常以32个比特为单位进行描述。图中的每一行都由32个比特（四个字节）构成，每个小格子称为字段或域。每个字段或某些字段的组合用来表达IP协议的相关功能。</p><p><a href="https://imgtu.com/i/qZnTXT"><img src="https://s1.ax1x.com/2022/03/20/qZnTXT.md.png" alt="qZnTXT.md.png"></a></p><h2 id="版本、首部长度、区分服务、总长度字段">版本、首部长度、区分服务、总长度字段</h2><ul><li><p>版本：<br>占4比特，表示IP协议的版本。<br>通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4（即IPv4）。</p></li><li><p>首部长度：<br>占4比特，表示IP数据报首部的长度。<br>该字段的取值以4字节为单位。最小十进制取值为5，表示IP数据报首部只有20字节固定部分；<br>最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分。</p></li><li><p>区分服务<br>占8比特，用来获得更好的服务。<br>该字段在旧标准中叫作服务类型，但实际上一直没有被使用过。<br>1998年，因特网工程任务组IETF把这个字段改名为区分服务。<br>利用该字段的不同数值可提供不同等级的服务质量。<br>只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段。</p></li><li><p>总长度<br>占16比特，表示IP数据报的总长度（首部＋数据载荷）。<br>最大取值为十进制的65535，以字节为单位。</p></li></ul><h2 id="标识、标志、片偏移字段">标识、标志、片偏移字段</h2><p>这三个字段共同用于IP数据报的分片。例如对于网际层封装出的IP数据报，它将在数据链路层封装成帧，每一种数据链路层协议都规定了帧的数据载荷的最大长度，称为最大传输单元MTU。例如，以太网的数据链路层规定MTU的值为1500个字节，如果某个IP数据报的总长度超过MTU时，将无法封装成帧。需要将原IP数据报分片为更小的IP数据报，再将各分片IP数据报封装成帧。</p><p><a href="https://imgtu.com/i/qZKjQx"><img src="https://s1.ax1x.com/2022/03/20/qZKjQx.md.png" alt="qZKjQx.md.png"></a></p><ul><li><p>标识<br>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。<br>IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。</p></li><li><p>标志<br>占3比特，各比特含义如下：</p><ul><li>DF位：<ul><li>1表示不允许分片；</li><li>0表示允许分片</li></ul></li><li>MF位：<ul><li>1表示“后面还有分片”：</li><li>0表示“这是最后一个分片”</li></ul></li><li>保留位：必须为0</li></ul></li><li><p>片偏移<br>占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。<br>片偏移以8个字节为单位。<br>片偏移量必须为整数</p></li></ul><h3 id="分片举例">分片举例</h3><p><a href="https://imgtu.com/i/qZlCRA"><img src="https://s1.ax1x.com/2022/03/20/qZlCRA.md.png" alt="qZlCRA.md.png"></a></p><p><a href="https://imgtu.com/i/qZlNi4"><img src="https://s1.ax1x.com/2022/03/20/qZlNi4.md.png" alt="qZlNi4.md.png"></a></p><h2 id="生存时间、协议、首部检验和字段">生存时间、协议、首部检验和字段</h2><ul><li><p>生存时间TTL<br>占8比特，最初以秒为单位，最大生存周期为255秒<br>路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则就丢弃。<br>现在以“跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0就转发，否则就丢弃。<br>生存时间TTL字段可以防止IP数据报在网络中永久兜圈<br><a href="https://imgtu.com/i/qZ1I39"><img src="https://s1.ax1x.com/2022/03/20/qZ1I39.md.png" alt="qZ1I39.md.png"></a></p></li><li><p>协议<br>占8比特，指明IPv4数据报的数据部分是何种协议数据单元。<br>常用的一些协议和相应的协议字段值如下<br>|协议名称|ICMP|IGMP|TCP|UDP|IPv6|OSPF|<br>|—|—|—|—|—|—|—|<br>|协议字段值|1|2|6|17|41|89|</p></li><li><p>首部检验和<br>占16比特，用来检测首部在传输过程中是否出现差错。比CRC检验码简单，称为因特网检验和。<br>IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段（生存时间、标志、片偏移等）的取值可能发生变化。<br>由于IP层本身并不提供可靠传输的服务，并且计算首部校验和是一项耗时的操作，因此在IPv6中，路由器不再计算首部校验和，从而更快转发IP数据报。</p></li></ul><h2 id="源IP地址、目的IP地址字段">源IP地址、目的IP地址字段</h2><p>各占32比特，用来填写发送该IP数据报的源主机的IP地址和接收该IP数据报的目的主机的IP地址。</p><h2 id="可选、填充字段">可选、填充字段</h2><ul><li>可选字段<br>长度从1个字节到40个字节不等。用来支持排错、测量及安全等措施。<br>可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用。</li><li>填充字段<br>确保首部长度为4字节的整数倍。使用全0进行填充。</li></ul><h1>网际控制报文协议ICMP（Internet Control Message Protocol）</h1><ul><li>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP（Internet Control Message Protocol）。</li><li>主机或路由器使用ICMP来发送<strong>差错报告报文</strong>和<strong>询问报文</strong>。</li><li><strong>ICMP报文被封装在IP数据报</strong>中发送。</li></ul><h2 id="ICMP差错报告报文">ICMP差错报告报文</h2><p>ICMP差错报告报文有以下五种：</p><ul><li>终点不可达</li><li>源点抑制</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）</li></ul><h3 id="终点不可达">终点不可达</h3><p>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误。</p><p><a href="https://imgtu.com/i/qZU3Lj"><img src="https://s1.ax1x.com/2022/03/20/qZU3Lj.md.png" alt="qZU3Lj.md.png"></a></p><h3 id="源点抑制">源点抑制</h3><p>当路由器或主机由于拥塞而丢奔数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</p><p><a href="https://imgtu.com/i/qZUywR"><img src="https://s1.ax1x.com/2022/03/20/qZUywR.md.png" alt="qZUywR.md.png"></a></p><h3 id="时间超过">时间超过</h3><p>当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段的值减1。</p><p>若结果不为0，则将该IP数据报转发出去；若结果为0，除丢奔该IP数据报外，还要向源点发送时间超过报文。</p><p><a href="https://imgtu.com/i/qZaE1U"><img src="https://s1.ax1x.com/2022/03/20/qZaE1U.md.png" alt="qZaE1U.md.png"></a></p><p>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文。</p><h3 id="参数问题">参数问题</h3><p>当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</p><p><a href="https://imgtu.com/i/qZaj4x"><img src="https://s1.ax1x.com/2022/03/20/qZaj4x.md.png" alt="qZaj4x.md.png"></a></p><h3 id="改变路由（重定向）">改变路由（重定向）</h3><p>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</p><p><a href="https://imgtu.com/i/qZdnxS"><img src="https://s1.ax1x.com/2022/03/20/qZdnxS.md.png" alt="qZdnxS.md.png"></a></p><h3 id="不发送ICMP差错报告报文的情况">不发送ICMP差错报告报文的情况</h3><ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li></ul><h2 id="ICMP询问报文">ICMP询问报文</h2><p>常用的ICMP询问报文有以下两种：</p><ul><li><p>回送请求和回答<br>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。<br>收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<br>这种询问报文用来<strong>测试目的站是否可达</strong>及了解其有关状态。</p></li><li><p>时间戳请求和回答<br>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。<br>在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。<br>这种询问报文用来<strong>进行时钟同步和测量时间</strong>。</p></li></ul><h3 id="ICMP用于分组网间探测PING（Packet-InterNet-Groper）">ICMP用于分组网间探测PING（Packet InterNet Groper）</h3><ul><li>用来测试主机或路由器间的连通性</li><li>应用层直接使用网际层的ICMP（没有通过运输层的TCP或UDP）</li><li>使用ICMP回送请求和回答报文</li></ul><p><a href="https://imgtu.com/i/qZ0gDe"><img src="https://s1.ax1x.com/2022/03/20/qZ0gDe.md.png" alt="qZ0gDe.md.png"></a></p><p><s>（我那个破学校官网是怎么回事</s></p><p><a href="https://imgtu.com/i/qZ0j5n"><img src="https://s1.ax1x.com/2022/03/20/qZ0j5n.md.png" alt="qZ0j5n.md.png"></a></p><h3 id="ICMP用于跟踪路由（traceroute）">ICMP用于跟踪路由（traceroute）</h3><ul><li>用来测试IP数据报从源主机到达目的主机要经过哪些路由器</li><li>Windows版本<ul><li>tracert命令</li><li>应用层直接使用网际层ICMP</li><li>使用了ICMP回送请求和回答报文以及差错报告报文</li></ul></li><li>Unix版本<ul><li>traceroute命令</li><li>在运输层使用UDP协议</li><li>仅使用ICMP差错报告报文</li></ul></li></ul><p><a href="https://imgtu.com/i/qZ0D9x"><img src="https://s1.ax1x.com/2022/03/20/qZ0D9x.md.png" alt="qZ0D9x.md.png"></a></p><h4 id="工作原理-3">工作原理</h4><p>假设主机H1想知道到达主机H2要经过哪些路由器。H1就给H2发送ICMP回送请求报文，该报文被封装在IP数据报中，IP数据报首部中生存时间字段TTL的值被设置为1。该IP数据报到达R1后，其生存时间减1结果为0。R1丢弃该数据报，并向发送该数据报的源主机H1发送ICMP差错报告报文，其类型为时间超过。</p><p>这样，H1就知道了到达H2的路径中的第一个路由器。</p><p><a href="https://imgtu.com/i/qZBbz6"><img src="https://s1.ax1x.com/2022/03/20/qZBbz6.md.png" alt="qZBbz6.md.png"></a></p><p>H1继续发送下一个封装有ICMP回送请求报文的IP数据报，首部中生存时间字段TTL的值被设置为2。经过R1的转发后，该数据报的生存时间减少为1。该IP数据报到达R2后，其生存时间减一结果为0。R2丢弃该数据报，并向发送该数据报的源主机H1发送ICMP差错报告报文，其类型为时间超过。</p><p>这样，H1就知道了到达H2的路径中的第二个路由器。</p><p><a href="https://imgtu.com/i/qZDQS0"><img src="https://s1.ax1x.com/2022/03/20/qZDQS0.md.png" alt="qZDQS0.md.png"></a></p><p>H1继续发送下一个封装有ICMP回送请求报文的IP数据报，首部中生存时间字段TTL的值被设置为3。经过R1、R2的转发后，该数据报到达主机H2，其生存时间减少为1。H2解析该数据报，发现其内部封装的是ICMP回送请求报文，于是就给H1发送封装有ICMP回送请求回答报文的IP数据报。</p><p>这样，H1就知道已经跟踪到路径中的最后一站，也就是目的主机H2。</p><p><a href="https://imgtu.com/i/qZDNk9"><img src="https://s1.ax1x.com/2022/03/20/qZDNk9.md.png" alt="qZDNk9.md.png"></a></p><h1>虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）">虚拟专用网VPN（Virtual Private Network）</h2><p><strong>利用公用的因特网</strong>作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。</p><p>由于IPv4地址的紧缺，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址。</p><p>对于下图，给部门A分配的专用网分配的私有地址的网络号为10.1.0.0，给部门B的专用网分配的私有地址的网络号为10.2.0.0。两个专用网中各主机所分配的私有地址如图所示。需要注意的是，私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。换句话说，私有地址只能用作本地地址，而不能用作全球地址。在因特网中的所有路由器，对目的地址是私有地址的IP数据报一律不进行转发。很显然，部门A和B各自至少需要一个路由器具有合法的全球IP地址，这样，它们各自的专用网才能利用公有的因特网进行通信。</p><p>假设部门A中一台主机要给部门B中的另一台主机发送数据，它会将待发送数据封装成内部IP数据报发送给路由器R1。其首部中源地址字段的值为部门A中该主机的IP地址，目的地址字段的值为部门B中另一台主机的IP地址。</p><p>R1收到该数据报后，发现其目的网络必须通过因特网才能到达，就将内部IP数据报进行加密，这样就确保了内部IP数据报的安全。然后重新添加上数据报的首部，封装成为在因特网上发送的外部数据报。其首部中源地址字段的值为路由器R1的全球地址，目的地址字段的值为路由器R2的全球地址。</p><p>路由器R2收到该外部IP数据报后，去掉其首部，将其数据部分进行解密，恢复出原来的IP数据报。这样就可以从其首部提取出源地址和目的地址。根据目的地址，将该内部IP数据报发送给相应的主机。</p><p><a href="https://imgtu.com/i/qZRTFU"><img src="https://s1.ax1x.com/2022/03/20/qZRTFU.md.png" alt="qZRTFU.md.png"></a></p><p>很显然，两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样，数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</p><p><a href="https://imgtu.com/i/qZfqq1"><img src="https://s1.ax1x.com/2022/03/20/qZfqq1.md.png" alt="qZfqq1.md.png"></a></p><ul><li><p>如上图所示，同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为<strong>内联网VPN</strong>。</p></li><li><p>有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为<strong>外联网VPN</strong>。</p></li><li><p>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为<strong>远程接入VPN</strong>。</p></li></ul><h2 id="网络地址转换NAT（Network-Address-Translation）">网络地址转换NAT（Network Address Translation）</h2><p>虽然因特网采用了无分类编址方式来减缓IPv4地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有被解除。</p><p>1994年提出了一种网络地址转换NAT的方法再次<strong>缓解了IPv4地址空间即将耗尽的问题</strong>。NAT能使<strong>大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源</strong>。</p><p>对于下图，使用私有地址的主机要与因特网上使用全球IP地址的主机进行通信。这需要在专用网络连接到因特网的路由器上安装NAT软件，装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址，这样，所有使用私有地址的主机在和外界通信时都要在NAT路由器上将其私有地址转换成全球IP地址。</p><p>假设使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报。该主机将IP数据报发送给NAT路由器，数据报首部中源地址字段的值为该主机的私有地址，目的地址字段的值为因特网上另一台主机的全球地址。NAT路由器从自己的全球IP地址池中为该主机分配一个临时的全球IP地址172.38.1.5，并将IP数据报的源地址修改为该地址。然后将私有地址与全球地址的对应关系记录在NAT转换表中。之后就可以转发该IP数据报了。</p><p>请注意，此时该IP数据报中的源地址和目的地址都是全球IP地址。</p><p><a href="https://imgtu.com/i/qZhcWD"><img src="https://s1.ax1x.com/2022/03/20/qZhcWD.md.png" alt="qZhcWD.md.png"></a></p><p>因特网上的这台主机给源主机发回数据报，数据报的源地址和目的地址都是全球IP地址。NAT路由器收到该IP数据报后，在NAT转换表中进行查找，发现该数据报的目的地址所对应的私有地址为192.168.0.2，于是就将该数据报的目的地址修改为192.168.0.2，并将其发送给相应的主机。</p><p>请注意，此时该IP数据报中的源地址为因特网上那台主机的全球IP地址，而目的地址为专用网络中这台主机的私有地址。</p><p><a href="https://imgtu.com/i/qZ43Xd"><img src="https://s1.ax1x.com/2022/03/20/qZ43Xd.md.png" alt="qZ43Xd.md.png"></a></p><p>当专用网中的这两台使用私有地址的主机，都要给因特网上使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与两个全球地址的对应关系。这种基本转换方法存在一个问题：如果NAT路由器具有N个全球IP地址，那么至多只能由N个内网主机能够同时和因特网上的主机通信。</p><p><a href="https://imgtu.com/i/qZ4gA0"><img src="https://s1.ax1x.com/2022/03/20/qZ4gA0.md.png" alt="qZ4gA0.md.png"></a></p><p>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。</p><p>这样，<strong>用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信</strong>。这种将端口号和IP地址一起进行转换的技术叫作<strong>网络地址与端口号转换NAPT</strong>（Network Address and Port Translation）。</p><p><a href="https://imgtu.com/i/qZTyxU"><img src="https://s1.ax1x.com/2022/03/20/qZTyxU.md.png" alt="qZTyxU.md.png"></a></p><p>外网主机不可以首先对内网主机发起通信，因此内网主机不能直接充当因特网服务器。</p><p><a href="https://imgtu.com/i/qZ7nzT"><img src="https://s1.ax1x.com/2022/03/20/qZ7nzT.md.png" alt="qZ7nzT.md.png"></a></p><p>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。</p><p>另外，由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护。</p>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络层 </tag>
            
            <tag> IPv4 </tag>
            
            <tag> 静态路由配置 </tag>
            
            <tag> 路由选择协议 </tag>
            
            <tag> RIP </tag>
            
            <tag> OSPF </tag>
            
            <tag> BGP </tag>
            
            <tag> ICMP </tag>
            
            <tag> VPN </tag>
            
            <tag> NAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的序列化与反序列化</title>
      <link href="/2022/03/10/serializeAndDeserializeBinaryTree/"/>
      <url>/2022/03/10/serializeAndDeserializeBinaryTree/</url>
      
        <content type="html"><![CDATA[<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：</p><ul><li>树中结点数在范围<code>[0, 10^4]</code>内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297.二叉树的序列化与反序列化</a></p><p>这里采用先序遍历记录二叉树的节点，如果为空则记录’#’作为标识（这就是序列化和遍历的区别。需要有两种遍历的结果才能确定一颗二叉树，而序列化时采用一种即可。因为序列化记录空树，而遍历不记录。</p><p>序列化时采用递归，不同节点的值之间用空格分隔。c++中分割带空格的字符串用<code>istringstream</code>，之后和序列化一样，递归地构造二叉树即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">serialize</span>(root-&gt;left) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">decode</span>(is);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">decode</span><span class="params">(istringstream&amp; is)</span></span>&#123;</span><br><span class="line">        string tmp;</span><br><span class="line">        is &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        root-&gt;left = <span class="built_in">decode</span>(is);</span><br><span class="line">        root-&gt;right = <span class="built_in">decode</span>(is);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化 </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> 二叉树遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的节点</title>
      <link href="/2022/03/10/swapNodesInPairs/"/>
      <url>/2022/03/10/swapNodesInPairs/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>提示：</p><ul><li>链表中节点的数目在范围```[0, 100]```内</li><li>```0 <= Node.val <= 100```</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点</a></p><p>递归就好了，头节点和头节点的next进行交换，再往后的节点通过函数返回就好啦。写的时候默认后面都交换过了就好啦。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* node1 = head;</span><br><span class="line">        ListNode* node2 = head-&gt;next;</span><br><span class="line">        ListNode* node3 = <span class="built_in">swapPairs</span>(head-&gt;next-&gt;next);</span><br><span class="line">        node1-&gt;next = node3;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        <span class="keyword">return</span> node2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻转链表 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解码方法</title>
      <link href="/2022/03/10/decodeWays/"/>
      <url>/2022/03/10/decodeWays/</url>
      
        <content type="html"><![CDATA[<p>一条包含字母<code>A-Z</code>的消息通过以下映射进行了 编码 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; &quot;1&quot;</span><br><span class="line">&#x27;B&#x27; -&gt; &quot;2&quot;</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; &quot;26&quot;</span><br></pre></td></tr></table></figure><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code>，将消息分组为<code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code>，将消息分组为<code>(11 10 6)</code></li></ul><p>注意，消息不能分组为<code>(1 11 06)</code>，因为<code>&quot;06&quot;</code>不能映射为<code>&quot;F&quot;</code>，这是由于<code>&quot;6&quot;</code>和<code>&quot;06&quot;</code>在映射中并不等价。</p><p>给你一个只含数字的<strong>非空</strong>字符串<code>s</code>，请计算并返回<strong>解码</strong>方法的<strong>总数</strong>。</p><p>题目数据保证答案肯定是一个<strong>32 位</strong>的整数。</p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code>只包含数字，并且可能包含前导零。</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/decode-ways/">91.编码方法</a></p><p><del>有人相爱，有人夜里看海，有人一道动态规划死活写不出来</del></p><p>对于一个字符串，编码出的最后一个字母可以是根据字符串最后一个字符，也可以是根据字符串最后两个字符。如果是根据最后一个字符进行编码的，那么该字符不能为’0’，如果是根据最后两个字符编码的，那么不能有前导0且不大于26。</p><p>根据以上推算，容易得到动态方程。<del>既然那么容易，我就不写了</del></p><p>要注意的是，长度为1和2时对字符串的判断。如果长度为1，那么直接判断是不是’0’就好了，如果长度为2，判断最后两个字符可以编码时，是要给当前dp值加一，而不是加上之前第二个的dp值，否则会越界。</p><p><del>感觉没说清楚，反正就是会越界，看代码就知道了</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = (s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="number">10</span> * (s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) + (s[i] - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                dp[i] += (i &gt; <span class="number">1</span> ? dp[i - <span class="number">2</span>] : <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方题解中，给dp加了个头，就不用考虑前面说的越界问题，但是dp的意义会变，要变下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] += dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="number">10</span> * (s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) + (s[i] - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索二维矩阵II</title>
      <link href="/2022/03/10/searchA2DMatrixII/"/>
      <url>/2022/03/10/searchA2DMatrixII/</url>
      
        <content type="html"><![CDATA[<p>编写一个高效的算法来搜索<code>m x n</code>矩阵<code>matrix</code>中的一个目标值<code>target</code>。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p>提示：</p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n, m &lt;= 300</code></li><li><code>-10^9 &lt;= matrix[i][j] &lt;= 10^9</code></li><li>每行的所有元素从左到右升序排列</li><li>每列的所有元素从上到下升序排列</li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240.搜索二维矩阵II</a></p><p>剑指offer上有一样的题目。</p><p>这里从右上角开始搜索，如果目标小于当前的数，则下面这一列都不会有等于目标的数，往左一列；如果目标大于当前的数，则左边这一行都不会有等于目标的数，往下一行。</p><p>仔细想想，有没有挺像个二叉搜索树 <del>我随便说的，我也不知道</del></p><p>反正能想到从右上角开始搜索就很简单啦，代码也不难的~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = n - <span class="number">1</span>, row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(col &gt;= <span class="number">0</span> &amp;&amp; row &gt;= <span class="number">0</span> &amp;&amp; col &lt; n &amp;&amp; row &lt; m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt; target)&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合总和</title>
      <link href="/2022/03/10/combinationSum/"/>
      <url>/2022/03/10/combinationSum/</url>
      
        <content type="html"><![CDATA[<p>给你一个<strong>无重复元素</strong>的整数数组<code>candidates</code>和一个目标整数<code>target</code>，找出<code>candidates</code>中可以使数字和为目标数<code>target</code>的<em>所有</em> <strong>不同组合</strong>，并以列表形式返回。你可以按<strong>任意顺序</strong>返回这些组合。</p><p>对于<code>candidates</code>中的<strong>同一个</strong>数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为<code>target</code>的不同组合数少于<code>150</code>个。</p><p>提示：</p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code>中的每个元素都<strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 500</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/combination-sum/">39.组合总和</a></p><p><del>我真是奇了怪了题目描述第二段少了开头的“对于”俩字就全乱了是什么鬼bug</del></p><p>很明显的回溯题，对于每一个数字有选择和不选择的方案。所以回溯的时候有一个直接选择下一个数字的递归，还有一个选择当前数字的递归。后一个递归的前后给临时答案放入和弹出数据。</p><p>小黎本来对数组弄了个排序，但是好像除了拖慢运行效率并没有啥用。也就是对于无解的情况有点用吧，但是测试样例中无解的比重应该并不大，所以看起来没啥用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// sort(candidates.begin(), candidates.end());</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">// if(candidates[0] &gt; target)&#123;</span></span><br><span class="line">        <span class="comment">//     return ans;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">backTrack</span>(candidates, ans, temp, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> idx, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span> || idx &gt;= candidates.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backTrack</span>(candidates, ans, temp, idx + <span class="number">1</span>, target);</span><br><span class="line"></span><br><span class="line">        temp.<span class="built_in">push_back</span>(candidates[idx]);</span><br><span class="line">        <span class="built_in">backTrack</span>(candidates, ans, temp, idx, target - candidates[idx]);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过对于<a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和II</a>来说，排序就是必要的。因为此时包含重复的数字，且每个数字在每个组合中只可以使用一次，明显需要用到排序。</p><p>而且这个地方每个数字只能使用一次，所以不能像这题一样回溯，需要有一个for循环来选取数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; candidates;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 元素不可重复利用，使用下一个即i+1</span></span><br><span class="line">            <span class="built_in">DFS</span>(i + <span class="number">1</span>, target - candidates[i]);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;candidates = candidates;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（突然发现自己以前写过这个题目，<del>偷个懒</del></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复制带随机指针的链表</title>
      <link href="/2022/03/10/copyListWithRandomPointer/"/>
      <url>/2022/03/10/copyListWithRandomPointer/</url>
      
        <content type="html"><![CDATA[<p>给你一个长度为<code>n</code>的链表，每个节点包含一个额外增加的随机指针<code>random</code>，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的<strong>深拷贝</strong>。 深拷贝应该正好由<code>n</code>个<strong>全新</strong>节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code>指针和<code>random</code>指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有<code>X</code>和<code>Y</code>两个节点，其中<code>X.random --&gt; Y</code>。那么在复制链表中对应的两个节点<code>x</code>和<code>y</code>，同样有<code>x.random --&gt; y</code>。</p><p>返回复制链表的头节点。</p><p>用一个由<code>n</code>个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个<code>[val, random_index]</code>表示：</p><ul><li><code>val</code>：一个表示<code>Node.val</code>的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从<code>0</code>到<code>n-1</code>）；如果不指向任何节点，则为<code>null</code>。<br>你的代码<strong>只</strong>接受原链表的头节点<code>head</code>作为传入参数。</li></ul><p>提示：</p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li><li><code>Node.random</code>为<code>null</code>或指向链表中的节点。</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138.复制带随机指针的链表</a></p><p><del>什么鬼题目把一个深拷贝说得又臭又长</del></p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>可以用哈希表，旧节点映射到新节点。先用哈希表把所有节点抄下来，然后再遍历一次加上next和random指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; nodeMap;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            nodeMap[curr] = <span class="keyword">new</span> <span class="built_in">Node</span>(curr-&gt;val);</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            nodeMap[curr]-&gt;next = nodeMap[curr-&gt;next];</span><br><span class="line">            nodeMap[curr]-&gt;random = nodeMap[curr-&gt;random];</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeMap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="原地拷贝"><a href="#原地拷贝" class="headerlink" title="原地拷贝"></a>原地拷贝</h1><p>当然也可以不用哈希表，直接在原来的指针后面new上一个一模一样的<del>跟屁虫</del>指针，也能实现类似哈希表的功能。也就是原指针的next就是映射的新指针，只是遍历的时候记得两个两个地遍历。</p><p>还有原来的链表也要恢复原样哦！还有对于头指针为空的特判哦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(curr-&gt;val);</span><br><span class="line">            newNode-&gt;next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = newNode;</span><br><span class="line">            curr = curr-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            curr-&gt;next-&gt;random = curr-&gt;random? curr-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            curr = curr-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* newHead = head-&gt;next;</span><br><span class="line">        curr = head;</span><br><span class="line">        Node* newCurr = newHead;</span><br><span class="line">        <span class="keyword">while</span>(curr &amp;&amp; newCurr)&#123;</span><br><span class="line">            curr-&gt;next = newCurr ? newCurr-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            newCurr-&gt;next = newCurr-&gt;next ? newCurr-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            newCurr = newCurr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/2022/03/10/longestPalindromicSubstring/"/>
      <url>/2022/03/10/longestPalindromicSubstring/</url>
      
        <content type="html"><![CDATA[<p>给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。</p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code>仅由数字和英文字母组成</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a></p><h1 id="中心扩展算法"><a href="#中心扩展算法" class="headerlink" title="中心扩展算法"></a>中心扩展算法</h1><p>当时小黎看到这题就感觉从中间往两边扩就行。遍历字符串，以该字符串为中心往两边扩，扩到不能扩为止。<del>结果美美WA</del></p><p>其实不只是从中间一个字符往两边扩的情况，还有中间俩字符。这里取当前遍历字符和下一个字符往两边扩，反正扩张函数会判断越界的，直接扔进去<del>拍屁股走人</del>就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; interval1 = <span class="built_in">expand</span>(s, i, i);</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; interval2 = <span class="built_in">expand</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(interval1[<span class="number">1</span>] - interval1[<span class="number">0</span>] &gt; end - begin)&#123;</span><br><span class="line">                end = interval1[<span class="number">1</span>];</span><br><span class="line">                begin = interval1[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(interval2[<span class="number">1</span>] - interval2[<span class="number">0</span>] &gt; end - begin)&#123;</span><br><span class="line">                end = interval2[<span class="number">1</span>];</span><br><span class="line">                begin = interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s.<span class="built_in">begin</span>() + begin, s.<span class="built_in">begin</span>() + end + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">expand</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>后面去看了官方题解，发现还可以通过动态规划来做，相比起之前的解法空间复杂度要高一些。</p><p>大概的思想就是，外围的俩字符相同，并且这俩字符之间的字符串也是回文串的时候，这个字符串就是回文串。初始化就是每个字符都是一个回文串，然后枚举一下子串长度和左边界，按照之前的思路判断一下就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 回文串 </tag>
            
            <tag> 中心扩展算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小路径和</title>
      <link href="/2022/03/10/minimumPathSum/"/>
      <url>/2022/03/10/minimumPathSum/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含非负整数的<code>m x n</code>网格<code>grid</code>，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64.最小路径和</a></p><p>很明显是个动态规划啦，初始化一下上边界和左边界的数值，然后对于别的格子取上边和左边最小值加上当前格子数值就好。</p><p><del>感觉没什么好说的，打那么多字是我对它最大的尊重了</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长有效括号</title>
      <link href="/2022/03/10/longestValidParentheses/"/>
      <url>/2022/03/10/longestValidParentheses/</url>
      
        <content type="html"><![CDATA[<p>给你一个只包含<code>&#39;(&#39;</code>和<code>&#39;)&#39;</code>的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>提示：</p><ul><li><code>0 &lt;= s.length &lt;= 3 * 10^4</code></li><li><code>s[i]</code>为<code>&#39;(&#39;</code>或<code>&#39;)&#39;</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32.最长有效括号</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>想起那天早上，数据结构的老师和我们说，<del>我和你们没有共同语言</del>判断括号用栈。于是小黎看到这题就哼哧哼哧地用了栈，美美错了。</p><p>之后寻思啊，这个栈里面放的都是左括号，感觉信息量很低啊，不如存放下标，这样就能计算长度了。</p><p><del>中间走的弯路忘记了，反正就是个考虑不全的憨憨的思考过程</del></p><p>最后整理出了如下思路：</p><ul><li>用一个变量start存放合法字符串的开始下标</li><li>遍历的过程中，如果遇到左括号，就将其下标入栈</li><li>如果遇到右括号，且此时栈为空，说明没有可与之匹配的左括号，字符串不合法，将start设在该下标的后一个</li><li>如果遇到右括号，且此时栈不为空，则弹出栈顶数据。如果弹出栈顶之后说明从start到目前下标已经匹配完成，可以记录从start到目前的长度，来更新答案。如果弹出之后栈不为空，说明仍有左括号未匹配，则此时的长度为栈顶未匹配的左括号下标之后到目前下标的距离，以此更新答案。</li></ul><p>说完啦！上代码！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - sta.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h1><p>就是弄两个变量，从左至右遍历，分别记录左括号和右括号的个数。当左括号等于右括号时，记录当前字符长度，当右括号多余左括号时<del>重开</del>重新置零开始计数。</p><p>这样对于左括号多余右括号的字符串是无法计数的，所以考虑再从右往左遍历。和之前思路相似，当左右括号数目相等时，记录当前长度，当左括号数目大于右括号数目时重新置零开始计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比起栈的做法，相当于是用时间换空间了吧</p>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号生成</title>
      <link href="/2022/03/10/generateParentheses/"/>
      <url>/2022/03/10/generateParentheses/</url>
      
        <content type="html"><![CDATA[<p>数字<code>n</code>代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">22.括号生成</a></p><p><del>看到输入范围是[1,8]有没有让你产生一个大胆的想法</del></p><p>很明显的一个递归（其实回溯也行<del>只是我懒得写</del>），递归出口就是左括号和右括号数目均符合条件，记上这个可行解就行。对于左括号或者右括号的数目大于目标值，以及右括号的数目多于左括号的情况，明显是不可行解，直接退出就行。</p><p>然后就是很简单的递归了<del>我只能说懂的都懂</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="built_in">generate</span>(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">&quot;&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(<span class="type">int</span> leftCount, <span class="type">int</span> rightCount, <span class="type">int</span> target, string curr, vector&lt;string&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftCount == target &amp;&amp; rightCount == target)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightCount &gt; target || leftCount &gt; target || rightCount &gt; leftCount)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">generate</span>(leftCount + <span class="number">1</span>, rightCount, target, curr + <span class="string">&#x27;(&#x27;</span>, ans);</span><br><span class="line">        <span class="built_in">generate</span>(leftCount, rightCount + <span class="number">1</span>, target, curr + <span class="string">&#x27;)&#x27;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="/2022/03/09/linkedListCycleII/"/>
      <url>/2022/03/09/linkedListCycleII/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表的头节点<code>head</code>，返回链表开始入环的第一个节点。<em>如果链表无环，则返回<code>null</code></em> 。</p><p>如果链表中有某个节点，可以通过连续跟踪<code>next</code>指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数<code>pos</code>来表示链表尾连接到链表中的位置<strong>（索引从<code>0</code>开始）</strong>。如果<code>pos</code>是<code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code>不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong>链表。</p><p>提示：</p><ul><li>链表中节点的数目范围在范围<code>[0, 10^4]</code>内</li><li><code>10^5 &lt;= Node.val &lt;= 10^5</code></li><li><code>pos</code>的值为<code>-1</code>或者链表中的一个有效索引</li></ul><p>进阶：你是否可以使用<code>O(1)</code>空间解决此题？</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142.环形链表</a></p><p><del>直接进阶吧，搞哈希表太没水准了</del></p><p>这里主要是一个数学问题，我们弄两个快慢指针遍历链表：快指针每次前进两个节点，慢指针每次前进一个节点。</p><p>如果链表无环，那么快指针到达空指针处，返回结果。</p><p>如果链表有环，那么快慢指针会在环内相遇。设环外节点数为a，环内节点数为b，快慢指针相遇时快指针前进了f个节点，慢指针前进了s个节点。</p><p>首先快指针速度是慢指针的两倍：f &#x3D; 2s</p><p>其次快指针比慢指针多走的节点数为环内节点的整数倍：f &#x3D; s + nb</p><p>联立上面两个有：s &#x3D; nb</p><p>也就是此时慢指针走过的节点数为环内节点数的整数倍。也就是再走a个节点能够到达环的起点数。</p><p>为了获得a，让快指针<del>打道回府</del>回到起点处，快慢指针同时前进，每次都移动一个节点。当二者相遇时，即是在环的开始处。</p><p>说完啦！上代码！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并区间</title>
      <link href="/2022/03/09/mergeIntervals/"/>
      <url>/2022/03/09/mergeIntervals/</url>
      
        <content type="html"><![CDATA[<p>以数组<code>intervals</code>表示若干个区间的集合，其中单个区间为<code>intervals[i] = [starti, endi]</code>。请你合并所有重叠的区间，并返回<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em>。</p><p>提示：</p><ul><li><code>1 &lt;= intervals.length &lt;= 10^4</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 10^4</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/merge-intervals/">56.合并区间</a></p><p><img src="https://pic.leetcode-cn.com/91d75169b1cdb15560d361f8cb7050adfe7906c955afbe8846b92d1beba8a0d7-image.png"></p><p>2个区间的关系有6种，但是其实可以变成上面3种情况（只需要假设<strong>第一个区间的起始位置 &lt;&#x3D; 第二个区间的起始位置</strong>，如果不满足这个假设，交换这两个区间）。</p><p>所以按照起始位置对所有区间排序，再按照逻辑合并区间就行。逻辑很简单，懒得写了。<del>不会真有人不知道吧</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                right = <span class="built_in">max</span>(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找树左下角的值</title>
      <link href="/2022/03/09/findButtomLeftTreeValue/"/>
      <url>/2022/03/09/findButtomLeftTreeValue/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树的<strong>根节点</strong> &#96;&#96;root&#96;&#96;&#96;，请找出该二叉树的<strong>最底层 最左边</strong>节点的值。</p><p>假设二叉树中至少有一个节点。</p><p>提示:</p><ul><li>二叉树的节点个数的范围是<code>[1,10^4]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513.找树左下角的值</a></p><p>这题有个很巧妙的方法，就是层序遍历，但是是从右向左，这样就能找到目标节点啦。</p><p>代码很简单，小黎只是恰好路过，感觉还蛮好玩的，记录一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel表列名称</title>
      <link href="/2022/03/09/excelSheetColumnTitle/"/>
      <url>/2022/03/09/excelSheetColumnTitle/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数<code>columnNumber</code>，返回它在Excel表中相对应的列名称。</p><p>提示：</p><ul><li><code>1 &lt;= columnNumber &lt;= 2^31 - 1</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168.Excel表列名称</a></p><p>乍一看我以为只是个简简单单的进制转换</p><p>啪一下很快啊！就WA了，哈哈（干笑</p><p>仔细想一想，这里是从1-26的26进制，人家<strong>没有0</strong>啊！正经的进制转换的路子不能走啊！</p><p>本来我寻思吧，1-25就是A-Y，0就是Z，还是WA了，对于701的测试样例过不了，多了一位A。</p><p>后面评论区里面说，既然习惯是0-25，那每次转换的时候<strong>把数字-1</strong>就好了，这样就是从0开始的了。</p><p>然后小黎就写出来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(columnNumber)&#123;</span><br><span class="line">            columnNumber--;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU缓存</title>
      <link href="/2022/03/09/LRUCache/"/>
      <url>/2022/03/09/LRUCache/</url>
      
        <content type="html"><![CDATA[<p>请你设计并实现一个满足LRU(最近最少使用)缓存约束的数据结构。</p><p>实现LRUCache 类：</p><ul><li><code>LRUCache(int capacity)</code>以<strong>正整数</strong>作为容量<code>capacity</code>初始化 LRU 缓存</li><li><code>int get(int key)</code>如果关键字<code>key</code>存在于缓存中，则返回关键字的值，否则返回<code>-1</code>。</li><li><code>void put(int key, int value)</code>如果关键字<code>key</code>已经存在，则变更其数据值<code>value</code>；如果不存在，则向缓存中插入该组<code>key-value</code>。如果插入操作导致关键字数量超过<code>capacity</code>，则应该<strong>逐出</strong>最久未使用的关键字。</li></ul><p>函数<code>get</code>和<code>put</code>必须以<code>O(1)</code>的平均时间复杂度运行。</p><p>提示：</p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 10^5</code></li><li>最多调用<code>2 * 10^5</code>次<code>get</code>和<code>put</code></li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/lru-cache/">146.LRU缓存</a></p><p><del>虽然我还没学操作系统但是听说这个常考就先写了</del></p><p>要<code>O(1)</code>的时间复杂度捏，那就只能用<code>unordered_map</code>了捏（抠鼻屎</p><p>由于存在一个内容上浮（最近使用的节点到最前面）和尾部内容删除的需求，所以考虑双向链表。双向链表很容易写的，自己写一个就好了。</p><p>关于节点的查询，可以用哈希表来实现。哈希表的键为数据的键；键对应的值为对应节点。这样方便根据key得到节点，从而对节点进行相关操作。<del>至于哈希表就不自己写了，柿子还是得挑软的捏</del></p><p>双端队列加个虚拟头尾指针比较方便操作，比如插入头部啦，删除尾部元素啦。</p><p>好像写的时候没有废太大力气，花最久时间应该在put函数那个地方，各个操作之间的顺序有点弄混的。应该先看有没有已经存在key对应的节点，有的话就改一下值上浮节点，没有的话就新增节点，再判断是否溢出。我最开始是先判断再加了，写的有点混乱<del>也不知道脑子里面是装了什么屎</del></p><p>好像也没什么了，主要就是哈希+双向链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DeLinkedListNode</span>&#123;</span><br><span class="line">    DeLinkedListNode* pre;</span><br><span class="line">    DeLinkedListNode* next;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="built_in">DeLinkedListNode</span>(<span class="type">int</span> key = <span class="number">0</span>, <span class="type">int</span> val = <span class="number">0</span>): <span class="built_in">val</span>(val), <span class="built_in">key</span>(key), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">DeLinkedListNode</span>(<span class="type">int</span> key, <span class="type">int</span> val, DeLinkedListNode* pre, DeLinkedListNode* next): <span class="built_in">val</span>(val), <span class="built_in">key</span>(key), <span class="built_in">pre</span>(pre), <span class="built_in">next</span>(next)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> curr;</span><br><span class="line">    DeLinkedListNode* head;</span><br><span class="line">    DeLinkedListNode* tail;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DeLinkedListNode*&gt; keyNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DeLinkedListNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DeLinkedListNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(keyNode.<span class="built_in">find</span>(key) != keyNode.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">moveToHead</span>(keyNode[key]);</span><br><span class="line">            <span class="keyword">return</span> keyNode[key]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(keyNode.<span class="built_in">find</span>(key) != keyNode.<span class="built_in">end</span>())&#123;</span><br><span class="line">            keyNode[key]-&gt;val = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(keyNode[key]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DeLinkedListNode* node = <span class="keyword">new</span> <span class="built_in">DeLinkedListNode</span>(key, value);</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        curr++;        </span><br><span class="line">        <span class="keyword">if</span>(curr &gt; capacity)&#123;</span><br><span class="line">            <span class="built_in">removeLast</span>();</span><br><span class="line">            curr--;</span><br><span class="line">        &#125;        </span><br><span class="line">        keyNode[key] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DeLinkedListNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;pre &amp;&amp; node-&gt;next)&#123;</span><br><span class="line">            DeLinkedListNode* pre = node-&gt;pre;</span><br><span class="line">            DeLinkedListNode* next = node-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">            next-&gt;pre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        DeLinkedListNode* first = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        node-&gt;pre = head;</span><br><span class="line">        node-&gt;next = first;</span><br><span class="line">        first-&gt;pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(DeLinkedListNode* node)</span></span>&#123;</span><br><span class="line">        DeLinkedListNode* preNode = node-&gt;pre;</span><br><span class="line">        DeLinkedListNode* nextNode = node-&gt;next;</span><br><span class="line">        preNode-&gt;next = nextNode;</span><br><span class="line">        nextNode-&gt;pre = preNode;</span><br><span class="line">        keyNode.<span class="built_in">erase</span>(node-&gt;key);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DeLinkedListNode* last = tail-&gt;pre;</span><br><span class="line">        <span class="built_in">removeNode</span>(last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的锯齿形层序遍历</title>
      <link href="/2022/03/09/binaryTreeZigzagLevelOrderTraversal/"/>
      <url>/2022/03/09/binaryTreeZigzagLevelOrderTraversal/</url>
      
        <content type="html"><![CDATA[<p>给你二叉树的根节点<code>root</code>，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>提示：</p><ul><li>树中节点数目在范围 [0, 2000] 内</li><li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103.二叉树的锯齿形层序遍历</a></p><p>这题在剑指offer里面刷过捏，所以我<strong>啪</strong>地一下就写完了</p><p>简单来说就是个层序遍历的变种，要点有：</p><ul><li>通过队列当前size来得知当前层有多少个节点</li><li>根据当前层节点数预先申请相应大小的数组</li><li>将申请好的数组放入答案中，根据答案中的数组个数判断当前层数</li><li>如果是奇数层，从前往后填；否则从后往前填</li></ul><p>记得层数是从1开始计数的啊，当时就忘记这茬美美越界<del>还愣了半天不知道错哪了</del></p><p>（感觉那个判断当前层数的方法比较巧妙，可以留意一下~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(sz, <span class="number">0</span>)</span></span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="type">int</span> n = ans.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    ans[n - <span class="number">1</span>][i] = node-&gt;val;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans[n - <span class="number">1</span>][sz - i - <span class="number">1</span>] = node-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的直径</title>
      <link href="/2022/03/09/diameterOfBinaryTree/"/>
      <url>/2022/03/09/diameterOfBinaryTree/</url>
      
        <content type="html"><![CDATA[<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543.二叉树的直径</a></p><p>小黎当时第一眼看到就想起来了之前刷过的<a href="https://angielee233.github.io/2022/03/07/binaryTreeMaximumPathSum/">二叉树最大路径和</a></p><p>用了类似的思路，写了以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = -INT_MAX;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">recur</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">recur</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">recur</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(&#123;ans, <span class="number">1</span> + left, <span class="number">1</span> + right, left + <span class="number">2</span> + right&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(&#123;<span class="number">1</span> + left, <span class="number">1</span> + right, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="number">1</span> + left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> + left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="number">1</span> + right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> + right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>过是过了，性能也不差，但是这个代码也太冗余了，还要判断左右子树是否为空。主要是因为如果子树为空，那就不能连接过去，就不能盲目地+1</p><p>后面感觉既然空树返回的是0，而且如果要和上端相连最多只能取一个子树。以及ans只用于从左子树通过根连接到右子树的情况，就改了一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = -INT_MAX;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">recur</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">recur</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">recur</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, left + <span class="number">2</span> + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> + <span class="built_in">max</span>(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>时间已经击败100%了，凑合过吧</del></p><p>后面看到<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/">官方题解</a>是用经过的最大节点数-1做的。感觉和我的也差不了太多，<del>勉强</del>贴上来吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">depth</span>(rt-&gt;left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">depth</span>(rt-&gt;right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就省略了子树是否为空的计算，还是比我的做法要优雅亿些的~</p>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三数之和</title>
      <link href="/2022/03/09/3Sum/"/>
      <url>/2022/03/09/3Sum/</url>
      
        <content type="html"><![CDATA[<p>给你一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素a，b，c，使得a + b + c &#x3D; 0？请你找出所有和为0且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>提示：</p><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 3000</li><li>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/3sum/">15.三数之和</a></p><p><del>又到了爷最爱的去重环节</del></p><p>感觉提到去重就离不开排序，让这些<del>蛇鼠一窝</del>相同的元素放在一起，会比较好处理。</p><p>首先遍历第一个元素，如果第一个元素就大于0，那么后续肯定无法组合出和为0的数组，直接返回答案就行。</p><p>为了去重，如果已经开始列举第一个元素了，且和之前列举的相同，则continue。</p><p>然后开始求第二、三个元素，弄两个指针left和right（小黎这里直接用的j和k），初始化left为第一个元素的后一个指针，right为数组的最后一个。</p><p>由于这里对第二、三个元素的查找是并列的，所以从两端向中间找。如果当前加和大了，就左移right；如果小了，就右移left。所以在进入第二重循环前定义right，并且在第二重循环中right的值只减不增。当left和right重合的时候，~就说明我们回不去了~~就说明对于当前的第一个元素，已经没有更多的解了，直接break即可。</p><p>要注意，这里对于第二个元素也是有去重的，和第一个元素的去重思路相同，不再赘述啦。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>() || nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == k)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列II</title>
      <link href="/2022/03/09/PermutationsII/"/>
      <url>/2022/03/09/PermutationsII/</url>
      
        <content type="html"><![CDATA[<p>给定一个可包含重复数字的序列<code>nums</code>，按任意顺序返回所有不重复的全排列。</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 8</li><li>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/permutations-ii/">47.全排列II</a></p><p>这种排列的很容易想到回溯，但是题目中给定的数组中可能包含重复数字，如果单纯地回溯可能造成枚举的重复。</p><p>为解决重复数字的问题，可以将数组排序，令相同数字相连在一起。对于相同的数字，令其在数组中出现的顺序相同，可以达到去重的效果。</p><p>本例中令相同的数字按顺序从左至右访问，如果该数访问过了或者前一个相同的数字未访问，则跳过。</p><p>当然也可以从右至左，评论区中有一则<a href="https://leetcode-cn.com/problems/permutations-ii/solution/quan-pai-lie-ii-by-leetcode-solution/1200093">评论</a>是这样的：</p><blockquote><p>其实简单的来说，以[1,1,1,2]为例子<br>vis[i-1]&#x3D;&#x3D;0时continue，那三个1的选取顺序只能是①②③<br>vis[i-1]&#x3D;&#x3D;1时continue，那三个1的选取顺序只能是③②①<br>往后不管多少个相同的数字，都只有“顺序“或“逆序”的方式选取，而不会出现 ③①②、②①③ 等等<br>所以这里的排列是通过确定相同数字的选取顺序，二选一，来排除因其他选取顺序而产生的重复结果</p></blockquote><p><del>反正大概就这个意思，我也懒得再解释了</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vst</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">backTrack</span>(nums, vst, <span class="number">0</span>, curr, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; vst, <span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; curr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(idx == n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vst[i] || (i &gt; <span class="number">0</span> &amp;&amp; !vst[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vst[i] = <span class="number">1</span>;</span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backTrack</span>(nums, vst, idx + <span class="number">1</span>, curr, ans);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            vst[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程表</title>
      <link href="/2022/03/09/courseSchedule/"/>
      <url>/2022/03/09/courseSchedule/</url>
      
        <content type="html"><![CDATA[<p>你这个学期必须选修<code>numCourses</code>门课程，记为<code>0</code>到<code>numCourses - 1</code>。</p><p>在选修某些课程之前需要一些先修课程。先修课程按数组<code>prerequisites</code>给出，其中 <code>prerequisites[i] = [ai, bi]</code>，表示如果要学习课程<code>ai</code>则 必须先学习课程<code>bi</code>。</p><p>例如，先修课程对<code>[0, 1]</code>表示：想要学习课程<code>0</code>，你需要先完成课程<code>1</code>。</p><p>请你判断是否可能完成所有课程的学习？如果可以，返回<code>true</code>；否则，返回<code>false</code>。</p><p>提示：</p><ul><li>1 &lt;&#x3D; numCourses &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</li><li>prerequisites[i].length &#x3D;&#x3D; 2</li><li>0 &lt;&#x3D; ai, bi &lt; numCourses</li><li>prerequisites[i]中的所有课程对互不相同</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/course-schedule/">207.课程表</a></p><p>这种场景很明显用拓扑排序，拓扑排序就是拿来干这活的。</p><p>首先记录一个邻接表，同时记录每个节点的入度。对于入度为0的节点，放入队列中。</p><p>对于队列中的节点，删除该节点，并将所有与该节点相连的节点入度-1，如果有节点入度减为0，则将该节点加入队列。循环上述过程，直到队列为空。</p><p>如果课程表是可行的，那么所有课程都被删除，否则仍存在未被删除的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pre : prerequisites)&#123;</span><br><span class="line">            edge[pre[<span class="number">1</span>]].<span class="built_in">push_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">            indegree[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> course = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> after : edge[course])&#123;</span><br><span class="line">                indegree[after]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[after] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(after);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似地，力扣上还有要求输出可行的上课顺序：</p><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210.课程表II</a></p><p>思路是类似的，只是相比起之前删除节点增加计数变成了给答案数组增加元素，不再赘述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; info : prerequisites)&#123;</span><br><span class="line">            edge[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            indegree[info[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> course = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(course);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> after : edge[course])&#123;</span><br><span class="line">                indegree[after]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[after] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(after);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>() == numCourses ? ans : <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转排序数组</title>
      <link href="/2022/03/08/searchInRotatedSortedArray/"/>
      <url>/2022/03/08/searchInRotatedSortedArray/</url>
      
        <content type="html"><![CDATA[<p>整数数组<code>nums</code>按升序排列，数组中的值互不相同。</p><p>在传递给函数之前，<code>nums</code>在预先未知的某个下标<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标从0开始计数）。例如，[0,1,2,4,5,6,7]在下标3处经旋转后可能变为[4,5,6,7,0,1,2]。</p><p>给你旋转后的数组<code>nums</code>和一个整数<code>target</code>，如果<code>nums</code>中存在这个目标值<code>target</code>，则返回它的下标，否则返回-1。</p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code>中的每个值都 独一无二</li><li>题目数据保证<code>nums</code>在预先未知的某个下标上进行了旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><span id="more"></span><p><del>啊哈哈哈！二分来咯！</del></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和为k的子数组</title>
      <link href="/2022/03/08/subarraySumEqualsK/"/>
      <url>/2022/03/08/subarraySumEqualsK/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组<code>nums</code>和一个整数<code>k</code>，请你统计并返回该数组中和为<code>k</code>的连续子数组的个数。</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 10^4</li><li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li><li>-10^7 &lt;&#x3D; k &lt;&#x3D; 10^7</li></ul><span id="more"></span><p><del>又是爷最爱的前缀和</del></p><p>暴力解法就不说了，懒得写一遍了<del>反正有手就行</del></p><p>这种题目比较容易想到的是用前缀和求解，遍历数组，每次记录到当前元素的前缀和<code>currSum</code>。如果想要得到和为<code>k</code>的子数组，应该搜索之前数组中前缀和为<code>currSum - k</code>的数组个数，加上即可。为了得到之前遍历过程中找到的前缀和为<code>currSum - k</code>的数组个数，可以用哈希表来记录。</p><p>不过需要考虑当前前缀和就等于<code>k</code>的情况，所以需要事先给哈希表加入<code>(0,1)</code>的键值对，说明已经有一个前缀和为0的数组，即空数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; times;</span><br><span class="line">        <span class="type">int</span> currSum = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        times[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            currSum += nums[i];</span><br><span class="line">            <span class="type">int</span> target = currSum - k;</span><br><span class="line">            <span class="keyword">if</span>(times.<span class="built_in">find</span>(target) != times.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ans += times[target];</span><br><span class="line">            &#125;</span><br><span class="line">            times[currSum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转字符串里的单词</title>
      <link href="/2022/03/08/reverseWordsInString/"/>
      <url>/2022/03/08/reverseWordsInString/</url>
      
        <content type="html"><![CDATA[<p>给你一个字符串<code>s</code>，逐个翻转字符串中的所有单词。</p><p>单词是由非空格字符组成的字符串。<code>s</code>中使用至少一个空格将字符串中的单词分隔开。</p><p>请你返回一个翻转s中单词顺序并用单个空格相连的字符串。</p><p>说明：</p><ul><li>输入字符串<code>s</code>可以在前面、后面或者单词间包含多余的空格。</li><li>翻转后单词间应当仅用一个空格分隔。</li><li>翻转后的字符串中不应包含额外的空格。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4</li><li><code>s</code>包含英文大小写字母、数字和空格<code>&#39; &#39;</code></li><li><code>s</code>中至少存在一个单词</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151.翻转字符串里的单词</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>反转这种事情，很容易想到栈。从前往后遍历字符，把单词压进去，再一个个弹出来，就刚好反转啦。</p><p>不过需要注意首尾以及单词间的空格，稍微处理一下就好啦，不难的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; sta;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[right] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                word.<span class="built_in">push_back</span>(s[left]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!word.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    sta.<span class="built_in">push</span>(word);</span><br><span class="line">                &#125;</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        word.<span class="built_in">push_back</span>(s[left]);</span><br><span class="line">        sta.<span class="built_in">push</span>(word);</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">append</span>(sta.<span class="built_in">top</span>());</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="原地算法"><a href="#原地算法" class="headerlink" title="原地算法"></a>原地算法</h1><p>原题里有个进阶，要求用O(1)的空间来完成。不过要注意一下，python和Java都做不到这点（因为它们的字符串不可变），小黎用的是C++（字符串可变），所以是可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; n; ++start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[start] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 填一个空白字符然后将idx移动到下一个单词的开头位置</span></span><br><span class="line">                <span class="keyword">if</span> (idx != <span class="number">0</span>) s[idx++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环遍历至单词的末尾</span></span><br><span class="line">                <span class="type">int</span> end = start;</span><br><span class="line">                <span class="keyword">while</span> (end &lt; n &amp;&amp; s[end] != <span class="string">&#x27; &#x27;</span>) s[idx++] = s[end++];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反转整个单词</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + idx - (end - start), s.<span class="built_in">begin</span>() + idx);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + idx, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最大子串</title>
      <link href="/2022/03/08/longestSubstringWithoutRepeatingCharacters/"/>
      <url>/2022/03/08/longestSubstringWithoutRepeatingCharacters/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串<code>s</code>，请你找出其中不含有重复字符的最长子串的长度。</p><p>提示：</p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4</li><li><code>s</code>由英文字母、数字、符号和空格组成</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3.无重复字符的最长子串</a></p><p>很明显是个滑动窗口，再加上用哈希表记录窗口内的字符就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>评论区有人提到：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/564157">答案有个缺点，左指针并不需要依次递增，即多了很多无谓的循环。 发现有重复字符时，可以直接把左指针移动到第一个重复字符的下一个位置即可。</a></p><p>改进代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>, left = <span class="number">0</span>, ans = <span class="number">0</span>, l = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(; right &lt; l; ++right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[right])&#123;</span><br><span class="line">                    left = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用反证法证明该算法的正确性</p><p>小黎感觉还挺巧妙的，可以回去多琢磨琢磨<del>就是暂时没搞懂为啥能过的意思</del></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转图像</title>
      <link href="/2022/03/08/rotateImage/"/>
      <url>/2022/03/08/rotateImage/</url>
      
        <content type="html"><![CDATA[<p>给定一个$n\times n$的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转90度。</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>提示：</p><ul><li>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 20</li><li>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/rotate-image/">48.旋转图像</a></p><p><del>感觉有我幼儿园那会脑筋急转弯那味了</del></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"></p><p>观察图片<del>易得</del>，可以把旋转进行分解，分解成转置和镜面，<strong>转置别写错了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[i][n - j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旋转图像 </tag>
            
            <tag> 脑筋急转弯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除二叉搜索树中的节点</title>
      <link href="/2022/03/08/deleteNodeInBST/"/>
      <url>/2022/03/08/deleteNodeInBST/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉搜索树的根节点root和一个值key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p>提示:</p><ul><li>节点数的范围$[0, 10^4]$.</li><li>$-10^5$ &lt;&#x3D; Node.val &lt;&#x3D; $10^5$</li><li>节点值唯一</li><li>root是合法的二叉搜索树</li><li>$-10^5$ &lt;&#x3D; key &lt;&#x3D; $10^5$</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450.删除二叉搜索树中的节点</a></p><p><del>这题目还假惺惺地告诉了你步骤</del></p><p>这题很明显地递归，如果你想看迭代的解法可以看<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/comments/155645">这里</a>，反正我是不会这么写的…</p><p>递归的思路很清晰，利用BST的性质即可：</p><ul><li>如果当前节点的值小于目标值，说明目标节点在右子树，往右子树递归</li><li>如果当前节点的值大于目标值，说明目标节点在左子树，往左子树递归</li><li>如果当前节点的值等于目标值，说明该节点为目标节点。如果该节点只有左子树或右子树，直接用非空子树替换即可。如果该节点左右子树都非空，将该节点的值替换为该节点的右子树中最小节点的值（一直往左子树找即可），往右子树递归，删除最小节点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; key)&#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; key)&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* temp = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;left)&#123;</span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                root-&gt;val = temp-&gt;val;</span><br><span class="line">                root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/2022/03/08/maximumSubarray/"/>
      <url>/2022/03/08/maximumSubarray/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组<code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53.最大子数组和</a></p><p>小黎一开始想用前缀和来做的，就是当前前缀和减去目前最小前缀和，和当前ans取max。但是这样的话对于包含第0个元素的答案是不行的，后面感觉这不就是动态规划的思想嘛，于是转头写动态规划了。</p><p>状态转移方程很直观，就是要么取之前数组和当前元素组合成一个数组，要么这个数组新开一个。设$f(i)$为数组前$i$个元素的最大前缀和，状态转移方程为：<br>$$<br>f(i) &#x3D; max(f(i - 1) + nums[i], nums[i])<br>$$<br>由于状态转移方程只和前一个结果有关，所以用一个变量存储之前的结果就行。取遍历过程中的最大值作为结果就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            pre = <span class="built_in">max</span>(nums[i] + pre, nums[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最近公共祖先</title>
      <link href="/2022/03/07/lowestCommonAncestorOfABinaryTree/"/>
      <url>/2022/03/07/lowestCommonAncestorOfABinaryTree/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点p、q，最近公共祖先表示为一个节点x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>提示：</p><ul><li>树中节点数目在范围[2, 10^5]内。</li><li>-10^9 &lt;&#x3D; Node.val &lt;&#x3D; 10^9</li><li>所有Node.val互不相同。</li><li>p !&#x3D; q</li><li>p和q均存在于给定的二叉树中。</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236.二叉树的最近公共祖先</a></p><p>递归！</p><p>后序遍历，从下往上递归。</p><p>递归出口：当前结点为空或为目标节点，则返回该结点。</p><p>结点操作：</p><ul><li>如果左子树和右子树递归结果都是空指针，说明该节点下无目标结点，返回空指针。</li><li>如果左子树和右子树递归结果都不为空指针，说明该根结点为所求LCA（因为是从下往上找的嘛。</li><li>如果左子树和右子树中有一个是空结点，说明目标节点存在于某一个子树中，返回非空的子树。</li></ul><p>就是个递归啦！想到就很简单！上代码！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="literal">nullptr</span> ? right : left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树最大路径和</title>
      <link href="/2022/03/07/binaryTreeMaximumPathSum/"/>
      <url>/2022/03/07/binaryTreeMaximumPathSum/</url>
      
        <content type="html"><![CDATA[<p><strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中<strong>至多出现一次</strong>。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><p><strong>路径和</strong>是路径中各节点值的总和。</p><p>给你一个二叉树的根节点<code>root</code>，返回其最大路径和。</p><p>提示：</p><ul><li>树中节点数目范围是$[1, 3 * 10^4]$</li><li>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树的最大路径和</a></p><p><del>其实我感觉题目有点不说人话</del></p><p>这题相当于，把二叉树当成一个无向图，求所经过结点之和最大的路径。</p><p>这题可以递归解，单独考虑只有根节点、左节点和右节点的二叉树。由于迭代是向上的，所以是一颗颗这样的小树组成一整颗大树。对于一颗小树，可以有如下几个选择：</p><ul><li>和上端大树相连</li></ul><ol><li>选择根节点</li><li>选择根节点、左节点</li><li>选择根节点、右节点</li></ol><ul><li>不和上端大树相连，重新开辟新的路径</li></ul><ol><li>选择左节点、根节点、右节点</li><li>选择左节点</li><li>选择右节点</li></ol><p>和上端大树相连的情况，可以返回三者取<code>max</code>的结果作为返回值；而不和上端大树相连的情况，可以单独缓存至一个变量里，每次递归时更新该值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = -INT_MAX;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">recur</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -INT_MAX / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">recur</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">recur</span>(node-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(&#123;ans, left, right, left + node-&gt;val + right&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(&#123;node-&gt;val, node-&gt;val + left, node-&gt;val + right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 最大路径和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/03/07/reverseList/"/>
      <url>/2022/03/07/reverseList/</url>
      
        <content type="html"><![CDATA[<p>大链表吱呀吱悠悠地转♪</p><p>这里~的风景呀真奇怪♪</p><p>天在转♪ 地在转♪</p><p>还有一个刷题的小笨蛋♪</p><span id="more"></span><p>反转链表！经久不衰的<del>送分</del>题！</p><h1 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206.反转链表</a></p><p>给你单链表的头节点<code>head</code>，请你反转链表，并返回反转后的链表。</p><p>提示：</p><ul><li>链表中节点的数目范围是[0, 5000]</li><li>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</li></ul><p>迭代和<del>递龟</del>递归都可以哦！</p><h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><p>遍历整个链表，反转一下next指针的方向就好了，非常简单，不赘述啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>递归的版本就比较复杂一些，关键在于反向工作。假设链表的其余部分已经被反转，那么考虑如何反转之前的部分。</p><p>假设链表长这样：<br>$$<br>n_1 \rightarrow \dots n_{k - 1} \rightarrow n_k \rightarrow n_{k + 1} \rightarrow \dots \rightarrow n_m \rightarrow nullptr<br>$$</p><p>如果我们已经将$n_{k + 1} \rightarrow \dots \rightarrow n_m$的部分反转，目前来到了$n_k$。那么我们希望$n_k$的下一个结点$n_{k + 1}$能指向$n_k$。即：<br>$$<br>n_k\rightarrow next\rightarrow next &#x3D; n_k<br>$$</p><p>那就开始递归吧！从后往前反转链表，就一直一直往后冲。但是需要一个出口呀，这里设置当结点为空或到达链表末端时返回该结点，相当于是新链表的头部啦！之后就是之前分析的部分啦，执行<code>head-&gt;next-&gt;next = head;</code>更改指针的方向。但是要记得把当前指针的<code>next</code>设为空哦，不然就会有环啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="反转部分链表"><a href="#反转部分链表" class="headerlink" title="反转部分链表"></a>反转部分链表</h1><p>反转所有链表还是太简单了（单指迭代，上点有意思的：反转部分链表！</p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92.反转部分链表 II</a></p><h2 id="截取需要反转部分单独操作"><a href="#截取需要反转部分单独操作" class="headerlink" title="截取需要反转部分单独操作"></a>截取需要反转部分单独操作</h2><p>最容易想到的思路就是，借鉴之前反转整个链表的想法，弄四个指针，两个指针在开始反转部分的前一个和开始部分，设为<code>pre</code>和<code>leftNode</code>；两个指针在反转部分的结束部分和后一个结点，设为<code>rightNode</code>和<code>curr</code>。将<code>pre</code>和<code>rightNode</code>的<code>next</code>设为空，将需要反转的部分独立出来，单独进行反转。反转完成后再接回原来的链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseLinkedList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 也可以使用递归反转一个链表</span></span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">        ListNode *rightNode = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            rightNode = rightNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">        ListNode *leftNode = pre-&gt;next;</span><br><span class="line">        ListNode *curr = rightNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：切断链接</span></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rightNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">        <span class="built_in">reverseLinkedList</span>(leftNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">        pre-&gt;next = rightNode;</span><br><span class="line">        leftNode-&gt;next = curr;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>上一个方法当需要反转的区间长度非常大的时候，时间开销会变大，极端情况下需要遍历两次链表。考虑使用“头插法”实现一次遍历的反转部分链表。</p><p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。</p><p>下面我们具体解释如何实现。使用三个指针变量 <code>pre</code>、<code>curr</code>、<code>next</code>来记录反转的过程中需要的变量，它们的意义如下：</p><ul><li><code>curr</code>：指向最初的待反转区域的第一个节点；</li><li><code>next</code>：永远指向<code>curr</code>的下一个节点，循环过程中，<code>curr</code>变化以后<code>next</code>会变化；</li><li><code>pre</code>：永远指向最初的待反转区域的第一个节点<code>left</code>的前一个节点，在循环过程中不变。</li></ul><p>（要画的图太多了，直接手写了</p><p><img src="https://img30.360buyimg.com/pop/jfs/t1/108587/29/25572/2142718/62262091Eb51130ab/c7fcb3389707aaa1.png" alt="reverselink.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的第k个最大元素</title>
      <link href="/2022/03/07/kthBiggest/"/>
      <url>/2022/03/07/kthBiggest/</url>
      
        <content type="html"><![CDATA[<p>（小黎最近在忙刷题，网课先告一段落！绝对不鸽！<del>咕咕咕</del></p><p>给定整数数组<code>nums</code>和整数<code>k</code>，请返回数组中第<code>k</code>个最大的元素。</p><p>提示：</p><ul><li>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li><li>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</li></ul><span id="more"></span><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215.数组中的第K个最大元素</a></p><p>这个主要就是用到了<strong>快排</strong>的思想啦！随机选择数组中的一个数作为<code>key</code>，之后将比<code>key</code>小的数放到它的右边，比它大的放左边。（因为要第<code>k</code>大嘛！如果要第<code>k</code>小的话就比它大的反过来就好啦！）</p><p>排序完之后，如果<code>key</code>刚好在第<code>k</code>个的位置的话，直接返回就好啦。如果<code>key</code>的下标小于<code>k - 1</code>（这里是用于下标从0开始计算的语言哦！下标从1开始的语言要变一下哦，灵活变一下啦），那么所求元素在<code>key</code>的右边，继续对右边进行相同的操作；如果<code>key</code>的下标大于<code>k - 1</code>，那么所求元素在<code>key</code>的左边，继续对左边进行相同的操作。</p><p>快速排序的性能和划分出的子数组的长度密切相关。直观地理解就是，如果每次规模为$n$的问题我们都划分成$1$和$n - 1$，每次递归的时候又向$n - 1$的集合中递归，这种情况是最坏的，时间代价是$O(n ^ 2)$。我们可以<strong>引入随机化来加速</strong>这个过程，它的时间代价的期望是$O(n)$，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p><p>放上小黎的代码！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getKth</span>(nums, k - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right != left)&#123;</span><br><span class="line">            <span class="type">int</span> random = <span class="built_in">rand</span>() % (right - left) + left;</span><br><span class="line">            <span class="built_in">swap</span>(nums[random], nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span>(idx == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[idx];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx &gt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKth</span>(nums, k, left, idx - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKth</span>(nums, k, idx + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> begin = left - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> key = nums[right];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; key)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++begin], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[++begin], nums[right]);</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时：4ms，超过了97%的cpp提交记录<br>内存消耗：9.6MB，超过了90%的cpp提交记录</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小黎与算法题互相折磨的前世今生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速选择 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客图片居中大法</title>
      <link href="/2022/03/01/center-img/"/>
      <url>/2022/03/01/center-img/</url>
      
        <content type="html"><![CDATA[<p>忍了几天，但是博客图片靠左真的<strong>太丑了</strong><br>丑到我的懒癌都压不住<br>上网找了些方法，记录一下吧</p><span id="more"></span><p>Markdown这玩意生下来就不带图片居中这花里胡哨的玩意，不过人家支持html语法，可以<strong>曲线救国</strong>一下。</p><h1 id="使用html格式"><a href="#使用html格式" class="headerlink" title="使用html格式"></a>使用html格式</h1><p>像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s4.ax1x.com/2022/03/01/blYdKA.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来，试试看！</p><div align="center">    <img src="https://s4.ax1x.com/2022/03/01/blYdKA.png"></img></div><p>这不就居中了嘛！</p><h1 id="难道要我在贴图的时候一个个改吗！"><a href="#难道要我在贴图的时候一个个改吗！" class="headerlink" title="难道要我在贴图的时候一个个改吗！"></a>难道要我在贴图的时候一个个改吗！</h1><p>像我这种<strong>大懒人</strong>自然是不会这么做的，之前的方法适用于没几个图的博客。<del>但是我相信过段时间你的博客就不是没几个图的状态了</del></p><p>MarkDown插入图片代码在最终渲染的时候，其实是变成了html中的img元素。因此我们可以直接<del>直接杀</del>去博客主题文件的源代码，找到控制文章内图片显示样式的css代码，将其修改成水平居中即可。</p><p>一般在<code>themes-&gt;(主题名称文件夹)-&gt;source-&gt;css-&gt;_partial</code>文件夹中可以找到，懒得找的直接在文件夹里搜索<code>img</code>也行（反正我就这么找着的</p><p>img后面有一坨花括号，改改就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">    max-width 100%;</span><br><span class="line">    display block;</span><br><span class="line">    margin 0 auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我当时改了最后一行，并加上了倒数第二行。这个方法参考的是<a href="https://www.butterpig.top/blog/hexo-img-center/">这篇博客</a>，和人家的有些出入，如果我的法子不行可以试试别人的~</p>]]></content>
      
      
      <categories>
          
          <category> 强迫症小黎的悲惨晚年 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客图片居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于MarkDown语法中加粗失效的问题</title>
      <link href="/2022/03/01/md-20220301/"/>
      <url>/2022/03/01/md-20220301/</url>
      
        <content type="html"><![CDATA[<p>小黎今天肝计网的时候，发现有个地方加粗失效了<br>但是下面的加粗又是可以的！<br>小黎上网找了找原因发现…<br>震惊！真相竟然是这个…<br><del>（一天天震惊震惊的，怎么不吓死你</del></p><span id="more"></span><h1 id="事件起因"><a href="#事件起因" class="headerlink" title="事件起因"></a>事件起因</h1><p>效果就是下图那样啦，上面的式子不能加粗，下面的可以（这个笔记写太快了，有很多小问题，忽略就好啦…</p><p><a href="https://imgtu.com/i/bMHNi6"><img src="https://s4.ax1x.com/2022/03/01/bMHNi6.png" alt="bMHNi6.png"></a></p><h1 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h1><p>后面小黎上网发现，加粗的开始标记符（就是前面两个小星星），和结束标记符（就是后面的两个小星星）对前后内容是有要求的！</p><h2 id="开始前先了解一下CommonMark规范吧"><a href="#开始前先了解一下CommonMark规范吧" class="headerlink" title="开始前先了解一下CommonMark规范吧"></a>开始前先了解一下CommonMark规范吧</h2><blockquote><p>Markdown将<code>*</code>与<code>_</code>作为强调指示符。被单个<code>*</code>或<code>_</code>包裹的文本将被HTML<code>&lt;em&gt;</code>标签包裹（也就是斜体）；被两个包裹的将被HTML<code>&lt;strong&gt;</code>标签包裹（也就是粗体）。</p></blockquote><p>先说几个关键词的意思吧~</p><h3 id="定界符序列（delimiter-run）"><a href="#定界符序列（delimiter-run）" class="headerlink" title="定界符序列（delimiter run）"></a>定界符序列（delimiter run）</h3><p>定界符类指的是：</p><ul><li>一个或一串非转义的<code>*</code>；</li><li>一个或一串非转义的<code>_</code>。</li></ul><h3 id="左侧定界符序列（left-flanking-delimiter-run）"><a href="#左侧定界符序列（left-flanking-delimiter-run）" class="headerlink" title="左侧定界符序列（left-flanking delimiter run）"></a>左侧定界符序列（left-flanking delimiter run）</h3><p>左侧定界符序列是一个定界符序列，且：</p><ul><li>后面不能是空白；</li><li>当前面没有空白或标点符号时，后面不能是标点符号。</li></ul><h3 id="右侧定界符序列（right-flanking-delimiter-run）"><a href="#右侧定界符序列（right-flanking-delimiter-run）" class="headerlink" title="右侧定界符序列（right-flanking delimiter run）"></a>右侧定界符序列（right-flanking delimiter run）</h3><p>右侧定界符序列是一个定界符序列，且：</p><ul><li>前面不能是空白；</li><li>当后面没有空白或标点符号时，前面不能是标点符号。</li></ul><h2 id="结合一下车祸现场吧"><a href="#结合一下车祸现场吧" class="headerlink" title="结合一下车祸现场吧"></a>结合一下车祸现场吧</h2><p>结合上方的例子，后面的<code>**</code>的前面是标点符号，但后面却不是空白或标点符号，所以它不是右侧定界符序列，不会被当作是结束粗体的标识符，自然粗体就不生效了。</p><p>（就是人家的自我认知出了点差错，怪我怪我…</p><h2 id="可是，为什么要这么定义？"><a href="#可是，为什么要这么定义？" class="headerlink" title="可是，为什么要这么定义？"></a>可是，为什么要这么定义？</h2><p>为了能支持嵌套分隔符序列，<code>**one **two two **three** two two** one**</code>：</p><blockquote><p><strong>one <strong>two two <strong>three</strong> two two</strong> one</strong></p></blockquote><p>这里就不具体说了，只能说懂的都懂（bushi</p><p>这样的影响是什么呢，就是使用非空格分词语言（比如中文）的用户只能<strong>骂骂咧咧</strong><font size=1><del>地继续用下去</del></font></p><h1 id="那怎么办！解决方案呢！"><a href="#那怎么办！解决方案呢！" class="headerlink" title="那怎么办！解决方案呢！"></a>那怎么办！解决方案呢！</h1><h2 id="你多加个空格不就行了"><a href="#你多加个空格不就行了" class="headerlink" title="你多加个空格不就行了"></a>你多加个空格不就行了</h2><p>相信大多数非强迫症患者会采用这个方案（就像我，但是感觉根源还是<strong>懒</strong></p><p>可是哪个中国人写字没事加空格啊！</p><h2 id="好吧，那试试零宽空格（zero-width-space，ZWSP）"><a href="#好吧，那试试零宽空格（zero-width-space，ZWSP）" class="headerlink" title="好吧，那试试零宽空格（zero-width space，ZWSP）"></a>好吧，那试试零宽空格（zero-width space，ZWSP）</h2><p>ZWSP长这样！锵锵！</p><blockquote><p>​</p></blockquote><p>什么？你说看不到？<del>其实聪明的人才看得到</del></p><p>看不到就对啦，ZWSP是一种不可打印的<code>Unicode</code>字符（<code>U+200B</code>），用于可能需要换行处。</p><p>我们可以使用ZWSP<strong>指定长文字的换行位置</strong>；只有当荧幕宽度不足以单行显示时ZWSP才会起作用。</p><p>举个例子，没有使用 ZWSP 时是这样的：</p><blockquote><p>LongLongLongLongLongLongLongLongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p></blockquote><p>使用ZWSP时是这样的</p><blockquote><p>LongLongLongLongLongLongLongLongLongLongLongLongLongLongLong​BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p></blockquote><p>由于 ZWSP 这种特殊属性，它也被用于<del>绕过敏感词检查</del>、创造不可复制的伪链接等等。</p><p>回到之前的问题，只要在需要加空格的地方加上ZWSP就好啦~</p><p>这个字符可以在<a href="https://unicode-table.com/en/200B/">这里</a>复制，点击copy就好啦</p><p><del>懒得截图了，还得上传图床</del></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与MarkDown不得不说的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加粗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-数据链路层</title>
      <link href="/2022/02/28/computerInternet-3/"/>
      <url>/2022/02/28/computerInternet-3/</url>
      
        <content type="html"><![CDATA[<p>小黎一天学一章，小黎真棒<br>上一章笔记的图片尺寸有些过于大了…<br>小黎懒得改，小黎真懒</p><span id="more"></span><h1>数据链路层概述</h1><ul><li>链路：从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点</li><li>数据链路：把实现通信协议的硬件和软件加到链路上，就构成了数据链路</li><li>数据链路层以<strong>帧</strong>为单位传输和处理数据</li></ul><p><a href="https://imgtu.com/i/bKcRsO"><img src="https://s4.ax1x.com/2022/02/28/bKcRsO.png" alt="bKcRsO.png"></a></p><h2 id="使用点对点信道的数据链路层">使用点对点信道的数据链路层</h2><h3 id="封装成帧">封装成帧</h3><p>数据链路层<strong>给网络层交付的协议数据单元添加帧头和帧尾</strong>的操作，称为封装成帧。添加帧头和帧尾都是为了在链路上以帧为单元传送数据，也就是为了实现数据链路层本身的功能。</p><p><a href="https://imgtu.com/i/bMSszt"><img src="https://s4.ax1x.com/2022/02/28/bMSszt.png" alt="bMSszt.png"></a></p><h3 id="差错检测">差错检测</h3><p>发送方将封装好的帧通过物理层发送到传输媒体，帧在传输过程中遭遇干扰后可能会出现<strong>误码</strong>（0变成1，1变成0）。发送方在发送数据之前，基于待发送的数据和检错算法计算出检错码，并将其封装在帧尾；接收方主机收到帧后，通过检错码和检错算法能够判断出帧在传输过程中是否出现了误码。</p><h3 id="可靠传输">可靠传输</h3><p>尽管误码不能完全避免，但若能实现<strong>发送方发送什么，接收方就能收到什么</strong>，就称为可靠传输。</p><h2 id="使用广播信道的数据链路层">使用广播信道的数据链路层</h2><ul><li>编址问题：将帧的目的地址放在帧中一起传输</li><li>碰撞问题：多个主机同时使用总线传输帧时，传输信号会发生碰撞。<br>（共享式以太网的媒体接入控制协议CSMA/SD、802.11局域网的媒体接入控制协议CSMA/CA）</li></ul><h2 id="数据链路层的互连设备">数据链路层的互连设备</h2><ul><li>网桥和交换机的工作原理</li><li>集线器（物理层互连设备）与交换机的区别</li></ul><h1>封装成帧</h1><h2 id="帧定界">帧定界</h2><ul><li>帧头和帧尾的作用之一就是<strong>帧定界</strong></li><li>并不是所有帧头和帧尾都包含帧定界标志，物理层会给其添加前导码，其中包括前同步码和帧开始定界符。另外以太网还规定了帧间间隔时间，故MAC不需要帧结束定界符。</li></ul><h2 id="透明传输">透明传输</h2><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，就好像数据链路层不存在一样。（例如不要求不能出现帧定界符，通过扫描上层传输数据并在与帧定界符相同内容前面添加转义字符解决</p><ul><li>面向字节的物理链路使用字节填充（字符填充）的方法实现透明传输</li><li>面向比特的物理链路使用比特填充的方法实现透明传输</li></ul><h2 id="传输效率">传输效率</h2><ul><li>为了提高帧的传输速率，应当使<strong>帧的数据部分长度尽可能大些</strong>。</li><li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即<strong>最大传送单元MTU</strong>。</li></ul><h1>差错检测</h1><ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能变成0，0可能变成1，这称为<strong>比特差错</strong>。</li><li>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER</strong>。</li><li>使用<strong>差错检测</strong>来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li></ul><h2 id="奇偶校验">奇偶校验</h2><ul><li>在待发送的数据后面<strong>添加1位奇偶校验位</strong>，使整个数据（包括所添加的校验位在内）中<strong>1的个数</strong>为奇数（奇校验）或偶数（偶校验）</li><li>如果有<strong>奇数个位数发生误码</strong>，则奇偶性发生变化，<strong>可以检查出误码</strong></li><li>如果有<strong>偶数个位数发生误码</strong>，则奇偶性不发生变化，<strong>不可以检查出误码</strong>（<strong>漏检</strong>）</li></ul><p>（太弱了，一般不用</p><h2 id="循环冗余校验CRC（Cyclic-Redundancy-Check）">循环冗余校验CRC（Cyclic Redundancy Check）</h2><ul><li>收发双方约定好一个<strong>生成多项式G(x)</strong></li><li>发送方基于待发送的数据和生成多项式计算出差错检测码（<strong>冗余码</strong>），将其添加到代传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ul><p><a href="https://imgtu.com/i/bMMXJ1"><img src="https://s4.ax1x.com/2022/02/28/bMMXJ1.png" alt="bMMXJ1.png"></a></p><h3 id="发送方">发送方</h3><ul><li><strong>待发送的数据作为被除数的一部分，后面添加生成多项式最高次个0</strong>以构成被除数。</li><li><strong>生成多项式各项系数</strong>构成的比特串作为除数</li><li>相除得到的余数作为冗余码，将其添加到待发送数据的后面一起发送</li><li>冗余码的<strong>长度与生成多项式最高次数相同</strong>，商仅作为标记，防止计算过程中对错位</li></ul><h3 id="接受方">接受方</h3><ul><li><strong>已接收的数据</strong>作为被除数。</li><li><strong>生成多项式各项系数</strong>构成的比特串作为除数</li><li>相除得到的<strong>余数如果为0则可以判定传输过程没有产生误码，否则产生了误码</strong></li></ul><h3 id="特别说明">特别说明</h3><ul><li><strong>检错码</strong>只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法<strong>纠正错误</strong></li><li>要想纠正传输中的差错，可以使用冗余信息更多的<strong>纠错码</strong>进行<strong>前向纠错</strong>。但纠错码的开销比较大，<strong>在计算机网络中较少使用</strong></li><li>循环冗余校验CRC有很好的检错能力（<strong>漏检率非常低</strong>），虽然计算复杂，但非常<strong>易于用硬件实现</strong>，因此被<strong>广泛应用于数据链路层</strong></li><li>在计算机网络中通常采用<strong>检错重传</strong>方式来纠正传输中的差错，或者<strong>仅丢弃检测到差错的帧</strong>，这取决于数据链路层向上层提供的传输服务是否可靠</li></ul><h1>可靠传输</h1><h2 id="基本概念">基本概念</h2><ul><li>一般情况下，<strong>有线链路</strong>的误码率比较低，为了减小开销，<strong>并不要求数据链路层向上提供可靠传输服务</strong>。即使出现了误码，可靠传输的问题由上层处理。</li><li><strong>无线链路</strong>易受干扰，误码率比较高，因此<strong>要求数据链路层必须向上层提供可靠传输服务</strong>。</li><li>传输差错种类：比特差错、分组丢失、分组失序、分组重复。后面三种差错一般不会出现在数据链路层，而会出现在其上层。</li><li><strong>可靠传输服务不仅局限于数据链路层</strong>，其他各层均可实现可靠传输</li><li>可靠传输的实现比较复杂，开销也比较大。是否使用可靠传输取决于应用需求</li></ul><p><a href="https://imgtu.com/i/bMl64s"><img src="https://s4.ax1x.com/2022/02/28/bMl64s.png" alt="bMl64s.png"></a></p><h2 id="可靠传输的实现机制">可靠传输的实现机制</h2><p>（这三种可靠传输实现机制的基本原理<strong>并不仅限于数据链路层</strong>，可以应用到计算机网络体系结构的各层协议中</p><h3 id="停止-等待协议SW（Stop-and-Wait）-自动请求重传ARQ（Automatic-Repeat-reQuest）">停止-等待协议SW（Stop-and-Wait）/自动请求重传ARQ（Automatic Repeat reQuest）</h3><p><a href="https://imgtu.com/i/bMYKgA"><img src="https://s4.ax1x.com/2022/02/28/bMYKgA.png" alt="bMYKgA.png"></a></p><h4 id="确认与否认">确认与否认</h4><ul><li>发送方给接收方发送数据分组，接收方收到后进行差错检测检测，若没有误码则接受该分组，给发送方发送确认分组（ACK）。发送方收到接收方的确认分组后，才能发送下一个数据分组。</li><li>若发现了误码，则丢弃该分组，并给发送方发送否认分组（NAK）。发送方收到否认分组后重传数据分组。因此<strong>发送方发送完成数据分组后，并不能立刻将该数据分组从缓存中删除，只有收到确认分组才可删除</strong>。</li></ul><h4 id="超时重传">超时重传</h4><p>（对于数据链路点对点信道而言不太容易出现这种情况，但对于多个网络通过多个路由器互联的复杂互联网而言，这种情况会经常出现。</p><ul><li>为避免发送方一直等待接收方ACK或NAK的状态，可以启用<strong>超时计时器</strong>，若超过计时器所设置的<strong>重传时间</strong>，则重传原先的数据分组，称为<strong>超时重传</strong>。</li><li>一般重传时间<strong>略大于从发送方到接收方的平均时间</strong>。</li></ul><h4 id="确认丢失">确认丢失</h4><ul><li>若接收方发送的ACK在传输过程中丢失，会导致发送方的超时重传，从而导致分组重复</li><li>为避免分组重复，<strong>给每个分组带上序号</strong>。</li><li>对于停止-等待协议，由于每发送一个分组就停止等待，只要保证每发送一个新的数据分组，其<strong>编号与上一组不同</strong>即可，因此只用<strong>一个比特来编号即可</strong>。</li></ul><h4 id="确认迟到">确认迟到</h4><p>（对于数据链路点对点信道而言不太容易出现这种情况，往返时间比较固定，不会出现确认迟到的情况。因此如果只<strong>在数据链路层实现该协议，可以不用给确认组编号</strong>。</p><ul><li>由于某些原因确认分组迟到了，导致超时重传。在重传的过程中发送方收到了迟到的确认分组，再次发送下一分组。而此时发送方接收到了重传的分组，再次发送确认分组，导致发送方误认为是对下一分组的确认。</li><li>为避免该种误判，需要<strong>对确认分组进行编号</strong>。</li></ul><h4 id="注意事项">注意事项</h4><ul><li>数据链路层点对点往返时间比较确定，重传时间比较好设定</li><li>运输层由于端到端往返时间不确定，设置合适的重传时间有时并不容易</li></ul><h4 id="信道利用率">信道利用率</h4><ul><li>图中忽略了接收方对数据分组的处理时延，以及发送方对确认分组的处理时延</li><li>一般TA都远小于TD，可以忽略</li><li>当RTT远大于TD时（例如使用卫星链路），信道利用率会非常低。若出现重传，利用率会更低。</li><li>为克服SW协议信道利用率低的缺点，产生了GBN协议和SR协议。</li></ul><p><a href="https://imgtu.com/i/bMU28g"><img src="https://s4.ax1x.com/2022/02/28/bMU28g.png" alt="bMU28g.png"></a></p><h3 id="回退N帧协议GBN（Go-Back-N）">回退N帧协议GBN（Go-Back-N）</h3><p>该协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数。如图所示：</p><ul><li>本例采用3个比特给分组编号，即序号0-7</li><li>发送窗口的尺寸WT的取值为：1 &lt;= WT &lt;= 2^3 - 1，本例取5</li><li>接收窗口的尺寸WR只能取1，与停止等待协议相同</li></ul><p><a href="https://imgtu.com/i/bMwnC8"><img src="https://s4.ax1x.com/2022/02/28/bMwnC8.png" alt="bMwnC8.png"></a></p><h4 id="无差错情况">无差错情况</h4><ol><li>发送发将<strong>落在发送窗口内</strong>的0-4号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，没有出现乱序和误码，正确地到达了接收方</li><li>接收方按序接受数据，<strong>每接收一个，接收窗口就向前滑动一个位置</strong>，并给发送方<strong>发送针对所接收分组的确认分组</strong></li><li>确认分组经过互联网的传输，没有出现乱序和误码，正确地到达了发送方</li><li>发送方按序接受数据，<strong>每接收一个，发送窗口就向前滑动一个位置</strong>，这样就有新的序号落入发送窗口，<strong>发送方将收到确认分组的数据分组从缓存中删除</strong></li></ol><h4 id="累积确认">累积确认</h4><p>接收方<strong>不一定</strong>要对收到的数据分组<strong>逐个发送确认</strong>，而是可以在收到几个数据分组后<strong>对按序到达的最后一个数据分组发送确认</strong>。ACKn表示序号为n及以前的所有数据分组都已正确接收。</p><ol><li>发送发将<strong>落在发送窗口内</strong>的0-4号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，没有出现乱序和误码，正确地到达了接收方</li><li>接收方按序接受数据，当接受完0-1号数据分组后，发送累计确认ACK1；接受完2-4号数据分组后，发送累计确认ACK4</li><li>假设ACK1丢失，ACK4正确到达</li><li>发送方接受ACK4之后，知道了序号为4及之前的数据分组已经被正确接收。于是移动窗口，删除缓存。</li></ol><ul><li><p>优点</p><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>此外，还能减少接收方的开销，减少对网络资源的占用</li></ul></li><li><p>缺点</p><ul><li>不能向发送方及时反映出接收方已经正确接收的分组信息</li></ul></li></ul><h4 id="有差错情况">有差错情况</h4><ol><li>发送发将<strong>落在发送窗口内</strong>的5-6-7-0-1-2号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，<strong>5号数据分组出现误码</strong></li><li>接收方按序接受数据，发现5号数据分组的错误，于是<strong>丢弃该数据分组</strong>。<strong>后续到达的四个分组的序号与接收窗口中的序号不匹配</strong>，接收方也不能接受，将其丢弃，并<strong>对之前按序接收的最后一个数据分组进行确认</strong>，即发送ACK4。<strong>每丢弃一个数据分组，就发送一次ACK4</strong>。</li><li>四个ACK4经过互联网的传输，没有出现乱序和误码，正确地到达了发送方</li><li>发送方收到重复的ACK4时，知道了之前发送的数据分组出现差错，于是<strong>可以不等超过计时器超时就立即重传</strong>。至于收到几个重复确认就立刻重传，由具体实现决定。</li></ol><p>在本例中，尽管序号为6-7-0-1的数据分组正确到达接收方，但<strong>由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受，发送方还要重传这些数据分组</strong>，这就是所谓的Go-Back-N（回退N帧）</p><p>可见，<strong>当通信线路质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高</strong>。</p><h4 id="发送窗口尺寸超过上限">发送窗口尺寸超过上限</h4><ol><li>发送发将<strong>落在发送窗口内</strong>的0-7号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，没有出现乱序和误码，正确地到达了接收方</li><li>接收方按序接受数据，<strong>每接收一个，接收窗口就向前滑动一个位置</strong>，并给发送方<strong>发送针对所接收分组的确认分组</strong></li><li>确认分组经过互联网的传输丢失，没有到达发送方</li><li>发送方<strong>超时重传</strong>，重复发送0-7号数据分组</li><li>接收方<strong>重复接收</strong>之前的0-7号数据分组。即接收方<strong>无法分辨新旧分组</strong>，进而产生<strong>分组重复</strong>这种数据差错。</li></ol><h4 id="回退N帧协议小结">回退N帧协议小结</h4><p><a href="https://imgtu.com/i/bMrxpV"><img src="https://s4.ax1x.com/2022/02/28/bMrxpV.png" alt="bMrxpV.png"></a></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种<strong>连续ARQ协议</strong>。</li><li>在协议工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为<strong>滑动窗口协议</strong>。</li><li>由于回退N帧协议的特性，<strong>当通信线路质量不好时，其信道利用率并不比停止-等待协议高</strong>。</li></ul><h3 id="选择重传协议SR（Selective-Request）">选择重传协议SR（Selective Request）</h3><ul><li>回退N帧协议的接收窗口尺寸只能等于1，因此<strong>接受方只能按序接收正确到达的数据分组</strong>。</li><li>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按需接收而丢弃（尽管它们无乱序和误码）。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</li><li>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，<strong>接收窗口的尺寸不再等于1，而应大于1</strong>，以便<strong>接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组</strong>，等到所缺分组收齐后再一并送交上层。这就是<strong>选择重传协议</strong>。</li><li>选择重传协议为了使发送方仅重传出现差错的分组，接收方<strong>不能再采用累积确认</strong>，而需要对每个正确接收到的数据分组进行<strong>逐一确认</strong>。</li></ul><h4 id="工作原理">工作原理</h4><ul><li>本例采用3个比特给分组编号，即序号0-7</li><li>发送窗口的尺寸WT的取值为：1 &lt;= WT &lt;= 2^(3 - 1)，本例取4</li><li>接收窗口的尺寸WR一般情况下和发送窗口尺寸WT相同，本例取4</li></ul><p><a href="https://imgtu.com/i/bMIxaV"><img src="https://s4.ax1x.com/2022/03/01/bMIxaV.png" alt="bMIxaV.png"></a></p><ol><li>发送发将<strong>落在发送窗口内</strong>的0-3号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，但其中的2号数据分组出现丢失</li><li>只要<strong>序号落入接收窗口内且无误码</strong>的分组，接收方都会接收。此时接收窗口为0-1-2-3。</li><li>接收方接收0号和1号数据分组，并发送0号和1号确认分组。接收窗口向前滑动两个位置。这样就有4和5这两个新的信号落入接收窗口。</li><li>接收方接收3号数据分组，并发送三号确认分组，但<strong>接收窗口不能向前滑动，因为3号分组是未按序到达的数据分组</strong>。</li><li>确认分组经过互联网的传输，陆续到达了发送方</li><li>发送方按序接接收确认分组，<strong>每接收一个，发送窗口就向前滑动一个位置</strong>。发送方接收0号和1号确认分组，发送窗口向前滑动两个位置，这样就有4-5新的序号落入发送窗口。</li><li>发送方将序号落入发送窗口的4号和5号发送窗口的数据分组发送出去，并将已确认收到的0和1号数据分组从发送缓存中删除。</li><li>发送方接收3号确认分组，但<strong>发送窗口不能向前滑动，因为这是一个未按序到达的确认分组</strong>。但<strong>需要记录3号数据分组已收到确认</strong>，这样该数据分组就不会超时重发。</li><li>假设在4号和5号确认分组的传输过程中，发送方针对2号数据分组的<strong>重传计时器超时</strong>，发送方重新发送2号数据分组。</li><li>4号和5号数据分组到达接收方，接收方接收它们并发送4号和5号确认分组，但<strong>接收窗口不能向前滑动</strong>，因为是未按序到达的数据分组。但<strong>需要记录4号和5号数据分组已收到确认</strong>，这样就不会超时重发。</li><li>发送方之前重传的2号数据分组到达接收方，接收方接收该数据分组，并发送2号数据分组。由于之前3-4-5已标记收到，此时<strong>接收窗口可以向前滑动四个窗口</strong>，这样就有6-7-0-1这四个新的序号落入接收窗口。</li><li>2号确认分组经过互联网的传输到达发送方，发送方接收该确认分组。由于之前3-4-5已标记发送，此时<strong>发送窗口可以向前滑动四个窗口</strong>，这样就有6-7-0-1这四个新的序号落入发送窗口。</li><li>此时发送方可以继续将6-7-0-1这四个序号的数据分组发送出去。</li></ol><h4 id="发送窗口和接收窗口的尺寸问题">发送窗口和接收窗口的尺寸问题</h4><p>发送方的发送窗口尺寸WT必须满足<strong>1 &lt; WT &lt;= 2^(n-1)</strong> ，其中n是构成分组序号的比特数量。</p><ul><li>若WT = 2，则<strong>与停止-等待协议相同</strong>。</li><li>若WT &gt; 2^(n-1)，则会导致接收方<strong>无法辨析新旧数据分组</strong>的问题。</li></ul><p>接收方的接收窗口尺寸WR必须满足<strong>1 &lt; WR &lt;= WT</strong>。</p><ul><li>若WR = 1，则<strong>回退N帧协议相同</strong>。</li><li>若WR &gt; WT，则<strong>没有意义</strong>。</li></ul><h5 id="发送窗口尺寸过大">发送窗口尺寸过大</h5><ul><li>本例采用3个比特给分组编号，即序号0-7</li><li>发送窗口的尺寸WT的取值为：1 &lt;= WT &lt;= 2^(3 - 1)，本例取5</li><li>接收窗口的尺寸WR一般情况下和发送窗口尺寸WT相同，本例取5</li></ul><ol><li>发送发将<strong>落在发送窗口内</strong>的0-4号数据分组，依次连续发送出去</li><li>接收方接收0-4号数据分组，并发送0-4号确认分组。接收窗口向前滑动5个位置。这样就有5-6-7-0-1这5个新的信号落入接收窗口。</li><li>确认分组经过互联网的传输，陆续到达发送方，但其中<strong>0号确认分组丢失</strong>。</li><li>发送方按序接收确认分组，并记录1-4号数据分组已收到确认，<strong>发送窗口不能向前移动</strong>。</li><li>发送方针对0号数据分组的<strong>重传计时器超时</strong>，发送方重新发送0号数据分组。</li><li>0号确认分组经过互联网的传输到达发送方，其序号0落在窗口内，接收方接收。但<strong>接收方先前已经正确接收过该数据分组</strong>，现在再次接收，<strong>接收方无法辨析新旧分组</strong>，会导致出现<strong>重复传输</strong>的传输差错。</li></ol><h4 id="选择重传协议小结">选择重传协议小结</h4><p><a href="https://imgtu.com/i/bM73UP"><img src="https://s4.ax1x.com/2022/03/01/bM73UP.png" alt="bM73UP.png"></a></p><h1>点对点协议PPP（Point-to-Point Protocol）</h1><p>PPP协议为在点对点链路传输各种协议数据提供了一个标准方法，主要由以下三部分构成：</p><ul><li>对各种协议数据报的封装方法（封装成帧）</li><li>链路控制协议LCP：用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs：其中的每一个协议支持不同的网络层协议</li></ul><h2 id="帧格式">帧格式</h2><p><a href="https://imgtu.com/i/bllc8A"><img src="https://s4.ax1x.com/2022/03/01/bllc8A.md.png" alt="bllc8A.md.png"></a></p><ul><li>标志（<strong>F</strong>lag）字段：PPP帧的定界符，取值为0x7E</li><li>地址（<strong>A</strong>ddress）字段：取值为0xFF，预留</li><li>控制（<strong>C</strong>ontrol）字段：取值为0x03，预留</li><li>协议（<strong>P</strong>rotocol）字段：指明帧的数据部分交送哪个协议处理<br><a href="https://imgtu.com/i/blQ1fA"><img src="https://s4.ax1x.com/2022/03/01/blQ1fA.md.png" alt="blQ1fA.md.png"></a></li><li>帧检查序列（<strong>F</strong>rame <strong>C</strong>heck <strong>S</strong>equence）：使用循环冗余校验CRC计算出的校验位，用于检查PPP帧是否存在误码</li></ul><p>其中预留的俩字段在创建之初都说以后有用，但是目前都没啥用（可能在韬光养晦 <s>（也有可能单纯地忘了</s></p><h2 id="透明传输-2">透明传输</h2><ul><li>面向字节的异步链路：使用字节填充法，插入转义字符</li><li>面向比特的同步链路：使用比特填充法，插入比特0</li></ul><p><a href="https://imgtu.com/i/bllYC9"><img src="https://s4.ax1x.com/2022/03/01/bllYC9.md.png" alt="bllYC9.md.png"></a></p><h3 id="字节填充法">字节填充法</h3><p><a href="https://imgtu.com/i/bl0kQS"><img src="https://s4.ax1x.com/2022/03/01/bl0kQS.md.png" alt="bl0kQS.md.png"></a></p><h4 id="发送方-2">发送方</h4><ul><li>出现的每一个<strong>7E</strong>（PPP的定界符）字节变成2字节序列（<strong>7D,5E</strong>）</li><li>出现的每一个<strong>7D</strong>（转义字符）字节变成2字节序列（<strong>7D,5D</strong>）</li><li>出现的每一个ASCII码控制字符（<strong>数值小于0x20的字符</strong>），则在该字符前面插入一个7D字节，同时将该字符的编码加上0x20</li></ul><h4 id="接收方">接收方</h4><p>进行<strong>反变换</strong>即可恢复出原来帧的数据部分</p><h3 id="比特填充法">比特填充法</h3><p><a href="https://imgtu.com/i/bl0x6U"><img src="https://s4.ax1x.com/2022/03/01/bl0x6U,md.png" alt="bl0x6U.md.png"></a></p><h4 id="发送方-3">发送方</h4><p>对帧的数据部分进行扫描（一般由硬件实现）。只要发现<strong>5个连续的比特1</strong>，则立即<strong>填充1个比特0</strong>。</p><h4 id="接收方-2">接收方</h4><p>对帧的数据部分进行扫描（一般由硬件实现）。只要发现<strong>5个连续的比特1</strong>，则<strong>把后面的1个比特0删除</strong>。</p><h2 id="差错检测-2">差错检测</h2><p>接收方每收到一个PPP帧，就进行CRC检验。若CRC检验正确，就收下这个帧，反之则丢弃。使用PPP的数据链路层<strong>向上不提供可靠传输服务</strong>。</p><h2 id="工作状态（以拨号接入为例）">工作状态（以拨号接入为例）</h2><ol><li>PPP的开始和结束状态都是“<strong>静止</strong>”状态，这时并不存在物理层的链接</li><li>当检测到调制解调器的载波信号，并建立物理层连接后，PPP就进入链路的“<strong>建立</strong>”状态</li><li>这时，链路控制协议LCP开始协商一些配置选项。若协商成功，则进入“<strong>鉴别</strong>”状态；若协商失败，则退回到“<strong>静止</strong>”状态。所协商的配置包括最大帧长、鉴别协议等。</li><li>可以不使用鉴别，也可以使用口令鉴别协议PAP，或挑战握手鉴别协议CHAP。若通信双方无需鉴别或鉴别身份成功，则进入“<strong>网络</strong>”状态；若鉴别失败，则进入“<strong>终止</strong>”状态。</li><li>进入“<strong>网络</strong>”状态后，进行NCP配置。配置完成后，进入“<strong>打开</strong>”状态。</li><li>PPP链路的两端通过互相交换网络层特定的NCP分组来进行NCP配置。如果链路上运行的是IP协议，则使用IP控制协议IPCP来对PPP链路的每一端配置IP模块（如配置IP地址</li><li>只要链路处于“<strong>打开</strong>”状态，就可以进行数据通信。当出现故障或链路的一端发出终止请求时，就进入“<strong>终止</strong>”状态。当载波停止后，则回到“<strong>静止状态</strong>”。</li></ol><p><a href="https://imgtu.com/i/b1fSUK"><img src="https://s4.ax1x.com/2022/03/01/b1fSUK.png" alt="b1fSUK.png"></a></p><h1>媒体接入控制MAC（Medium Access Control）</h1><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即<strong>媒体接入控制MAC</strong>。</p><p><a href="https://imgtu.com/i/b15rrj"><img src="https://s4.ax1x.com/2022/03/02/b15rrj.png" alt="b15rrj.png"></a></p><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路交换机的交换式局域网在有线领域已经完全取代了共享式局域网。但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</p><h2 id="静态划分信道">静态划分信道</h2><h3 id="信道复用">信道复用</h3><ul><li>复用：通过一条物理线路同时传输多条用户的信号</li></ul><p>当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用信道复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</p><p><a href="https://imgtu.com/i/bGKjIS"><img src="https://s4.ax1x.com/2022/03/02/bGKjIS.png" alt="bGKjIS.png"></a></p><h4 id="常见的信道复用技术：">常见的信道复用技术：</h4><h5 id="频分复用FDM">频分复用FDM</h5><p>将传输线路的频带资源划分成多个子频带，形成多个子信道。各子信道之间需要留出隔离频带，以免造成子信道之间的干扰。当多个信号输入一个多路复用器时，这个复用器将每一路信号调制到不同频率的载波上，接收端由相应的分用器通过滤波将各路信号分开，将合成的复用信号恢复成原始的多路信号。显然，<strong>频分复用的所有用户同时占用不同的频带资源并行通信</strong>。</p><p><a href="https://imgtu.com/i/bGQCfe"><img src="https://s4.ax1x.com/2022/03/02/bGQCfe.png" alt="bGQCfe.png"></a></p><h5 id="时分复用TDM">时分复用TDM</h5><p>将传输线路的带宽资源按时隙轮流分配给不同的用户，每对用户只在所分配的时隙里使用线路传输数据。时分复用技术将时间划分成了一段段等长的时分复用帧，每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙。显然，<strong>时分复用的所有用户在不同的时间占用同样的频带宽度</strong>。</p><p><a href="https://imgtu.com/i/bGQTBt"><img src="https://s4.ax1x.com/2022/03/02/bGQTBt.png" alt="bGQTBt.png"></a></p><h5 id="波分复用WDM">波分复用WDM</h5><p>波分复用其实就是光的频分复用。如图为8路传输速率均为2.5Gbit/s的光载波，其波长均为1310nm。经光调制后，分别将波长变换到1550-1561.2nm，每个光载波相隔1.6nm。这8个波长很接近的光载波，经过光复用器（合波器）在一根光纤中传输。因此，在一根光纤上数据传输的总速率就达到了8*2.5Gbit/s = 20Gbit/s。光信号传输一段距离后会衰减，因此对衰减了的光信号必须进行放大才能继续传输。</p><p><a href="https://imgtu.com/i/bGl5PU"><img src="https://s4.ax1x.com/2022/03/02/bGl5PU.png" alt="bGl5PU.png"></a></p><h5 id="码分复用CDM">码分复用CDM</h5><p>码分复用CDM是另一种共享信道的方法。实际上该技术主要用于多址接入，人们更常用的名词是码分多址CDMA（Code Division Multiple Access）。同理，频分复用FDM和时分复用TDM同样可以用于多址接入，相应的名词为频分多址FDMA（Frequency Division Multiple Access）和时分多址TDMA（Time Division Multiple Access）。</p><p>本课程中不严格区分复用与多址的概念，可以简单理解如下：</p><ul><li>复用是将单一媒体的频带资源划分成多个子信道，这些信道之间相互独立，互不干扰。从媒体的整体频带资源上开，每个子信道只占用该媒体频带资源的一部分。</li><li>多址（更确切地应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的（对于无线广播或电视广播站就是这样）。</li><li>从某种程度上看，FDMA、TDMA、CDMA可以看成是FDM、TDM、CDM的应用。</li></ul><p>与FDM和TDM不同，CDM的每一个用户可以<strong>在同样的时间使用同样的频带进行通信</strong>。由于<strong>各用户使用经过特殊挑选的不同码型</strong>，因此用户之间<strong>不会造成干扰</strong>。</p><p>在CDMA中，每一个比特时间再划分为m个短的间隔，称为<strong>码片</strong>（Chip）。通常m的取值为64或128。使用CDMA的每一个站被指派一个唯一的<strong>m bit码片序列</strong>（Chip Sequence）：</p><ul><li>一个站如果要<strong>发送比特0</strong>，则<strong>发送其自身的m bit码片序列</strong></li><li>一个站如果要<strong>发送比特1</strong>，则<strong>发送其自身的m bit码片序列的二进制反码</strong></li><li>为方便起见，习惯将码片序列中的0写为-1，1写为+1</li><li>这种通信方式称为直接序列扩频DSSS</li></ul><p>码片序列的挑选原则：</p><ol><li>分配给每个站的<strong>码片序列必须各不相同</strong>，实际常采用伪随机码序列</li><li>分配给每个站的<strong>码片序列必须正交</strong>（规格化内积为0）</li></ol><ul><li>令向量S表示站S的码片序列，令向量T表示其他任何站的码片序列</li><li>两个不同站S和T的码片序列正交，就是向量S和T的规格化内积为0</li><li>$S\cdot T\equiv0<s>S\cdot \bar{T}\equiv0</s>S\cdot S\equiv 1~~ S\cdot\bar{S}\equiv -1$</li></ul><p>CDMA应用举例：</p><p><a href="https://imgtu.com/i/bGt4mQ"><img src="https://s4.ax1x.com/2022/03/02/bGt4mQ.png" alt="bGt4mQ.png"></a></p><h2 id="随机接入">随机接入</h2><h3 id="CSMA-CD（Carrier-Sense-Multiple-Access-Collision-Detection）协议">CSMA/CD（Carrier Sense Multiple Access/Collision Detection）协议</h3><p>多址接入（Multiple Access）：</p><ul><li>多个站连接在一条总线上，竞争使用总线</li></ul><p>载波监听（Csrrier Sense）：</p><ul><li>每一个站在发送帧之前先要检测一下总线上是否有其他站点正在发送帧（“先听后说”）</li><li>若检测总线空闲96比特时间，则发送这个帧</li><li>若检测到总线忙，则继续检测并等待总线转为96比特时间，然后发送这个帧</li></ul><p>碰撞检测（Collision Detection）：</p><ul><li>每一个正在发送帧的站边发送边检测碰撞（“边说边听”）</li><li>一旦发送总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送（“一旦冲突，立即听说，等待时机，重新再说”）</li></ul><h4 id="举例说明">举例说明</h4><p>现对CSMA/CD举例说明。如下图，多址接入就是多个主机连接到一条总线上，各主机随机发送帧。</p><ol><li>主机C要发送帧，首先进行载波监听，检测到总线空闲96比特时间后，发送帧。</li><li>在主机C发送帧的过程中，主机B也要发送帧。主机B进行载波监听，发现总线忙，于是持续监听总线。一旦发现总线空闲96比特时间，则立即发送帧。</li><li>B边发送帧边检测碰撞，只要没检测到碰撞，则可继续发送帧的剩余部分。</li><li>主机B发送帧的过程中，主机C也要发送帧，主机C进行载波监听，发现总线空闲96比特时间后立即发送帧，产生碰撞。</li><li>在产生碰撞的时刻，主机B和C都在边发送边检测碰撞，但都检测不到碰撞。</li><li>碰撞信号沿总线传播，主机C比主机B更早检测到碰撞并停止发送，退避一段随机时间后，重新发送之前所发送的帧。当主机B检测到碰撞信号后，退避一段随机时间后，重新发送之前所发送的帧。</li></ol><p><a href="https://imgtu.com/i/bGdGnO"><img src="https://s4.ax1x.com/2022/03/02/bGdGnO.png" alt="bGdGnO.png"></a></p><h4 id="争用期">争用期</h4><p><a href="https://imgtu.com/i/bG0wOf"><img src="https://s4.ax1x.com/2022/03/02/bG0wOf.png" alt="bG0wOf.png"></a></p><ul><li>主机最多经过$2\tau$（即$\delta\rightarrow 0$）的时长就可检测到本次发送是否遭受碰撞</li><li>因此，以太网的端到端往返传播时延$2\tau$称为<strong>争用期</strong>或<strong>碰撞窗口</strong></li><li>经过争用期这段时间还没检测到碰撞，才能肯定这次发送不会发生碰撞</li><li>每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间。</li><li>显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大。因此，<strong>共享式以太网不能连接太多的主机，使用的总线也不能太长</strong>。</li><li>10Mb/s以太网把争用期定为512比特发送时间，即51.2μs，因此其总线长度不能超过5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过2500m。</li></ul><h4 id="最小帧长">最小帧长</h4><p>最小帧长 = 争用期 * 数据传输速率</p><p><a href="https://imgtu.com/i/bGDsRs"><img src="https://s4.ax1x.com/2022/03/02/bGDsRs.png" alt="bGDsRs.png"></a></p><ul><li><strong>以太网规定最小帧长为64字节</strong>，即512比特（512比特时间即为争用期）</li><li>如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节</li><li>以太网的<strong>最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞</strong></li><li>如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此<strong>凡长度小于64字节的帧都是由于碰撞而异常终止的无效帧</strong></li></ul><h4 id="最大帧长">最大帧长</h4><p><a href="https://imgtu.com/i/bGyNs1"><img src="https://s4.ax1x.com/2022/03/02/bGyNs1.png" alt="bGyNs1.png"></a></p><p><s>（我的帧很大，你要忍一下</s></p><h4 id="截断二进制指数退避算法">截断二进制指数退避算法</h4><p><a href="https://imgtu.com/i/bG6ETK"><img src="https://s4.ax1x.com/2022/03/02/bG6ETK.png" alt="bG6ETK.png"></a></p><ul><li>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可以<strong>使重传需要推迟的平均时间随重传次数而增大</strong>（也称为<strong>动态退避</strong>），因而<strong>减小发生碰撞的概率</strong>，有利于整个系统的稳定。</li><li><strong>当重传16次仍不能成功时</strong>，表明同时打算发送帧的主机太多，以至于连续发生碰撞，则<strong>丢弃该帧</strong>，并向高层报告。</li></ul><h4 id="信道利用率-2">信道利用率</h4><p><a href="https://imgtu.com/i/bGcpAf"><img src="https://s4.ax1x.com/2022/03/02/bGcpAf.png" alt="bGcpAf.png"></a></p><h4 id="帧发送流程">帧发送流程</h4><p><a href="https://imgtu.com/i/bGc08e"><img src="https://s4.ax1x.com/2022/03/02/bGc08e.png" alt="bGc08e.png"></a></p><h4 id="帧接收流程">帧接收流程</h4><p><a href="https://imgtu.com/i/bGcL5T"><img src="https://s4.ax1x.com/2022/03/02/bGcL5T.png" alt="bGcL5T.png"></a></p><h3 id="CSMA-CA（Carrier-Sense-Multiple-Access-Collision-Avoidance）协议">CSMA/CA（Carrier Sense Multiple Access / Collision Avoidance）协议</h3><ul><li><p><strong>在无线局域网中，仍然可以使用载波监听多址接入CSMA</strong>，即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。</p></li><li><p><strong>在无线局域网中，不能用碰撞检测CD</strong>，原因如下：</p><ul><li>由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。<strong>如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高</strong>。</li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传输的特殊性（<strong>存在隐蔽站问题</strong>），进行碰撞检测的意义也不大。</li><li><a href="https://imgtu.com/i/qCypMd"><img src="https://s1.ax1x.com/2022/03/17/qCypMd.png" alt="qCypMd.png"></a></li></ul></li><li><p><strong>802.11无线局域网</strong>使用CSMA/CA协议，在CSMA的基础上增加了一个<strong>碰撞避免CA功能</strong>，而不再实现碰撞检测功能。</p></li><li><p>由于<strong>不可能避免所有的碰撞</strong>，并且<strong>无线信道误码率较高</strong>，802.11标准还使用了**数据链路层确认机制（停止-等待协议）**来保证数据被正确接收。</p></li><li><p>802.11的MAC层标准定义了两种不同的媒体接入控制方式：</p><ul><li><strong>分布式协调功能DCF</strong>（Distributed Coordination Function）。在DCF方式下，没有中心控制站点，每个站点使用CSMA／CA协议通过争用信道来获取发送权，这是802.11定义的默认方式。</li><li><strong>点协调功能PCF</strong>（Point Coordination Function）。PCF方式使用集中控制的接入算法（一般在接入点AP实现集中控制），是802.11定义的可选方式，在实际中较少使用。</li></ul></li></ul><h4 id="帧间间隔IFS（InterFrame-Space）">帧间间隔IFS（InterFrame Space）</h4><p>802.11标准规定，所有的<strong>站点必须在持续检测到信道空闲一段指定时间后才能发送帧</strong>，这段时间称为帧间间隔IFS</p><ul><li><p>帧间间隔的长短取决于该站点要发送的帧的类型</p><ul><li>高优先级帧需要等待的时间较短，因此可优先获得发送权；</li><li>低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li></ul></li><li><p>常用的两种帧间间隔如下：</p><ul><li><strong>短帧间间隔SIFS</strong>（28μs），是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。</li><li><strong>DCF帧间间隔DIFS</strong>（128μs），它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧。</li></ul></li></ul><h4 id="工作原理-2">工作原理</h4><p><a href="https://imgtu.com/i/qCWj0J"><img src="https://s1.ax1x.com/2022/03/17/qCWj0J.png" alt="qCWj0J.png"></a></p><p>Q1：源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</p><p>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。</p><p>Q2：目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</p><p>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。</p><p>Q3：信道由忙转为空闲且经过DIFS时间后，为什么还要退避一段随机时间才能使用信道？</p><p>防止多个站点同时发送数据而产生碰撞。</p><ul><li><p>当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法。</p></li><li><p>以下情况必须使用退避算法：</p><ul><li>在发送数据帧之前检测到信道处于忙状态时；在每一次重传一个数据帧时；</li><li>在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）。</li></ul></li></ul><h4 id="退避算法">退避算法</h4><ul><li><p>在执行退避算法时，站点为退避计时器设置一个随机的退避时间</p><ul><li>当退避计时器的时间减小到零时，就开始发送数据；</li><li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。</li></ul></li><li><p>在进行第i次退避时，退避时间在时隙编号$(0, 1, …, 2^{2+i}-1)$中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避）就不再增加了。</p></li></ul><p><a href="https://imgtu.com/i/qCIIzt"><img src="https://s1.ax1x.com/2022/03/17/qCIIzt.png" alt="qCIIzt.png"></a></p><h4 id="信道预约">信道预约</h4><ul><li><p>为了<strong>尽可能减少碰撞的概率</strong>和降低碰撞的影响，802.11标准允许要发送数据的站点<strong>对信道进行预约</strong>。</p><ol><li>源站在发送数据帧之前先发送一个短的控制帧，称为<strong>请求发送RTS</strong>（Recuest To Send），它包括源地址，目的地址及这次通信（包括相应的确认帧）所需的持续时间。</li><li>若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为<strong>允许发送CTS</strong>（Ciear To Send），它也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS帧中）。</li><li>源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。</li></ol></li><li><p>除源站和目的站以外的<strong>其他各站</strong>，在<strong>收到CTS帧（或数据帧）后就推迟接入到无线局域网中</strong>。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</p></li><li><p>如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧。</p></li><li><p>由于<strong>RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小</strong>。而对于一般的数据帧，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时 间就很多，因此<strong>用很小的代价对信道进行预约往往是值得的</strong>。802.11标准规定了3种情况供用户选择：</p><ul><li>使用RTS帧和CTS帧 不使用RTS帧和CTS帧</li><li>只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧</li></ul></li></ul><p><a href="https://imgtu.com/i/qCbN4g"><img src="https://s1.ax1x.com/2022/03/17/qCbN4g.png" alt="qCbN4g.png"></a></p><h4 id="虚拟载波监听">虚拟载波监听</h4><ul><li><p>除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的<strong>虚拟载波监听</strong>机制。</p></li><li><p>由于利用虚拟载波监听机制，<strong>站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间</strong>，而不需要真正监听到信道上的信号，因此<strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题</strong>。</p></li></ul><p><a href="https://imgtu.com/i/qCqKaT"><img src="https://s1.ax1x.com/2022/03/17/qCqKaT.png" alt="qCqKaT.png"></a></p><h1>MAC地址</h1><ul><li><p>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址；</p></li><li><p>在每个主机发送的<strong>帧中必须携带标识发送主机和接收主机的地址</strong>。由于这类地址是用于媒体接入控制MAC（Media Access Control），因此这类地址被称为<strong>MAC地址</strong>；</p><ul><li><p>MAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为<strong>硬件地址</strong>；</p></li><li><p>MAC地址有时也被称为<strong>物理地址</strong>。<strong>请注意：这并不意味着MAC地址属于网络体系结构中的物理层！</strong></p></li></ul></li><li><p>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，<strong>严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识</strong>。</p></li></ul><p><a href="https://imgtu.com/i/qPkGS1"><img src="https://s1.ax1x.com/2022/03/17/qPkGS1.png" alt="qPkGS1.png"></a></p><h2 id="IEEE-802局域网的MAC地址">IEEE 802局域网的MAC地址</h2><h3 id="MAC地址格式">MAC地址格式</h3><p><a href="https://imgtu.com/i/qPkcOf"><img src="https://s1.ax1x.com/2022/03/17/qPkcOf.png" alt="qPkcOf.png"></a></p><p><a href="https://imgtu.com/i/qPAg3R"><img src="https://s1.ax1x.com/2022/03/17/qPAg3R.png" alt="qPAg3R.png"></a></p><h3 id="地址发送顺序">地址发送顺序</h3><ul><li><p>字节发送顺序：第一字节 -&gt; 第六字节</p></li><li><p>字节内的比特发送顺序：b0 -&gt; b7</p></li></ul><h3 id="单播MAC地址">单播MAC地址</h3><p><a href="https://imgtu.com/i/qPEfRs"><img src="https://s1.ax1x.com/2022/03/17/qPEfRs.png" alt="qPEfRs.png"></a></p><h3 id="广播MAC地址">广播MAC地址</h3><p><a href="https://imgtu.com/i/qPVZQI"><img src="https://s1.ax1x.com/2022/03/17/qPVZQI.png" alt="qPVZQI.png"></a></p><h3 id="多播MAC地址">多播MAC地址</h3><p><a href="https://imgtu.com/i/qPmqn1"><img src="https://s1.ax1x.com/2022/03/17/qPmqn1.png" alt="qPmqn1.png"></a></p><p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p><h1>IP地址（网络层范畴）</h1><ul><li><p>IP地址是因特网（Internet）上的主机和路由器所使用的地址，用于标识两部分信息：</p><ul><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ul></li><li><p>很显然，之前介绍的MAC地址不具备区分不同网络的功能。</p><ul><li>如果只是一个单独的网络，不接入因特网，可以只使用MAC地址（这不是一般用户的应用方式）。</li><li>如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用。</li></ul></li></ul><h2 id="从网络体系结构看IP地址与MAC地址">从网络体系结构看IP地址与MAC地址</h2><p><a href="https://imgtu.com/i/qPK1YT"><img src="https://s1.ax1x.com/2022/03/17/qPK1YT.png" alt="qPK1YT.png"></a></p><h2 id="数据包转发过程中IP地址与MAC地址的变化情况">数据包转发过程中IP地址与MAC地址的变化情况</h2><p><a href="https://imgtu.com/i/qPKxhT"><img src="https://s1.ax1x.com/2022/03/17/qPKxhT.png" alt="qPKxhT.png"></a></p><ul><li><p>数据包转发过程中<strong>源IP地址和目的IP地址保持不变</strong></p></li><li><p>数据包转发过程中<strong>源MAC地址和目的MAC地址逐个链路（或逐个网络）改变</strong></p></li></ul><p><a href="https://imgtu.com/i/qPMcCT"><img src="https://s1.ax1x.com/2022/03/17/qPMcCT.png" alt="qPMcCT.png"></a></p><p>（先暂时这么认为吧，详细的会在以后有介绍的</p><p>（这里有一个问题，只知道IP地址不知道MAC地址可咋整，下一个协议会解决的</p><h1>ARP协议</h1><p><s>（就是表白墙捞人</s></p><p><a href="https://imgtu.com/i/qP1lDJ"><img src="https://s1.ax1x.com/2022/03/17/qP1lDJ.png" alt="qP1lDJ.png"></a></p><p><a href="https://imgtu.com/i/qP1vqJ"><img src="https://s1.ax1x.com/2022/03/17/qP1vqJ.png" alt="qP1vqJ.png"></a></p><p>总的来说就是B要给C发消息，但是只知道C的IP地址，不知道C的MAC地址。于是在自己的<s>通讯录</s>ARP高速缓存里面找找自己有没有C的IP地址对应的MAC地址，没有的话就<s>上表白墙捞人</s>发送ARP请求报文，请求得到C的MAC地址。所有<s>看到表白墙</s>收到请求报文的主机如果发现不是自己就拉到了，发现<s>自己居然上表白墙了</s>是自己的话就发送自己的MAC地址给请求的主机B<s>正经人发现自己上表白墙也不会全世界发自己的联系方式吧</s>。主机B收到C的MAC地址后，就可以发送消息给C啦。</p><p><a href="https://imgtu.com/i/qP33QS"><img src="https://s1.ax1x.com/2022/03/17/qP33QS.png" alt="qP33QS.png"></a></p><p>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用。对于下图，ARP协议的使用是逐段链路进行的。</p><p><a href="https://imgtu.com/i/qP8LB4"><img src="https://s1.ax1x.com/2022/03/17/qP8LB4.png" alt="qP8LB4.png"></a></p><p><s>也就是你不能在南开幼儿园的校园墙捞南开幼儿园附属大学的人</s></p><h1>MAC地址、IP地址、ARP协议小结</h1><p><a href="https://imgtu.com/i/qPGsa9"><img src="https://s1.ax1x.com/2022/03/17/qPGsa9.png" alt="qPGsa9.png"></a></p><h1>集线器与交换机的区别</h1><h2 id="使用双绞线和集线器HUB的星型以太网">使用双绞线和集线器HUB的星型以太网</h2><ul><li><p><strong>使用集线器的以太网在逻辑上仍是一个总线网</strong>，各站共享总线资源，<strong>使用的还是CSMA／CD协议</strong>；</p></li><li><p><strong>集线器只工作在物理层</strong>，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）；</p></li><li><p><strong>集线器一般都有少量的容错能力和网络管理功能</strong>。例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。</p></li></ul><p><a href="https://imgtu.com/i/qPYhAH"><img src="https://s1.ax1x.com/2022/03/17/qPYhAH.png" alt="qPYhAH.png"></a></p><h2 id="使用集线器HUB在物理层扩展以太网">使用集线器HUB在物理层扩展以太网</h2><p><a href="https://imgtu.com/i/qPtmCR"><img src="https://s1.ax1x.com/2022/03/17/qPtmCR.png" alt="qPtmCR.png"></a></p><p><a href="https://imgtu.com/i/qPttPA"><img src="https://s1.ax1x.com/2022/03/17/qPttPA.png" alt="qPttPA.png"></a></p><h2 id="以太网交换机">以太网交换机</h2><p><a href="https://imgtu.com/i/qPakb8"><img src="https://s1.ax1x.com/2022/03/17/qPakb8.png" alt="qPakb8.png"></a></p><ul><li><p>以太网交换机通常都有<strong>多个接口</strong>。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在<strong>全双工方式</strong>。（使用集线器的以太网在逻辑上是<strong>共享总线</strong>的，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在<strong>半双工模式</strong>）</p></li><li><p>以太网交换机具有并行性，能<strong>同时连通多对接口</strong>，使多对主机能同时通信，<strong>无碰撞</strong>（<strong>不使用CSMA/CD协议</strong>）。</p></li><li><p>以太网交换机一般都具有多种速率的接口，例如：10Mb／s、100Mb／s、1Gb／s、10Gb／s接口的多种组合。</p></li><li><p>以太网交换机<strong>工作在数据链路层</strong>（也包括物理层），它收到帧后，在帧交换表中查找<strong>帧的目的MAC地址所对应的接口号</strong>，然后通过该接口转发帧。</p></li><li><p>以太网交换机是一种即插即用设备，其内部的<strong>帧交换表</strong>是通过<strong>自学习算法</strong>自动地逐渐建立起来的。</p></li><li><p>帧的两种转发方式：</p><ul><li>1．<strong>存储转发</strong></li><li>2．<strong>直通交换</strong>：采用基于硬件的交叉矩阵（交换时延非常小，但不检查帧是否右差错）</li></ul></li></ul><h2 id="对比集线器和交换机">对比集线器和交换机</h2><p><a href="https://imgtu.com/i/qPRb7j"><img src="https://s1.ax1x.com/2022/03/17/qPRb7j.png" alt="qPRb7j.png"></a></p><table style="white-space:normal; word-break:break-all;"><tr><td style="white-space:normal; word-break:break-all;" width="300">集线器HUB</td><td style="white-space:normal; word-break:break-all;" width="300">交换机SWITCH</td></tr><tr><td style="white-space:normal; word-break:break-all;" width="300"><ul><li>早期以太网的互连设备</li><li>工作在OSI体系结构的物理层</li><li>对接收到的信号进行放大、转发</li><li>使用集线器作为互连设备的以太网仍然属于共享总线式以太网。集线器互连起来的所有主机共享总线带宽，属于同一个碰撞域和广播域。</li></ul></td><td style="white-space:normal; word-break:break-all;" width="300"><ul><li>目前以太网中使用最广泛的互连设备</li><li>工作在OSI体系结构的数据链路层（也包括物理层）</li><li>根据MAC地址对帧进行转发</li><li>使用交换机作为互连设备的以太网，称为交换式以太网。交换机可以根据MAC地址过滤帧，即隔离碰撞域。</li><li>交换机的每个接口是一个独立的碰撞域</li><li style="white-space:normal; word-break:break-all;" width="300">交换机隔离碰撞域但不隔离广播域（VLAN除外）</li></ul></td></tr></table><h1>以太网交换机自学习和转发帧的流程</h1><ul><li><p>以太网交换机工作在<strong>数据链路层</strong>（也包括物理层）</p></li><li><p>以太网交换机收到帧后，在帧交换表中查找<strong>帧的目的MAC地址所对应的接口号</strong>，然后通过该接口转发帧。</p></li><li><p>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机<strong>通过自学习算法</strong>自动逐渐<strong>建立起帧交换表</strong>。</p></li></ul><h2 id="流程举例">流程举例</h2><p>如图所示，相互连接的两台以太网交换机各自连接了三台主机，构成了一个交换式以太网。为了简单起见，各主机中网卡上固化的MAC地址仅用一个大写字母表示，各主机互不相同。假设各主机知道网络中其他各主机的MAC地址（无需ARP）。</p><p><a href="https://imgtu.com/i/qiqWFK"><img src="https://s1.ax1x.com/2022/03/18/qiqWFK.png" alt="qiqWFK.png"></a></p><p>假设主机A给主机B发送帧，该帧从交换机1的接口1进入交换机1。交换机1首先进行登记的工作，将该帧的源MAC地址A记录到自己的帧交换表中，将该帧进入自己的接口的接口号1相应地也记录到帧交换表中。上述登记工作就称为交换机的<strong>自学习</strong>。</p><p>之后交换机1对该帧进行转发，该帧的目的MAC地址是B，在帧交换表中查找MAC地址B。找不到，于是对该帧进行<strong>盲目转发</strong>，也称为<strong>泛洪</strong>。也就是从除该帧进入交换机接口外的所有接口转发该帧。可以看出，交换机开始时还没有足够的知识来明确转发帧，只能进行盲目地转发。</p><p>主机B的网卡收到该帧后，根据帧的目的MAC地址B，就知道这是发送给自己的帧，于是就接受该帧。主机C的网卡收到该帧后，根据帧的目的MAC地址B，就知道这不是发送给自己的帧，于是就丢弃该帧。</p><p>该帧从交换机的接口2进入交换机2，交换机2首先进行登记的工作，将该帧的源MAC地址A记录到自己的帧交换表中。将该帧进入自己的接口的接口号2相应地也记录到帧交换表中。之后交换机2对该帧进行转发，该帧的目的MAC地址是B，在帧交换表中查找MAC地址B，找不到，于是对该帧进行盲目转发。主机DEF都会收到该帧，根据帧的目的MAC地址B，就知道这不是发送给自己的帧，于是丢弃该帧。</p><p><a href="https://imgtu.com/i/qiqqTP"><img src="https://s1.ax1x.com/2022/03/18/qiqqTP.png" alt="qiqqTP.png"></a></p><p>接下来，主机B给主机A发送帧，该帧从交换机1的接口3进入交换机1.交换机1首先进行登记的工作，将该帧的源MAC地址B记录到自己的帧交换表中，将该帧进入自己的接口的接口号3相应地也记录到帧交换表中。之后，交换机1对该帧进行转发，该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到，于是按照MAC地址A所对应的接口号1从接口1转发该帧，这是明确的转发。</p><p>主机A的网卡收到该帧后，根据帧的目的MAC地址A，就知道这是发送给自己的帧，于是接受该帧。很显然，交换机2不会收到该帧。</p><p><a href="https://imgtu.com/i/qiLM01"><img src="https://s1.ax1x.com/2022/03/18/qiLM01.png" alt="qiLM01.png"></a></p><p>接下来，主机E给主机A发送帧，该帧从交换机2的接口3进入交换机2。交换机2首先进行登记的工作。之后，交换机2对该帧进行转发，该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到。于是按照MAC地址A所对应的接口号2从接口2转发该帧，这是明确的转发。</p><p>该帧从交换机1的接口4进入交换机1，交换机1首先进行登记的工作。之后，交换机1对该帧进行转发。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到，于是按照MAC地址A所对应的接口号1从接口1转发该帧，这是明确的转发。</p><p>主机A的网卡收到该帧后，根据帧的目的MAC地址A就知道这是发送给自己的帧，于是接受该帧。</p><p><a href="https://imgtu.com/i/qiOVEt"><img src="https://s1.ax1x.com/2022/03/18/qiOVEt.png" alt="qiOVEt.png"></a></p><p>为演示丢弃帧的情况，给交换机1的接口1再连接一台主机G。为简单起见，没有画出集线器。这样，主机A、主机G、交换机1的接口1就共享同一条总线。</p><p><a href="https://imgtu.com/i/qiOoVI"><img src="https://s1.ax1x.com/2022/03/18/qiOoVI.png" alt="qiOoVI.png"></a></p><p>假设主机G给主机A发送帧，该帧通过总线进行传输，主机A和交换机1的接口1都可以收到。主机A的网卡收到该帧后，根据帧的目的MAC地址A就知道这是发送给自己的帧，于是接受该帧。</p><p>交换机1收到该帧后，首先进行登记工作。之后，交换机1对该帧进行转发，该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到，MAC地址A所对应的接口号是1，但是该帧正是从接口1进入交换机1的，交换机1不会再从该接口将该帧转发出去，因为这是没有必要的，于是丢弃该帧。很显然，交换机2不会收到该帧。</p><p><a href="https://imgtu.com/i/qiXlRO"><img src="https://s1.ax1x.com/2022/03/18/qiXlRO.png" alt="qiXlRO.png"></a></p><p>随着网络中各主机都发送帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系。需要注意的是，因为MAC地址与交换机接口的对应关系并不是永久性的，所以帧交换表中的每条记录都有自己的有效时间，到期自动删除。</p><p><a href="https://imgtu.com/i/qije1S"><img src="https://s1.ax1x.com/2022/03/18/qije1S.png" alt="qije1S.png"></a></p><p>例如交换机某接口所连接的主机更换成了另一台主机，又或者主机中的网卡坏了，更换了新的网卡。这些情况都会导致MAC地址与交换机对应接口关系的改变。（ARP高速缓存表类似</p><h2 id="流程小结">流程小结</h2><ul><li><p>以太网交换机自学习和转发帧的流程：</p><ol><li>收到帧后进行<strong>登记</strong>。登记的内容为帧的<strong>源MAC地址</strong>及进入交换机的<strong>接口号</strong></li><li>根据帧的<strong>目的MAC地址</strong>和交换机的<strong>帧交换表</strong>对帧进行<strong>转发</strong>，有以下三种情况：<ul><li><strong>明确转发</strong>：交换机知道应当从哪个（或哪些）接口转发该帧（单播，多播，广播）</li><li><strong>盲目转发</strong>：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）。</li><li><strong>明确丢弃</strong>：交换机知道不应该转发该帧，将其丢弃。</li></ul></li></ol></li><li><p>帧交换表中的每条记录都有自己的<strong>有效时间</strong>，到期删除。原因如下：</p><ul><li>交换机的接口改接了另一台主机；</li><li>主机更换了网卡。</li></ul></li></ul><h1>以太网交换机的生成树协议STP</h1><p>添加<strong>冗余链路</strong>可以提高以太网的可靠性，但是会带来<strong>网络环路</strong>的问题，会带来以下问题：</p><ul><li><strong>广播风暴</strong>：大量消耗网络资源，使得网络无法正常转发其他数据帧</li><li><strong>主机收到重复的广播帧</strong>：大量消耗主机资源</li><li><strong>交换机的帧交换表震荡（漂移）</strong></li></ul><p>以太网交换机使用<strong>生成树协议STP</strong>（Spanning Tree Protocol），可以在增加冗余链路来提高网络可靠性的同时又<strong>避免网络环路带来的各种问题</strong>。</p><ul><li>不论交换机之间采用怎样的物理连接，交换机都能够<strong>自动计算并构建一个逻辑上没有环路的网络</strong>，其逻辑拓扑结构必须是树型的（无逻辑环路）；</li><li>最终生成的树型逻辑拓扑要<strong>确保连通整个网络</strong>；</li><li>当首次连接交换机或网络<strong>物理拓扑发生变化</strong>时（有可能是人为改变或故障），交换机都将进行<strong>生成树的重新计算</strong>。</li></ul><h1>虚拟局域网VLAN（Virtual Local Area Network）</h1><ul><li><p>以太网交换机工作在<strong>数据链路层</strong>（也包括物理层）</p></li><li><p>使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于<strong>同一个广播域</strong>。随着交换式以太网规模的扩大，广播域相应扩大。</p></li><li><p>巨大的广播域会带来很多弊端：</p><ul><li><strong>广播风暴</strong></li><li>难以管理和维护</li><li>潜在的安全问题</li></ul></li><li><p><strong>网络中会频繁出现广播信息</strong>（TCP/IP协议栈中很多协议都会使用广播，例如ARP、RIP、DHCP等）</p></li><li><p>分割广播域的方法：使用路由器可以隔离广播域，但路由器成本较高，<strong>虚拟局域网VLAN技术应运而生</strong>。</p></li><li><p>虚拟局域网VLAN（Virtual Local Area Network）是一种将局域网内的<strong>设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</strong>。</p></li></ul><p>对于下图，网络中的各主机使用同一个广播域，某个主机发送的广播数据包，其他主机都可以收到</p><p><a href="https://imgtu.com/i/qFPwYd"><img src="https://s1.ax1x.com/2022/03/18/qFPwYd.md.png" alt="qFPwYd.png"></a></p><p>如果把主机划分成两个VLAN，则VLAN1中的广播数据包不会传送到VLAN2，VLAN2中的广播数据包不会传送到VLAN1。也就是说，同一个VLAN内部可以广播通信，不同VLAN之间不能广播通信。</p><p><a href="https://imgtu.com/i/qFCLRI"><img src="https://s1.ax1x.com/2022/03/18/qFCLRI.md.png" alt="qFCLRI.png"></a></p><h2 id="实现机制">实现机制</h2><h3 id="IEEE-802-1Q帧">IEEE 802.1Q帧</h3><ul><li>IEEE 802.1Q帧（也称Dot One Q帧）对以太网的MAC帧格式进行了扩展，插入了<strong>4字节的VLAN标记</strong>。</li></ul><p><a href="https://imgtu.com/i/qFFydS"><img src="https://s1.ax1x.com/2022/03/18/qFFydS.md.png" alt="qFFydS.md.png"></a></p><ul><li><p>VLAN标记的<strong>最后12比特</strong>称为<strong>VLAN标识符VID</strong>，它唯一地标志了以太网帧属于哪一个VLAN。</p><ul><li>VID的取值范围是0～4095 $(0,2^{12}—1)$</li><li>0和4095都不用来表示VLAN，因此用于表示VLAN的<strong>VID的有效取值范围是1~4094</strong>。</li></ul></li><li><p><strong>802.1Q帧是由交换机来处理的，而不是用户主机来处理的。</strong></p><ul><li>当交换机收到<strong>普通的以太网帧</strong>时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称“<strong>打标签</strong>”。</li><li>当交换机<strong>转发802.1Q帧</strong>时，<strong>可能</strong>会删除其4字节VLAN标记转变为普通以太网帧，简称“<strong>去标签</strong>”。</li></ul></li></ul><h3 id="交换机的端口类型">交换机的端口类型</h3><ul><li><p>交换机的端口类型有以下三种：</p><ul><li>Access</li><li>Trunk</li><li>Hybrid（思科交换机没有，华为交换机私有</li></ul></li><li><p>交换机各端口的缺省VLAN ID</p><ul><li>在思科交换机上称为Native VLAN，即本征VLAN。</li><li>在华为交换机上称为Port VLAN ID，即端口VLAN ID，简记为PVID。（为描述方便，后续都用PVID而不是本征VLAN</li></ul></li></ul><h4 id="Access端口">Access端口</h4><ul><li>Access端口一般用于连接用户计算机</li><li>Access端口只能属于一个VLAN</li><li>Access端口的PVID值与端口所属VLAN的ID相同（默认为1）</li><li>Access端口接收处理方法：<br>一般只接受“未打标签”的普通以太网MAC帧。根据接收帧的端口的PVID给帧“<strong>打标签</strong>”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>Access端口发送处理方法：<br>若帧中的VID与端口的PVID相等，则“<strong>去标签</strong>”并<strong>转发</strong>该帧；否则不转发。</li></ul><p><a href="https://imgtu.com/i/qFEhQA"><img src="https://s1.ax1x.com/2022/03/18/qFEhQA.md.png" alt="qFEhQA.png"></a></p><p><a href="https://imgtu.com/i/qFmZOs"><img src="https://s1.ax1x.com/2022/03/18/qFmZOs.md.png" alt="qFmZOs.png"></a></p><h4 id="Trunk端口">Trunk端口</h4><ul><li>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</li><li>Trunk端口可以属于多个VLAN</li><li>用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1。</li><li>Trunk端口发送处理方法：<ul><li>对VID等于PVID的帧，“<strong>去标签</strong>”再转发；</li><li>对VID不等于PVID的帧，<strong>直接转发</strong>；</li></ul></li><li>Trunk端口接收处理方法：<ul><li>接收“未打标签”的帧，根据接收帧的端口的PVID给帧“<strong>打标签</strong>”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>接收“已打标签的帧”；</li></ul></li></ul><p><a href="https://imgtu.com/i/qFnkAx"><img src="https://s1.ax1x.com/2022/03/18/qFnkAx.md.png" alt="qFnkAx.png"></a></p><p><a href="https://imgtu.com/i/qFnauj"><img src="https://s1.ax1x.com/2022/03/18/qFnauj.md.png" alt="qFnauj.png"></a></p><h4 id="Hybrid端口">Hybrid端口</h4><ul><li>Hybrid端口既可用于交换机之间或交换机与路由器之间的互连（同Trunk端口），也可用于交换机与用户计算机之间的互连（同Access端口）</li><li>Hybrid端口可以属于多个VLAN（同Trunk端口）</li><li>用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1（同Trun端口）</li><li>Hybrid端口发送处理方法（<strong>与Trunk端口不同</strong>）查看帧的VID是否在端口的“去标签”列表中：<ul><li>若存在，则“去标签”后再转发；</li><li>若不存在，则直接转发；</li></ul></li><li>Hybrid端口接收处理方法（同Trunk端口）<ul><li>接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>接收“已打标签的帧”：</li></ul></li></ul><p>【应用举例】主机A、B、C连接在同一个交换机的不同接口上。利用Hybrid端口的功能，实现以下应用需求：A和B都能与C相互通信，但A与B不能相互通信。</p><p><a href="https://imgtu.com/i/qFK0hV"><img src="https://s1.ax1x.com/2022/03/18/qFK0hV.md.png" alt="qFK0hV.png"></a></p><p><a href="https://imgtu.com/i/qFKMkt"><img src="https://s1.ax1x.com/2022/03/18/qFKMkt.md.png" alt="qFKMkt.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据链路层 </tag>
            
            <tag> 可靠传输 </tag>
            
            <tag> 停止-等待协议 </tag>
            
            <tag> 回退N帧协议 </tag>
            
            <tag> 选择重传协议 </tag>
            
            <tag> 点对点协议 </tag>
            
            <tag> CSMA/CD </tag>
            
            <tag> CSMA/CA </tag>
            
            <tag> MAC地址 </tag>
            
            <tag> IP地址 </tag>
            
            <tag> ARP协议 </tag>
            
            <tag> 集线器 </tag>
            
            <tag> 交换机 </tag>
            
            <tag> 以太网 </tag>
            
            <tag> VLAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-物理层</title>
      <link href="/2022/02/27/computerInternet-2/"/>
      <url>/2022/02/27/computerInternet-2/</url>
      
        <content type="html"><![CDATA[<p>小黎学完第一章啦<br>继续向第二章前进（嘿哈嘿哈</p><span id="more"></span><h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>物理层就是要解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务。（透明是指数据链路层看不见也无需看见物理层究竟使用的是什么方法来传输比特0和1的，它只管享受物理层提供的服务即可）</p><h2 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h2><ul><li>机械特性：指明接口所用接线器的<strong>形状</strong>和<strong>尺寸</strong>、<strong>引脚数目</strong>和<strong>排列</strong>、<strong>固定</strong>和<strong>锁定</strong>装置。</li><li>电气特性：指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。</li><li>功能特性：指明某条线上出现的某一电平的<strong>电压表示何种意义</strong>。</li><li>过程特性：指明对于不同功能的各种可能<strong>事件的出现顺序</strong>。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</li></ul><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>（传输媒体不属于计算机网络结构的任何一层</p><h2 id="传输媒体分类"><a href="#传输媒体分类" class="headerlink" title="传输媒体分类"></a>传输媒体分类</h2><ul><li>导引型传输媒体（电磁波被导引沿着固体媒体传播）：双绞线、同轴电缆、光纤、电力线</li><li>非导引型传输媒体（自由空间）：无线电波、微波、红外线、可见光</li></ul><p>（没太听进去，主要讲硬件部分，想看详细的可以看老师的原视频</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=64605483&bvid=BV1c4411d7jb&cid=114529069&page=15" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p>在<strong>远距离传输（如计算机网络）中数据采用串行传输，计算机内部的传输常采用并行传输</strong>，例如CPU与内存之间通过总线进行传输，常见的总线宽度有8位、16位、32位和64位。</p><h3 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h3><p>数据是一个比特一个比特一次发送的，因此在发送端和接收端之间，只需要一条数据传输线路即可</p><h3 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h3><p>一次发送n个比特而不是一个比特，因此在发送端和接收端之间需要有n条传输线路。并行传输速度是串行传输的n倍，但成本高。</p><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><h3 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h3><p>数据块以比特流的形式传输，字节之间没有间隔，接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1。</p><p>由于不同设备的时钟频率不可能完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差会导致接收端对比特信号判别错位，因此需要收发双方时钟同步。</p><h4 id="收发双方时钟同步的方法"><a href="#收发双方时钟同步的方法" class="headerlink" title="收发双方时钟同步的方法"></a>收发双方时钟同步的方法</h4><ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如曼切斯特编码）</li></ul><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>以字节为独立的传输单位，字节之间的时间间隔不固定。接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节前后分别加上起始位和结束位。</p><p>异步指<strong>字节之间异步</strong>，即字节之间的时间间隔不固定。字节中的每个比特仍然要同步，即各比特的持续时间相同。</p><h2 id="单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）</h2><p><a href="https://imgtu.com/i/bG2q9U"><img src="https://s4.ax1x.com/2022/03/02/bG2q9U.png" alt="bG2q9U.png"></a></p><h3 id="单向通信"><a href="#单向通信" class="headerlink" title="单向通信"></a>单向通信</h3><p>通信双方只有一个数据传输方向，只需要一条信道</p><h3 id="半双工通信"><a href="#半双工通信" class="headerlink" title="半双工通信"></a>半双工通信</h3><p>通信双方可以相互传输数据，但不能同时进行。需要两条信道，每个方向各一条</p><h3 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h3><p>通信双方可以同时发送和接受信息。需要两条信道，每个方向各一条。</p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>编码：在不改变信号性质的前提下，仅对数字基带信号的波形进行变换。编码后产生的信号为数字信号，可以在数字信道中传输。</p><p>调制：把数字基带信号的频率范围搬移到较高的频段，并转换为模拟信号。调制后产生的信号是模拟信号，可以在模拟信道中传输。</p><p><a href="https://imgtu.com/i/bnW410"><img src="https://s4.ax1x.com/2022/02/27/bnW410.png" alt="bnW410.png"></a></p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>在使用时间域的波形表示数字信号时，<strong>代表不同离散数值的基本波形</strong>。简单来说，码元就是构成信号的一段波形。</p><p><a href="https://imgtu.com/i/bnfiAH"><img src="https://s4.ax1x.com/2022/02/27/bnfiAH.png" alt="bnfiAH.png"></a></p><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><ul><li>不归零编码：在整个码元时间内不会出现零电平。<br>（接收方判断码元数目需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按照时钟信号的节拍来逐个接受码元。然而对于计算机网络<strong>宁愿利用这根传输线来传输数据信号而不是时钟信号</strong>。所以由于这种同步问题，计算机网络中的数据传输不采用这类编码。</li><li>归零编码：<strong>每个码元传输结束后信号都要归零</strong>。<br>所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。实际上，归零编码相当于把时钟信号用“归零”方式编码在了数据之内，这称为<strong>自同步</strong>信号。但归零编码中大部分的<strong>数据带宽</strong>都用来传输归零而浪费掉了。</li><li>曼彻斯特编码：在每个码元的中间时刻信号都会发生跳变。<br>中间时刻的跳变既表示时钟，又表示数据。</li><li>差分曼切斯特编码：在每个码元的中间时刻信号都会发生跳变<br>跳变仅表示时钟，码元开始处电平是否发生变化表示数据</li></ul><p><a href="https://imgtu.com/i/bn48XV"><img src="https://s4.ax1x.com/2022/02/27/bn48XV.png" alt="bn48XV.png"></a></p><h2 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h2><ul><li>调幅（AM）：无载波输出表示比特0，有载波输出表示比特1</li><li>调频（FM）：频率f1的波形表示比特0，频率f2的波形表示比特1</li><li>调相（PM）：初相位0度的波形表示比特0，初相位180度表示比特1</li></ul><p><a href="https://imgtu.com/i/bn5V3R"><img src="https://s4.ax1x.com/2022/02/27/bn5V3R.png" alt="bn5V3R.png"></a></p><h2 id="混合调制举例：正交振幅调制QAM"><a href="#混合调制举例：正交振幅调制QAM" class="headerlink" title="混合调制举例：正交振幅调制QAM"></a>混合调制举例：正交振幅调制QAM</h2><p>很明显，使用基本调制方法1个码元只能包含1个比特信息，为了使一个码元包含更多信息可以采用混合调制的方法。</p><p>因为<strong>频率和相位是相关的</strong>，即频率是相位关于时间的变化率。所以<strong>一次只能调制频率和相位两个中的一个</strong>。通常情况下相位和振幅可以结合起来一起调制，称为<strong>正交振幅调制QAM</strong></p><h3 id="QAM-16"><a href="#QAM-16" class="headerlink" title="QAM-16"></a>QAM-16</h3><p>所调制出的波形可以有12种相位，每种相位有1或2种振幅可选，可调制出16种码元（波形），每种码元可以表示4个比特（log2(16)&#x3D;4）。</p><p><a href="https://imgtu.com/i/bnoPfJ"><img src="https://s4.ax1x.com/2022/02/27/bnoPfJ.md.png" alt="bnoPfJ.md.png"></a></p><p>每个码元表示的比特不可随便定义，应采用<strong>格雷码</strong>，使任意两个相邻码元只有一个比特位不同，可以减少传输失真导致的错位数目。例如下图原本都是表示比特0，由于传输过程中导致失真，并未都落在在星座图的理想位置。</p><p><a href="https://imgtu.com/i/bnTQET"><img src="https://s4.ax1x.com/2022/02/27/bnTQET.md.png" alt="bnTQET.md.png"></a></p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p>在假定的理想条件下，<strong>为了避免码间串扰，码元传输速率是有上限的</strong>。</p><ul><li>理想低通信道的最高码元传输速率 &#x3D; 2W Baud &#x3D; 2W 码元&#x2F;s</li><li>理想带通信道的最高码元传输速率 &#x3D; W Baud &#x3D; W 码元&#x2F;s</li><li>实际信道所能传输的码元速率要明显低于奈氏准则给出的上限值</li></ul><p>码元传输速率（波特率、调制速率、波形速率、符号速率）与比特率有一定关系：</p><ul><li>当1个码元只携带1比特的信息量时，则波特率（码元&#x2F;s）与比特率（比特&#x2F;s）在数值上相等；</li><li>当1个码元携带n比特的信息量时，则波特率（码元&#x2F;s）转换成比特率（比特&#x2F;s）数值要乘以n。</li></ul><p>要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量，这需要<strong>多元制</strong>。</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p><p><a href="https://imgtu.com/i/bnHMhF"><img src="https://s4.ax1x.com/2022/02/27/bnHMhF.md.png" alt="bnHMhF.md.png"></a></p><ul><li>信道带宽或信道中<strong>信噪比</strong>越大，信息的极限传输速率越高</li><li>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少，因为在实际信道中，信号还要受到其他一些损伤，例如各种脉冲干扰、信号在传输中的衰减和失真等，这些因素在香农公式中并未考虑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理层 </tag>
            
            <tag> 香农公式 </tag>
            
            <tag> 奈氏准则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-概论</title>
      <link href="/2022/02/26/computerInternet-1/"/>
      <url>/2022/02/26/computerInternet-1/</url>
      
        <content type="html"><![CDATA[<p>学校里没机会上计算机网络的课（因为名额满了就不分给咱学院了），只好自学了…<br>不过也没啥，大学不就是大家来自学的意思嘛（bushi<br>网课是网上推荐较多的，bilibili上面湖科大的视频<br>希望能坚持看完吧…</p><span id="more"></span><h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><h2 id="网络、互联网和因特网"><a href="#网络、互联网和因特网" class="headerlink" title="网络、互联网和因特网"></a>网络、互联网和因特网</h2><ul><li>网络由若干个结点和这些结点的链路组成</li><li>多个网络还可以通过路由器互连，这样就构成了一个覆盖范围更大的网络，即互联网，因此，互联网是“网络的网络”。</li><li>因特网是世界上最大的互联网络。</li></ul><h2 id="因特网服务提供者ISP-（Internet-Service-Provider）"><a href="#因特网服务提供者ISP-（Internet-Service-Provider）" class="headerlink" title="因特网服务提供者ISP （Internet Service Provider）"></a>因特网服务提供者ISP （Internet Service Provider）</h2><p>（比如我国的中国电信、移动和联通</p><h2 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h2><p>因特网所有的RFC(Request For Comments)技术文档都可以从因特网上免费下载(<a href="http://www.ietf.org/rfc.html">http://www.ietf.org/rfc.html</a>)</p><h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><ul><li>边缘部分：由所有连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享</li><li>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ul><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><h2 id="电路交换-Circuit-Switching"><a href="#电路交换-Circuit-Switching" class="headerlink" title="电路交换(Circuit Switching)"></a>电路交换(Circuit Switching)</h2><ul><li>电话交换机接通电话线的方式称为电路交换</li><li>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源</li><li>电路交换的三个步骤：建立连接（分配通信资源）；通话（一直占用通信资源）；释放连接（归还通信资源）</li><li>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低，因为<strong>计算机数据是突发式地出现在传输线路上的</strong>。</li></ul><p><a href="https://imgtu.com/i/bmoYqK"><img src="https://s4.ax1x.com/2022/02/27/bmoYqK.png" alt="bmoYqK.png"></a></p><h2 id="分组交换-Packet-Switching"><a href="#分组交换-Packet-Switching" class="headerlink" title="分组交换(Packet Switching)"></a>分组交换(Packet Switching)</h2><p>将表示消息的数据块称为一个报文，在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。<strong>在每一个数据段前面，加上一些由必要的控制信息组成的首部</strong>后，就构成了一个分组，也可简称为<strong>包</strong>。相应地，首部也可称为<strong>包头</strong>。</p><p><strong>首部包含了分组的目的地址</strong>，否则分组传输路径中的各分组交换机（路由器）就不知道如何转发分组了。分组交换机收到一个分组后，先暂时将分组存储下来，再检查其首部，按照首部中的目的地址进行查表转发，找到合适的转发接口，通过该接口将分组转发给下一个分组交换机。主机收到数据后，去除首部，再将其还原。</p><p>三方任务：</p><ul><li>发送方：构造分组、发送分组</li><li>分组交换机（路由器）：缓存分组、转发分组</li><li>接收方：接收分组、还原报文</li></ul><p><a href="https://imgtu.com/i/bmowPH"><img src="https://s4.ax1x.com/2022/02/27/bmowPH.png" alt="bmowPH.png"></a></p><h2 id="报文交换-Message-Switching"><a href="#报文交换-Message-Switching" class="headerlink" title="报文交换(Message Switching)"></a>报文交换(Message Switching)</h2><p>报文交换的交换结点也采用分组转发的方式，但报文交换对报文的大小没有限制，这就要求交换结点有较大的缓存空间。报文交换主要用于早期的电报通信网，目前较少使用，通常被较为先进的分组交换所取代。</p><h2 id="三种交换方式对比"><a href="#三种交换方式对比" class="headerlink" title="三种交换方式对比"></a>三种交换方式对比</h2><p><a href="https://imgtu.com/i/bmosMt"><img src="https://s4.ax1x.com/2022/02/27/bmosMt.png" alt="bmosMt.png"></a></p><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p><strong>通信之前建立连接</strong>，建立好连接后使用该连接进行数据传送，数据传送结束后释放连接，归还通信资源。一旦建立连接，中间各节点交换机就是直通形式的，比特流可以直达终点。</p><p>优点：</p><ul><li>通信时延小：通信线路为通信双方用户专用，数据直达，因此通信时延小，在连续传输大量数据时，优点明显</li><li>有序传输：双方只有一条专用线路，数据只在这一线路传输，不存在失序问题</li><li>没有冲突：不会出现争用物理信道问题</li><li>适用范围广：可以传输模拟和数字信号</li><li>实时性强</li><li>控制简单</li></ul><p>缺点：</p><ul><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差：只要所连接的物理通路任意一点出现故障，就必须重新拨号建立新的连接</li><li>难以规格化：不同类型、规格、速率的终端很难进行相互通信，也难以在通信过程中进行差错控制</li></ul><h3 id="报文交换："><a href="#报文交换：" class="headerlink" title="报文交换："></a>报文交换：</h3><p><strong>随时可以发送报文，不需要事先建立连接。</strong>整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。报文需要在各结点交换机上进行存储转发。由于不限制报文的大小，因此需要各结点交换机都具有较大的缓存空间。</p><p>优点：</p><ul><li>无需建立连接：不存在建立通路的时延</li><li>动态分配线路</li><li>提高线路可靠性：如果某条传输路径发生故障，会重新选择另一条路径传输数据，提高了传输可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul><p>缺点：</p><ul><li>引起了转发时延</li><li>需要较大的存储缓存空间</li><li>需要传输额外的信息量</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><strong>随时可以发送分组，不需要事先建立连接。</strong>构成原始报文的分组，依次在各结点交换机上存储转发。<strong>各结点交换机在发送分组的同时，还缓存接收到的分组。</strong>构成原始报文的分组在各结点交换机上进行存储转发，相比报文交换减少了转发时延，还可以避免过长的报文长时间占用链路，同时也<strong>有利于进行差错控制</strong>。</p><p>优点：</p><ul><li>无需建立连接</li><li>线路利用率高</li><li>简化存储管理：分组长度固定，缓冲区大小固定，管理容易</li><li>加速传输：由于分组逐个传输，后一个分组的存储和前一个分组的转发可以同时进行</li><li>减少出错概率和重发数据量：分组比报文小，出错概率必然减小，即便分组出错也只需重传出错的部分，而不是重传整个报文</li></ul><p>缺点：</p><ul><li>引起转发时延</li><li>需要传输额外的信息量</li><li>对于数据报服务，存在失序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程。</li></ul><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><p>计算机网络的最简单定义：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong></p><ul><li>互联：计算机之前可以通过有线或无线的方式进行数据通信</li><li>自治：指独立的计算机，拥有自己的硬件和软件，可以单独运行使用</li><li>集合：至少需要两台计算机</li></ul><p>计算机网络较好的定义：计算机网络主要是由一些<strong>通用的、可编程的硬件互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的日益增长的应用</strong>。</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件</li><li>计算机网络并非专们用来传送数据，而是能够支持多种应用。</li></ul><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ul><li>按交换技术分类：电路交换网络、报文交换网络、分组交换网络</li><li>按使用者分类：公用网（公众网）、专用网</li><li>按传输介质分类：有限网络、无线网络</li><li>按覆盖范围分类：广域网WAN、城域网MAN、局域网LAN、个域网PAN</li><li>按拓扑结构分类：总线型网络、星型网络、环型网络、网状型网络</li></ul><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率。常用数据率单位如下：</p><ul><li>bit&#x2F;s (b&#x2F;s, bps)</li><li>kb&#x2F;s &#x3D; 10^3 b&#x2F;s (bps), KB &#x3D; 2^10B, B &#x3D; 8b</li><li>Mb&#x2F;s &#x3D; 10^6 b&#x2F;s (bps), MB &#x3D; 2^20B, B &#x3D; 8b</li><li>Gb&#x2F;s &#x3D; 10^9 b&#x2F;s (bps), GB &#x3D; 2^30B, B &#x3D; 8b</li><li>Tb&#x2F;s &#x3D; 10^12 b&#x2F;s (bps), TB &#x3D; 2^40B, B &#x3D; 8b</li></ul><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>带宽在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围，基本单位为Hz</p><p>带宽在计算机网络中的意义：表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率，基本单位为b&#x2F;s</p><p>带宽的两种表述之间有着密切联系：<strong>一条通信线路的频带宽度越宽，其所传输数据的最高数据率越高。</strong></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量表示在<strong>单位时间内通过某个网络（或信道、接口）的数据量</strong>。</p><p>被经常用于对现实世界中网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量<strong>受网络的带宽或额定速率的限制</strong>。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>网络时延由三部分组成：发送时延、传播时延、处理时延</p><p>发送时延 &#x3D; 分组长度（b）&#x2F;发送速率（b&#x2F;s），发送速率受网卡的发送速率、信道带宽和接口速率影响，取三者最小值。</p><p>传播时延 &#x3D; 信道长度（m）&#x2F;电磁波传播速率（m&#x2F;s），电磁波传播速率受传播介质影响，自由空间为3e8，铜线为2.3e8，光纤为2e8</p><p>处理时延一般不方便计算。处理时延忽略不计时，无法判断哪种时延占主导，需要具体情况具体分析。</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>传播时延与带宽的乘积</p><p>若发送端持续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特。</p><p>链路的时延带宽积又称为以比特为单位的链路长度。</p><h2 id="往返时间RTT-Round-Trip-Time"><a href="#往返时间RTT-Round-Trip-Time" class="headerlink" title="往返时间RTT(Round-Trip Time)"></a>往返时间RTT(Round-Trip Time)</h2><p>从源主机发送分组开始，直到源主机收到来自目的主机的确认分组为止所需要的时间。</p><p>在以太网、卫星链路、无线局域网的传播过程中，卫星链路所带来的传播时延比较大（卫星距离远）。</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：表示某信道有百分之几的时间是被利用的（有数据通过）。</p><p>网络利用率：全网络的信道利用率的加权平均。</p><p>根据排队论，<strong>当某信道的利用率增大时，该信道引起的时延也会迅速增加</strong>，因此<strong>信道利用率并非越高越好</strong>。如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用D&#x3D;D0&#x2F;(1-U)公式来表示D、D0和利用率U之间的关系：当网络利用率到达50%时，时延加倍；当网络利用率超过50%时，时延急剧增大；当网络利用率接近100%时，时延趋近于无穷。因此，一些拥有较大主干网的ISP通常会控制其信道利用率不超过50%，如果超过就要准备扩容增大带宽。</p><p>也不能使信道利用率太低，会浪费通信资源。应使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在合理范围内。</p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>即分组丢失率，是指在一定时间范围内传输过程中<strong>丢失的分组数量与总分组数量的比率</strong>。丢包率可具体分为接口丢包率、结点丢包率、链路丢包率、路径丢包率和网络丢包率等。</p><p>分组丢失主要有两种情况：</p><ul><li>分组在传输过程中出现误码，被结点丢弃；</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时可能造成网络拥塞。</li></ul><p>因此丢包率反映了网络的拥塞情况：</p><ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ul><h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="常见的计算机体系结构"><a href="#常见的计算机体系结构" class="headerlink" title="常见的计算机体系结构"></a>常见的计算机体系结构</h2><ul><li>开放系统互连参考模型（OSI）：<br>是一个七层协议的体系结构，从下往上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。是法律上的国际标准。</li><li>TCP&#x2F;IP体系结构：<br>是一个四层协议的体系结构，从下往上依次为网络接口层、网际层、运输层、应用层。是事实上的国际标准。</li></ul><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的物理层和数据链路层合并为网络结构层，并去掉了会话层和表示层。此外，由于TCP&#x2F;IP在网络层使用的协议是IP协议（网际协议），故网络层常被称为网际层。</p><p>用户主机的操作系统和用于网络互连的路由器中通常带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族，但路由器一般只包含网络接口层和网际层。TCP&#x2F;IP体系结构的网络接口层并没有规定具体内容，目的互连全世界不同的接口，因此本质上TCP&#x2F;IP体系结构只有上面的三层。</p><ul><li>网际层：核心协议为IP协议</li><li>运输层：TCP和UDP为两个重要协议</li><li>应用层：包含大量应用层协议，例如HTTP、SMTP、DNS、RTP</li></ul><p>IP协议可以将不同的网络接口互连，并向其上的TCP和UDP协议提供网络互连服务。而TCP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议（HTTP、SMTP）提供可靠传输的服务；UDP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议（DNS、RTP）提供不可靠传输的服务。</p><p>IP协议作为TCP&#x2F;IP体系结构中的核心协议，一方面负责互连不同的网络接口（IP over everything），另一方面为各种网络应用提供服务（Everything over IP）。</p><p><a href="https://imgtu.com/i/bmojJJ"><img src="https://s4.ax1x.com/2022/02/27/bmojJJ.png" alt="bmojJJ.png"></a></p><ul><li>原理体系结构：<br>是一个五层协议的体系结构，从下往上依次为物理层、数据链路层、网际层、运输层、应用层。将TCP&#x2F;IP体系结构的网络接口层又重新划分为了物理层和数据链路层，更有利于对计算机网络原理的学习。</li></ul><p><a href="https://imgtu.com/i/bmTPeK"><img src="https://s4.ax1x.com/2022/02/27/bmTPeK.png" alt="bmTPeK.png"></a></p><h1 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h1><p>将实现计算机网络所需要解决的主要问题划归到各个层</p><ul><li>物理层：使两台计算机通过信号传输比特0或1<br>采用怎样的传输媒体（介质）<br>采用怎样的物理接口<br>使用怎样的信号比特0和1</li><li>数据链路层：实现分组在一个网络上传输<br>如何标识网络中各主机（主机编址问题，例如MAC地址）<br>如何从信号所表示的一连串比特流中区分出地址和数据（分组的封装格式问题）<br>如何协调各主机争用总线</li><li>网络层：实现分组在网络间传输<br>如何标识各网络以及网络中的各主机（网络和主机共同编址的问题，例如IP地址）<br>路由器如何转发分组，如何进行路由选择</li><li>运输层：实现进程之间基于网络的通信<br>如何解决进程之间基于网络通信的问题<br>出现传输错误时如何处理</li><li>应用层：<br>通过应用进程间的交互来完成特定的网络应用</li></ul><p><a href="https://imgtu.com/i/bmTVWd"><img src="https://s4.ax1x.com/2022/02/27/bmTVWd.png" alt="bmTVWd.png"></a></p><h1 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h1><p>（老师讲得很好，视频讲解很清晰，所以直接贴视频吧</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=64605483&bvid=BV1c4411d7jb&cid=112162125&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h1 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h1><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li>实体： 任何可发送或接收的硬件或软件进程</li><li>对等实体：收发双方相同层次中的实体</li></ul><p><a href="https://imgtu.com/i/bmTuOP"><img src="https://s4.ax1x.com/2022/02/27/bmTuOP.png" alt="bmTuOP.png"></a></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li>协议：控制两个对等实体进行逻辑通信的规则的集合<br>逻辑通信实际中并不存在，只是假设出来的一种通信，目的在于方便我们单独研究体系结构某一层时不用考虑其他层</li><li>协议的三要素：语法、语义、同步</li></ul><p><a href="https://imgtu.com/i/bmT3Fg"><img src="https://s4.ax1x.com/2022/02/27/bmT3Fg.png" alt="bmT3Fg.png"></a></p><h3 id="语法-定义所交换信息的格式"><a href="#语法-定义所交换信息的格式" class="headerlink" title="语法:定义所交换信息的格式"></a>语法:定义所交换信息的格式</h3><p>例如下图为IP数据报的格式，其中的小格子称为字段或域，数字表示字段的长度，单位为位（也就是比特）。语法就是定义了这些小格子的长度和顺序，即语法定义了所交换信息由哪些字段以及何种顺序构成。</p><p><a href="https://imgtu.com/i/bmTclR"><img src="https://s4.ax1x.com/2022/02/27/bmTclR.png" alt="bmTclR.png"></a></p><h3 id="语义-定义收发双方所要完成的操作"><a href="#语义-定义收发双方所要完成的操作" class="headerlink" title="语义:定义收发双方所要完成的操作"></a>语义:定义收发双方所要完成的操作</h3><h3 id="同步-定义收发双方的时序关系"><a href="#同步-定义收发双方的时序关系" class="headerlink" title="同步:定义收发双方的时序关系"></a>同步:定义收发双方的时序关系</h3><p>例如TCP采用“三报文握手”建立连接的过程，要想进行运输层TCP实体间的逻辑通信，首先必须建立连接，从连接建立过程可以看出TCP客户端与TCP服务器之间的时序关系，以及各自的状态转换。只有双方建立连接后，才能进行TCP数据传输。</p><p><a href="https://imgtu.com/i/bm7a3d"><img src="https://s4.ax1x.com/2022/02/27/bm7a3d.png" alt="bm7a3d.png"></a></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul><li>在协议的控制下，<strong>两个对等实体间的逻辑通信使得本层能向上一层提供服务</strong>。<br>例如物理层对等实体在物理层协议的控制下向数据链路层提供服务。</li><li>要实现本层协议，<strong>还需要使用下面一层所提供的服务</strong>。<br>例如数据链路层对等实体享受物理层提供的服务，并在数据链路层协议的控制下进行逻辑通信，给网络层提供服务。</li><li>协议是<strong>“水平的”</strong>，服务是<strong>“垂直的”</strong>。</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下层的协议对上层的实体是<strong>“透明”</strong>的。<br>（例如我们享受使用手机打游戏，但是并不知道这个游戏咋做出来的</li></ul><p><a href="https://imgtu.com/i/bm7R3j"><img src="https://s4.ax1x.com/2022/02/27/bm7R3j.png" alt="bm7R3j.png"></a></p><ul><li>服务访问点：在<strong>同一系统中相邻两层的实体交换信息的逻辑接口</strong>，用于区分不同的服务类型。<br>数据链路层的服务访问点为帧的“类型”字段<br>网络层的服务访问点为IP数据报首部中的“协议字段”<br>运输层的服务访问点为“端口号”</li><li>服务原语：<strong>上层使用下层所提供的服务必须通过与下层交换一些命令</strong>，这些命令称为服务原语。</li><li>协议数据单元PDU：<strong>对等层次之间传送的数据包</strong>称为该层的协议数据单元。<br>物理层对等实体逻辑通信的数据包称为比特流<br>数据链路层对等实体逻辑通信的数据包为帧<br>网络层对等实体逻辑通信的数据包称为分组。如果使用IP协议，也称为IP数据报<br>运输层对等实体逻辑通信的数据包一般根据协议而定，使用TCP协议则称为TCP报文段；使用UDP协议则称为UDP用户数据报<br>应用层对等实体逻辑通信数据包一般称为应用报文<br>上述各层数据包可以统称为协议数据单元PDU</li><li>服务数据单元SDU：同一系统内，<strong>层与层之间交换的数据包</strong>称为服务数据单元</li><li>多个SDU可以合成一个PDU，一个SDU也可划分为几个PDU</li></ul><p><a href="https://imgtu.com/i/bm7qC4"><img src="https://s4.ax1x.com/2022/02/27/bm7qC4.png" alt="bm7qC4.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路交换 </tag>
            
            <tag> 分组交换 </tag>
            
            <tag> 报文交换 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> 服务 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11特性</title>
      <link href="/2022/02/25/c++11/"/>
      <url>/2022/02/25/c++11/</url>
      
        <content type="html"><![CDATA[<ul><li>提高运行效率的语言特性：右值引用、泛化常量表达式</li><li>原有语法的增强：初始化列表、统⼀的初始化语法、类型推导、范围for循环、Lambda表达式、final和override、构造函数委托</li><li>语言能力的提升：空指针nullptr、default和delete、⻓整数、静态assert</li><li>c++标准库的更新：智能指针、正则表达式、哈希表等</li></ul><span id="more"></span><h1 id="提高运行效率"><a href="#提高运行效率" class="headerlink" title="提高运行效率"></a>提高运行效率</h1><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>C++03及之前的标准中，右值是不允许被改变的，实践中也通常使⽤<code>const T&amp;</code>的⽅式传递右值。然⽽这是效率低下的做法，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">Person p = <span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>上述获取右值并初始化<code>p</code>的过程包含了<code>Person</code>的3个构造过程和2个析构过程，这是C++⼴受诟病的⼀点，但C++11 的右值引⽤特性允许我们对右值进⾏修改。借此可以实现<strong>move语义</strong>，即从右值中直接拿数据过来初始化或修改左值，⽽不需要重新构造左值后再析构右值。⼀个move构造函数是这样声明的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; rhs)&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="泛化常量表达式"><a href="#泛化常量表达式" class="headerlink" title="泛化常量表达式"></a>泛化常量表达式</h2><h1 id="原有语法的增强"><a href="#原有语法的增强" class="headerlink" title="原有语法的增强"></a>原有语法的增强</h1><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><h2 id="统一的初始化语法"><a href="#统一的初始化语法" class="headerlink" title="统一的初始化语法"></a>统一的初始化语法</h2><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h2 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h2><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式实际上就是提供了⼀个类似匿名函数的特性，⽽匿名函数则是在需要⼀个函数，但是⼜不想费⼒去命名⼀个函数的情况下去使⽤的。利⽤lambda表达式可以编写内嵌的匿名函数，⽤以替换独⽴函数或者函数对象，并且使代码更可读。</p><p>从本质上来讲，lambda表达式只是⼀种语法糖，因为所有其能完成的⼯作都可以⽤其它稍微复杂的代码来实现，但是它简便的语法却给C++带来了深远的影响。从⼴义上说，lamdba表达式产⽣的是函数对象。在类中，可以<strong>重载函数调⽤运算符<code>()</code><strong>，此时类的对象可以将具有类似函数的⾏为，我们称这些对象为</strong>函数对象（Function Object）</strong>或者<strong>仿函数（Functor）</strong>。相⽐ lambda表达式，函数对象有⾃⼰独特的优势。</p><p>lambda表达式⼀般都是从⽅括号[]开始，结束于花括号{}，花括号⾥⾯就像定义函数那样，包含了lamdba表达式体，⼀个最简单的例⼦如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义简单的lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> basicLambda = [] &#123; cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="built_in">basicLambda</span>(); <span class="comment">// 输出：Hello, world!</span></span><br></pre></td></tr></table></figure><p>（hello world百用不厌嗷兄弟们</p><p>上⾯是最简单的lambda表达式，没有参数。如果需要参数，那么就要像函数那样，放在圆括号⾥⾯，如果有返回值，返回类型要放在-&gt;后⾯，即拖尾返回类型，当然你也可以忽略返回类型，<strong>lambda会帮你⾃动推断出返回类型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指明返回类型，托尾返回类型</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// ⾃动推断返回类型</span></span><br><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 输出：7</span></span><br><span class="line"><span class="type">int</span> product = <span class="built_in">multiply</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure><p>最前边的<code>[]</code>是lambda表达式的⼀个很重要的功能，就是闭包。先说明⼀下lambda表达式的⼤致原理：每当你定义⼀个lambda表达式后，编译器会⾃动⽣成⼀个匿名类（这个类重载了<code>()</code>运算符），我们称为闭包类型（closure type）。那么在运⾏时，这个lambda表达式就会返回⼀个匿名的闭包实例，其是⼀个右值。所以，上⾯lambda表达式的结果就是⼀个个闭包实例。<strong>闭包的⼀个强⼤之处是可以通过传值或者引⽤的⽅式捕捉其封装作⽤域内的变量</strong>，前⾯的⽅括号就是⽤来定义捕捉模式以及变量，⼜将其称为 lambda 捕捉块。例⼦如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_x = [x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;</span><br><span class="line">    <span class="comment">// 复制捕捉x,lambda表达式⽆法修改此变量</span></span><br><span class="line">    <span class="keyword">auto</span> multiply_x = [&amp;x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a * x; &#125;;</span><br><span class="line">    <span class="comment">// 引⽤捕捉x，lambda表达式可以修改此变量</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_x</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">multiply_x</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出：20 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获的⽅式可以是引⽤也可以是复制，但是具体说来会有以下⼏种情况来捕获其所在作⽤域中的变量：</p><ul><li><code>[]</code>：默认不捕获任何变量；</li><li><code>[=]</code>：默认以值捕获所有变量；</li><li><code>[&amp;]</code>：默认以引⽤捕获所有变量；</li><li><code>[a]</code>：仅以值捕获a，其它变量不捕获；</li><li><code>[&amp;a]</code>：仅以引⽤捕获a，其它变量不捕获；</li><li><code>[=, &amp;a]</code>：默认以值捕获所有变量，但a是例外，通过引⽤捕获；</li><li><code>[&amp;, a]</code>：默认以引⽤捕获所有变量，但是a是例外，通过值捕获；</li><li><code>[this]</code>：通过引⽤捕获当前对象（其实是复制指针）；</li><li><code>[*this]</code>：通过传值⽅式捕获当前对象；</li></ul><p>⽽<strong>lambda表达式⼀个更重要的应⽤是其可以⽤于函数的参数，通过这种⽅式可以实现回调函数。</strong>其实最常⽤的是在STL算法中，⽐如要统计⼀个数组中满⾜特定条件的元素数量，通过lambda表达式给出条件，传递给<code>count_if</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(v.<span class="built_in">beigin</span>(), v.<span class="built_in">end</span>(), [val](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; val; &#125;);</span><br><span class="line"><span class="comment">// v中⼤于3的元素数量</span></span><br></pre></td></tr></table></figure><p>最后给出lambda表达式的完整语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[capture-list] (params) <span class="built_in">mutable</span>(optional) <span class="built_in">constexpr</span>(optional)(c++<span class="number">17</span>) exception attribute -&gt; ret &#123; body &#125;</span><br><span class="line"><span class="comment">// 可选的简化语法</span></span><br><span class="line">[capture-list] (params) -&gt; ret &#123;body&#125; </span><br><span class="line">[capture-list] (params) &#123;body&#125; </span><br><span class="line">[capture-list] &#123;body&#125;</span><br></pre></td></tr></table></figure><ul><li>capture-list：捕捉列表，前⾯已经讲过，不能省略；</li><li>params：参数列表，可以省略（但是后⾯必须紧跟函数体）；</li><li>mutable：可选，将lambda表达式标记为mutable后，函数体就可以修改传值⽅式捕获的变量；</li><li>constexpr：可选，C++17，可以指定lambda表达式是⼀个常量函数；</li><li>exception：可选，指定lambda表达式可以抛出的异常；</li><li>attribute：可选，指定lambda表达式的特性；</li><li>ret：可选，返回值类型；</li><li>body：函数执⾏体。</li></ul><h2 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h2><h2 id="构造函数委托"><a href="#构造函数委托" class="headerlink" title="构造函数委托"></a>构造函数委托</h2><h1 id="语言能力提升"><a href="#语言能力提升" class="headerlink" title="语言能力提升"></a>语言能力提升</h1><h2 id="空指针nullptr"><a href="#空指针nullptr" class="headerlink" title="空指针nullptr"></a>空指针nullptr</h2><p>nullptr的出现是为了替代原有的NULL。在某种意义上来说，传统C++会把NULL和0视为相同，取决于编译器如何定义NULL：有些编译器会将NULL定义为<code>((void*)0)</code>，有些则直接定义为0。C++不允许将<code>void*</code>隐式转换到其他类型，但如果NULL被定义为<code>((void*)0)</code>，那么当编译<code>char *ch = NULL</code>时，NULL只能被定义为0。但是依然会产生问题，将导致C++中重载特性发生混乱。考虑如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这两个函数来说，如果NULL为0那么<code>func(NULL)</code>将会去调用<code>func(int)</code>，导致代码违反直观。</p><p>为了解决该问题，C++11引入关键字<code>nullptr</code>专门用于区分空指针和0。<code>nullptr</code>的类型为<code>nullptr_t</code>，能够隐式地转换为任何指针或成员指针的类型，也能和他们进行相等或不等的比较。<br>（所以养成用<code>nullptr</code>取代<code>NULL</code>的好习惯噢</p><h2 id="default和delete"><a href="#default和delete" class="headerlink" title="default和delete"></a>default和delete</h2><h2 id="长整数"><a href="#长整数" class="headerlink" title="长整数"></a>长整数</h2><h2 id="静态assert"><a href="#静态assert" class="headerlink" title="静态assert"></a>静态assert</h2><h1 id="c-标准库更新"><a href="#c-标准库更新" class="headerlink" title="c++标准库更新"></a>c++标准库更新</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2>]]></content>
      
      
      <categories>
          
          <category> 小黎与C++的互相拉扯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 右值引用 </tag>
            
            <tag> 泛化常量表达式 </tag>
            
            <tag> 初始化列表 </tag>
            
            <tag> 初始化语法 </tag>
            
            <tag> 类型推导 </tag>
            
            <tag> 范围for循环 </tag>
            
            <tag> lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x&amp;(x-1)的使用</title>
      <link href="/2022/02/25/x&amp;(x-1)/"/>
      <url>/2022/02/25/x&amp;(x-1)/</url>
      
        <content type="html"><![CDATA[<ul><li>计算数的二进制1的个数</li><li>判断是否为2的次方数</li></ul><span id="more"></span><h1 id="将x转为二进制，计算1的数目"><a href="#将x转为二进制，计算1的数目" class="headerlink" title="将x转为二进制，计算1的数目"></a>将x转为二进制，计算1的数目</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每执行一次<code>x = x &amp; (x-1)</code>，会将<code>x</code>用二进制表示时最右边的一个1变为0，因为<code>x-1</code>会将该二进制最右边的一个1变为0。</p><h1 id="判断数x是否为2的次方数"><a href="#判断数x是否为2的次方数" class="headerlink" title="判断数x是否为2的次方数"></a>判断数x是否为2的次方数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  x &amp;&amp; (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理同上，此外要注意<code>==</code>的优先级高于<code>&amp;</code>，且<code>x</code>不能为0。</p>]]></content>
      
      
      <categories>
          
          <category> 小黎和二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 与运算 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
