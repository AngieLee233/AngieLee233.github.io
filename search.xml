<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>删除二叉搜索树中的节点</title>
      <link href="/2022/03/08/deleteNodeInBST/"/>
      <url>/2022/03/08/deleteNodeInBST/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉搜索树的根节点root和一个值key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><span id="more"></span><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450.删除二叉搜索树中的节点</a></p><p><del>这题目还假惺惺地告诉了你步骤</del></p><p>这题很明显地递归，如果你想看迭代的解法可以看<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/comments/155645">这里</a>，反正我是不会这么写的…</p><p>递归的思路很清晰，利用BST的性质即可：</p><ul><li>如果当前节点的值小于目标值，说明目标节点在右子树，往右子树递归</li><li>如果当前节点的值大于目标值，说明目标节点在左子树，往左子树递归</li><li>如果当前节点的值等于目标值，说明该节点为目标节点。如果该节点只有左子树或右子树，直接用非空子树替换即可。如果该节点左右子树都非空，将该节点的值替换为该节点的右子树中最小节点的值（一直往左子树找即可），往右子树递归，删除最小节点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; key)&#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; key)&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* temp = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;left)&#123;</span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                root-&gt;val = temp-&gt;val;</span><br><span class="line">                root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子序和</title>
      <link href="/2022/03/08/maximumSubarray/"/>
      <url>/2022/03/08/maximumSubarray/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组<code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分</p><span id="more"></span><p>小黎一开始想用前缀和来做的，就是当前前缀和减去目前最小前缀和，和当前ans取max。但是这样的话对于包含第0个元素的答案是不行的，后面感觉这不就是动态规划的思想嘛，于是转头写动态规划了。</p><p>状态转移方程很直观，就是要么取之前数组和当前元素组合成一个数组，要么这个数组新开一个。设$f(i)$为数组前$i$个元素的最大前缀和，状态转移方程为：<br>$$<br>f(i) &#x3D; max(f(i - 1) + nums[i], nums[i])<br>$$<br>由于状态转移方程只和前一个结果有关，所以用一个变量存储之前的结果就行。取遍历过程中的最大值作为结果就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            pre = <span class="built_in">max</span>(nums[i] + pre, nums[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子序和 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最近公共祖先</title>
      <link href="/2022/03/07/lowestCommonAncestorOfABinaryTree/"/>
      <url>/2022/03/07/lowestCommonAncestorOfABinaryTree/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点p、q，最近公共祖先表示为一个节点x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236.二叉树的最近公共祖先</a></p><p>递归！</p><p>后序遍历，从下往上递归。</p><p>递归出口：当前结点为空或为目标节点，则返回该结点。</p><p>结点操作：</p><ul><li>如果左子树和右子树递归结果都是空指针，说明该节点下无目标结点，返回空指针。</li><li>如果左子树和右子树递归结果都不为空指针，说明该根结点为所求LCA（因为是从下往上找的嘛。</li><li>如果左子树和右子树中有一个是空结点，说明目标节点存在于某一个子树中，返回非空的子树。</li></ul><p>就是个递归啦！想到就很简单！上代码！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="literal">nullptr</span> ? right : left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树最大路径和</title>
      <link href="/2022/03/07/binaryTreeMaximumPathSum/"/>
      <url>/2022/03/07/binaryTreeMaximumPathSum/</url>
      
        <content type="html"><![CDATA[<p><strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中<strong>至多出现一次</strong>。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><p><strong>路径和</strong>是路径中各节点值的总和。</p><p>给你一个二叉树的根节点<code>root</code>，返回其最大路径和。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树的最大路径和</a></p><p><del>其实我感觉题目有点不说人话</del></p><p>这题相当于，把二叉树当成一个无向图，求所经过结点之和最大的路径。</p><p>这题可以递归解，单独考虑只有根节点、左节点和右节点的二叉树。由于迭代是向上的，所以是一颗颗这样的小树组成一整颗大树。对于一颗小树，可以有如下几个选择：</p><ul><li>和上端大树相连</li></ul><ol><li>选择根节点</li><li>选择根节点、左节点</li><li>选择根节点、右节点</li></ol><ul><li>不和上端大树相连，重新开辟新的路径</li></ul><ol><li>选择左节点、根节点、右节点</li><li>选择左节点</li><li>选择右节点</li></ol><p>和上端大树相连的情况，可以返回三者取<code>max</code>的结果作为返回值；而不和上端大树相连的情况，可以单独缓存至一个变量里，每次递归时更新该值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = -INT_MAX;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">recur</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -INT_MAX / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">recur</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">recur</span>(node-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(&#123;ans, left, right, left + node-&gt;val + right&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(&#123;node-&gt;val, node-&gt;val + left, node-&gt;val + right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 最大路径和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/03/07/reverseList/"/>
      <url>/2022/03/07/reverseList/</url>
      
        <content type="html"><![CDATA[<p>大链表吱呀吱悠悠地转♪</p><p>这里~的风景呀真奇怪♪</p><p>天在转♪ 地在转♪</p><p>还有一个刷题的小笨蛋♪</p><span id="more"></span><p>反转链表！经久不衰的<del>送分</del>题！</p><h1 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206.反转链表</a></p><p>给你单链表的头节点<code>head</code>，请你反转链表，并返回反转后的链表。</p><p>迭代和<del>递龟</del>递归都可以哦！</p><h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><p>遍历整个链表，反转一下next指针的方向就好了，非常简单，不赘述啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>递归的版本就比较复杂一些，关键在于反向工作。假设链表的其余部分已经被反转，那么考虑如何反转之前的部分。</p><p>假设链表长这样：<br>$$<br>n_1 \rightarrow \dots n_{k - 1} \rightarrow n_k \rightarrow n_{k + 1} \rightarrow \dots \rightarrow n_m \rightarrow nullptr<br>$$</p><p>如果我们已经将$n_{k + 1} \rightarrow \dots \rightarrow n_m$的部分反转，目前来到了$n_k$。那么我们希望$n_k$的下一个结点$n_{k + 1}$能指向$n_k$。即：<br>$$<br>n_k\rightarrow next\rightarrow next &#x3D; n_k<br>$$</p><p>那就开始递归吧！从后往前反转链表，就一直一直往后冲。但是需要一个出口呀，这里设置当结点为空或到达链表末端时返回该结点，相当于是新链表的头部啦！之后就是之前分析的部分啦，执行<code>head-&gt;next-&gt;next = head;</code>更改指针的方向。但是要记得把当前指针的<code>next</code>设为空哦，不然就会有环啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="反转部分链表"><a href="#反转部分链表" class="headerlink" title="反转部分链表"></a>反转部分链表</h1><p>反转所有链表还是太简单了（单指迭代，上点有意思的：反转部分链表！</p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92.反转部分链表 II</a></p><h2 id="截取需要反转部分单独操作"><a href="#截取需要反转部分单独操作" class="headerlink" title="截取需要反转部分单独操作"></a>截取需要反转部分单独操作</h2><p>最容易想到的思路就是，借鉴之前反转整个链表的想法，弄四个指针，两个指针在开始反转部分的前一个和开始部分，设为<code>pre</code>和<code>leftNode</code>；两个指针在反转部分的结束部分和后一个结点，设为<code>rightNode</code>和<code>curr</code>。将<code>pre</code>和<code>rightNode</code>的<code>next</code>设为空，将需要反转的部分独立出来，单独进行反转。反转完成后再接回原来的链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseLinkedList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 也可以使用递归反转一个链表</span></span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">        ListNode *rightNode = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            rightNode = rightNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">        ListNode *leftNode = pre-&gt;next;</span><br><span class="line">        ListNode *curr = rightNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：切断链接</span></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rightNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">        <span class="built_in">reverseLinkedList</span>(leftNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">        pre-&gt;next = rightNode;</span><br><span class="line">        leftNode-&gt;next = curr;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>上一个方法当需要反转的区间长度非常大的时候，时间开销会变大，极端情况下需要遍历两次链表。考虑使用“头插法”实现一次遍历的反转部分链表。</p><p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。</p><p>下面我们具体解释如何实现。使用三个指针变量 <code>pre</code>、<code>curr</code>、<code>next</code>来记录反转的过程中需要的变量，它们的意义如下：</p><ul><li><code>curr</code>：指向最初的待反转区域的第一个节点；</li><li><code>next</code>：永远指向<code>curr</code>的下一个节点，循环过程中，<code>curr</code>变化以后<code>next</code>会变化；</li><li><code>pre</code>：永远指向最初的待反转区域的第一个节点<code>left</code>的前一个节点，在循环过程中不变。</li></ul><p>（要画的图太多了，直接手写了</p><p><img src="https://img30.360buyimg.com/pop/jfs/t1/108587/29/25572/2142718/62262091Eb51130ab/c7fcb3389707aaa1.png" alt="reverselink.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小黎刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的第k个最大元素</title>
      <link href="/2022/03/07/kthBiggest/"/>
      <url>/2022/03/07/kthBiggest/</url>
      
        <content type="html"><![CDATA[<p>（小黎最近在忙刷题，网课先告一段落！绝对不鸽！<del>咕咕咕</del></p><p>给定整数数组<code>nums</code>和整数<code>k</code>，请返回数组中第<code>k</code>个最大的元素。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/submissions/">215.数组中的第K个最大元素</a></p><p>这个主要就是用到了<strong>快排</strong>的思想啦！随机选择数组中的一个数作为<code>key</code>，之后将比<code>key</code>小的数放到它的右边，比它大的放左边。（因为要第<code>k</code>大嘛！如果要第<code>k</code>小的话就比它大的反过来就好啦！）</p><p>排序完之后，如果<code>key</code>刚好在第<code>k</code>个的位置的话，直接返回就好啦。如果<code>key</code>的下标小于<code>k - 1</code>（这里是用于下标从0开始计算的语言哦！下标从1开始的语言要变一下哦，灵活变一下啦），那么所求元素在<code>key</code>的右边，继续对右边进行相同的操作；如果<code>key</code>的下标大于<code>k - 1</code>，那么所求元素在<code>key</code>的左边，继续对左边进行相同的操作。</p><p>快速排序的性能和划分出的子数组的长度密切相关。直观地理解就是，如果每次规模为$n$的问题我们都划分成$1$和$n - 1$，每次递归的时候又向$n - 1$的集合中递归，这种情况是最坏的，时间代价是$O(n ^ 2)$。我们可以<strong>引入随机化来加速</strong>这个过程，它的时间代价的期望是$O(n)$，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p><p>放上小黎的代码！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getKth</span>(nums, k - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right != left)&#123;</span><br><span class="line">            <span class="type">int</span> random = <span class="built_in">rand</span>() % (right - left) + left;</span><br><span class="line">            <span class="built_in">swap</span>(nums[random], nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span>(idx == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[idx];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx &gt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKth</span>(nums, k, left, idx - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKth</span>(nums, k, idx + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> begin = left - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> key = nums[right];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; key)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++begin], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[++begin], nums[right]);</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时：4ms，超过了97%的cpp提交记录<br>内存消耗：9.6MB，超过了90%的cpp提交记录</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小黎刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速选择 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客图片居中大法</title>
      <link href="/2022/03/01/center-img/"/>
      <url>/2022/03/01/center-img/</url>
      
        <content type="html"><![CDATA[<p>忍了几天，但是博客图片靠左真的<strong>太丑了</strong><br>丑到我的懒癌都压不住<br>上网找了些方法，记录一下吧</p><span id="more"></span><p>Markdown这玩意生下来就不带图片居中这花里胡哨的玩意，不过人家支持html语法，可以<strong>曲线救国</strong>一下。</p><h1 id="使用html格式"><a href="#使用html格式" class="headerlink" title="使用html格式"></a>使用html格式</h1><p>像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s4.ax1x.com/2022/03/01/blYdKA.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来，试试看！</p><div align="center">    <img src="https://s4.ax1x.com/2022/03/01/blYdKA.png"></img></div><p>这不就居中了嘛！</p><h1 id="难道要我在贴图的时候一个个改吗！"><a href="#难道要我在贴图的时候一个个改吗！" class="headerlink" title="难道要我在贴图的时候一个个改吗！"></a>难道要我在贴图的时候一个个改吗！</h1><p>像我这种<strong>大懒人</strong>自然是不会这么做的，之前的方法适用于没几个图的博客。<del>但是我相信过段时间你的博客就不是没几个图的状态了</del></p><p>MarkDown插入图片代码在最终渲染的时候，其实是变成了html中的img元素。因此我们可以直接<del>直接杀</del>去博客主题文件的源代码，找到控制文章内图片显示样式的css代码，将其修改成水平居中即可。</p><p>一般在<code>themes-&gt;(主题名称文件夹)-&gt;source-&gt;css-&gt;_partial</code>文件夹中可以找到，懒得找的直接在文件夹里搜索<code>img</code>也行（反正我就这么找着的</p><p>img后面有一坨花括号，改改就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">    max-width 100%;</span><br><span class="line">    display block;</span><br><span class="line">    margin 0 auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我当时改了最后一行，并加上了倒数第二行。这个方法参考的是<a href="https://www.butterpig.top/blog/hexo-img-center/">这篇博客</a>，和人家的有些出入，如果我的法子不行可以试试别人的~</p>]]></content>
      
      
      <categories>
          
          <category> 强迫症小黎的悲惨晚年 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客图片居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于MarkDown语法中加粗失效的问题</title>
      <link href="/2022/03/01/md-20220301/"/>
      <url>/2022/03/01/md-20220301/</url>
      
        <content type="html"><![CDATA[<p>小黎今天肝计网的时候，发现有个地方加粗失效了<br>但是下面的加粗又是可以的！<br>小黎上网找了找原因发现…<br>震惊！真相竟然是这个…<br><del>（一天天震惊震惊的，怎么不吓死你</del></p><span id="more"></span><h1 id="事件起因"><a href="#事件起因" class="headerlink" title="事件起因"></a>事件起因</h1><p>效果就是下图那样啦，上面的式子不能加粗，下面的可以（这个笔记写太快了，有很多小问题，忽略就好啦…</p><p><a href="https://imgtu.com/i/bMHNi6"><img src="https://s4.ax1x.com/2022/03/01/bMHNi6.png" alt="bMHNi6.png"></a></p><h1 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h1><p>后面小黎上网发现，加粗的开始标记符（就是前面两个小星星），和结束标记符（就是后面的两个小星星）对前后内容是有要求的！</p><h2 id="开始前先了解一下CommonMark规范吧"><a href="#开始前先了解一下CommonMark规范吧" class="headerlink" title="开始前先了解一下CommonMark规范吧"></a>开始前先了解一下CommonMark规范吧</h2><blockquote><p>Markdown将<code>*</code>与<code>_</code>作为强调指示符。被单个<code>*</code>或<code>_</code>包裹的文本将被HTML<code>&lt;em&gt;</code>标签包裹（也就是斜体）；被两个包裹的将被HTML<code>&lt;strong&gt;</code>标签包裹（也就是粗体）。</p></blockquote><p>先说几个关键词的意思吧~</p><h3 id="定界符序列（delimiter-run）"><a href="#定界符序列（delimiter-run）" class="headerlink" title="定界符序列（delimiter run）"></a>定界符序列（delimiter run）</h3><p>定界符类指的是：</p><ul><li>一个或一串非转义的<code>*</code>；</li><li>一个或一串非转义的<code>_</code>。</li></ul><h3 id="左侧定界符序列（left-flanking-delimiter-run）"><a href="#左侧定界符序列（left-flanking-delimiter-run）" class="headerlink" title="左侧定界符序列（left-flanking delimiter run）"></a>左侧定界符序列（left-flanking delimiter run）</h3><p>左侧定界符序列是一个定界符序列，且：</p><ul><li>后面不能是空白；</li><li>当前面没有空白或标点符号时，后面不能是标点符号。</li></ul><h3 id="右侧定界符序列（right-flanking-delimiter-run）"><a href="#右侧定界符序列（right-flanking-delimiter-run）" class="headerlink" title="右侧定界符序列（right-flanking delimiter run）"></a>右侧定界符序列（right-flanking delimiter run）</h3><p>右侧定界符序列是一个定界符序列，且：</p><ul><li>前面不能是空白；</li><li>当后面没有空白或标点符号时，前面不能是标点符号。</li></ul><h2 id="结合一下车祸现场吧"><a href="#结合一下车祸现场吧" class="headerlink" title="结合一下车祸现场吧"></a>结合一下车祸现场吧</h2><p>结合上方的例子，后面的<code>**</code>的前面是标点符号，但后面却不是空白或标点符号，所以它不是右侧定界符序列，不会被当作是结束粗体的标识符，自然粗体就不生效了。</p><p>（就是人家的自我认知出了点差错，怪我怪我…</p><h2 id="可是，为什么要这么定义？"><a href="#可是，为什么要这么定义？" class="headerlink" title="可是，为什么要这么定义？"></a>可是，为什么要这么定义？</h2><p>为了能支持嵌套分隔符序列，<code>**one **two two **three** two two** one**</code>：</p><blockquote><p><strong>one <strong>two two <strong>three</strong> two two</strong> one</strong></p></blockquote><p>这里就不具体说了，只能说懂的都懂（bushi</p><p>这样的影响是什么呢，就是使用非空格分词语言（比如中文）的用户只能<strong>骂骂咧咧</strong><font size=1><del>地继续用下去</del></font></p><h1 id="那怎么办！解决方案呢！"><a href="#那怎么办！解决方案呢！" class="headerlink" title="那怎么办！解决方案呢！"></a>那怎么办！解决方案呢！</h1><h2 id="你多加个空格不就行了"><a href="#你多加个空格不就行了" class="headerlink" title="你多加个空格不就行了"></a>你多加个空格不就行了</h2><p>相信大多数非强迫症患者会采用这个方案（就像我，但是感觉根源还是<strong>懒</strong></p><p>可是哪个中国人写字没事加空格啊！</p><h2 id="好吧，那试试零宽空格（zero-width-space，ZWSP）"><a href="#好吧，那试试零宽空格（zero-width-space，ZWSP）" class="headerlink" title="好吧，那试试零宽空格（zero-width space，ZWSP）"></a>好吧，那试试零宽空格（zero-width space，ZWSP）</h2><p>ZWSP长这样！锵锵！</p><blockquote><p>​</p></blockquote><p>什么？你说看不到？<del>其实聪明的人才看得到</del></p><p>看不到就对啦，ZWSP是一种不可打印的<code>Unicode</code>字符（<code>U+200B</code>），用于可能需要换行处。</p><p>我们可以使用ZWSP<strong>指定长文字的换行位置</strong>；只有当荧幕宽度不足以单行显示时ZWSP才会起作用。</p><p>举个例子，没有使用 ZWSP 时是这样的：</p><blockquote><p>LongLongLongLongLongLongLongLongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p></blockquote><p>使用ZWSP时是这样的</p><blockquote><p>LongLongLongLongLongLongLongLongLongLongLongLongLongLongLong​BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p></blockquote><p>由于 ZWSP 这种特殊属性，它也被用于<del>绕过敏感词检查</del>、创造不可复制的伪链接等等。</p><p>回到之前的问题，只要在需要加空格的地方加上ZWSP就好啦~</p><p>这个字符可以在<a href="https://unicode-table.com/en/200B/">这里</a>复制，点击copy就好啦</p><p><del>懒得截图了，还得上传图床</del></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与MarkDown不得不说的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加粗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-数据链路层</title>
      <link href="/2022/02/28/computerInternet-3/"/>
      <url>/2022/02/28/computerInternet-3/</url>
      
        <content type="html"><![CDATA[<p>小黎一天学一章，小黎真棒<br>上一章笔记的图片尺寸有些过于大了…<br>小黎懒得改，小黎真懒</p><span id="more"></span><h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><ul><li>链路：从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点</li><li>数据链路：把实现通信协议的硬件和软件加到链路上，就构成了数据链路</li><li>数据链路层以<strong>帧</strong>为单位传输和处理数据</li></ul><p><a href="https://imgtu.com/i/bKcRsO"><img src="https://s4.ax1x.com/2022/02/28/bKcRsO.png" alt="bKcRsO.png"></a></p><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>数据链路层<strong>给网络层交付的协议数据单元添加帧头和帧尾</strong>的操作，称为封装成帧。添加帧头和帧尾都是为了在链路上以帧为单元传送数据，也就是为了实现数据链路层本身的功能。</p><p><a href="https://imgtu.com/i/bMSszt"><img src="https://s4.ax1x.com/2022/02/28/bMSszt.png" alt="bMSszt.png"></a></p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>发送方将封装好的帧通过物理层发送到传输媒体，帧在传输过程中遭遇干扰后可能会出现<strong>误码</strong>（0变成1，1变成0）。发送方在发送数据之前，基于待发送的数据和检错算法计算出检错码，并将其封装在帧尾；接收方主机收到帧后，通过检错码和检错算法能够判断出帧在传输过程中是否出现了误码。</p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>尽管误码不能完全避免，但若能实现<strong>发送方发送什么，接收方就能收到什么</strong>，就称为可靠传输。</p><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ul><li>编址问题：将帧的目的地址放在帧中一起传输</li><li>碰撞问题：多个主机同时使用总线传输帧时，传输信号会发生碰撞。<br>（共享式以太网的媒体接入控制协议CSMA&#x2F;SD、802.11局域网的媒体接入控制协议CSMA&#x2F;CA）</li></ul><h2 id="数据链路层的互连设备"><a href="#数据链路层的互连设备" class="headerlink" title="数据链路层的互连设备"></a>数据链路层的互连设备</h2><ul><li>网桥和交换机的工作原理</li><li>集线器（物理层互连设备）与交换机的区别</li></ul><h1 id="封装成帧-1"><a href="#封装成帧-1" class="headerlink" title="封装成帧"></a>封装成帧</h1><h2 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h2><ul><li>帧头和帧尾的作用之一就是<strong>帧定界</strong></li><li>并不是所有帧头和帧尾都包含帧定界标志，物理层会给其添加前导码，其中包括前同步码和帧开始定界符。另外以太网还规定了帧间间隔时间，故MAC不需要帧结束定界符。</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，就好像数据链路层不存在一样。（例如不要求不能出现帧定界符，通过扫描上层传输数据并在与帧定界符相同内容前面添加转义字符解决</p><ul><li>面向字节的物理链路使用字节填充（字符填充）的方法实现透明传输</li><li>面向比特的物理链路使用比特填充的方法实现透明传输</li></ul><h1 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h1><ul><li>为了提高帧的传输速率，应当使<strong>帧的数据部分长度尽可能大些</strong>。</li><li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即<strong>最大传送单元MTU</strong>。</li></ul><h1 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h1><ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能变成0，0可能变成1，这称为<strong>比特差错</strong>。</li><li>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER</strong>。</li><li>使用<strong>差错检测</strong>来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li></ul><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><ul><li>在待发送的数据后面<strong>添加1位奇偶校验位</strong>，使整个数据（包括所添加的校验位在内）中<strong>1的个数</strong>为奇数（奇校验）或偶数（偶校验）</li><li>如果有<strong>奇数个位数发生误码</strong>，则奇偶性发生变化，<strong>可以检查出误码</strong></li><li>如果有<strong>偶数个位数发生误码</strong>，则奇偶性不发生变化，<strong>不可以检查出误码</strong>（<strong>漏检</strong>）</li></ul><p>（太弱了，一般不用</p><h2 id="循环冗余校验CRC（Cyclic-Redundancy-Check）"><a href="#循环冗余校验CRC（Cyclic-Redundancy-Check）" class="headerlink" title="循环冗余校验CRC（Cyclic Redundancy Check）"></a>循环冗余校验CRC（Cyclic Redundancy Check）</h2><ul><li>收发双方约定好一个<strong>生成多项式G(x)</strong></li><li>发送方基于待发送的数据和生成多项式计算出差错检测码（<strong>冗余码</strong>），将其添加到代传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ul><p><a href="https://imgtu.com/i/bMMXJ1"><img src="https://s4.ax1x.com/2022/02/28/bMMXJ1.png" alt="bMMXJ1.png"></a></p><h3 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h3><ul><li><strong>待发送的数据作为被除数的一部分，后面添加生成多项式最高次个0</strong>以构成被除数。</li><li><strong>生成多项式各项系数</strong>构成的比特串作为除数</li><li>相除得到的余数作为冗余码，将其添加到待发送数据的后面一起发送</li><li>冗余码的<strong>长度与生成多项式最高次数相同</strong>，商仅作为标记，防止计算过程中对错位</li></ul><h3 id="接受方"><a href="#接受方" class="headerlink" title="接受方"></a>接受方</h3><ul><li><strong>已接收的数据</strong>作为被除数。</li><li><strong>生成多项式各项系数</strong>构成的比特串作为除数</li><li>相除得到的<strong>余数如果为0则可以判定传输过程没有产生误码，否则产生了误码</strong></li></ul><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><ul><li><strong>检错码</strong>只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法<strong>纠正错误</strong></li><li>要想纠正传输中的差错，可以使用冗余信息更多的<strong>纠错码</strong>进行<strong>前向纠错</strong>。但纠错码的开销比较大，<strong>在计算机网络中较少使用</strong></li><li>循环冗余校验CRC有很好的检错能力（<strong>漏检率非常低</strong>），虽然计算复杂，但非常<strong>易于用硬件实现</strong>，因此被<strong>广泛应用于数据链路层</strong></li><li>在计算机网络中通常采用<strong>检错重传</strong>方式来纠正传输中的差错，或者<strong>仅丢弃检测到差错的帧</strong>，这取决于数据链路层向上层提供的传输服务是否可靠</li></ul><h1 id="可靠传输-1"><a href="#可靠传输-1" class="headerlink" title="可靠传输"></a>可靠传输</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>一般情况下，<strong>有线链路</strong>的误码率比较低，为了减小开销，<strong>并不要求数据链路层向上提供可靠传输服务</strong>。即使出现了误码，可靠传输的问题由上层处理。</li><li><strong>无线链路</strong>易受干扰，误码率比较高，因此<strong>要求数据链路层必须向上层提供可靠传输服务</strong>。</li><li>传输差错种类：比特差错、分组丢失、分组失序、分组重复。后面三种差错一般不会出现在数据链路层，而会出现在其上层。</li><li><strong>可靠传输服务不仅局限于数据链路层</strong>，其他各层均可实现可靠传输</li><li>可靠传输的实现比较复杂，开销也比较大。是否使用可靠传输取决于应用需求</li></ul><p><a href="https://imgtu.com/i/bMl64s"><img src="https://s4.ax1x.com/2022/02/28/bMl64s.png" alt="bMl64s.png"></a></p><h2 id="可靠传输的实现机制"><a href="#可靠传输的实现机制" class="headerlink" title="可靠传输的实现机制"></a>可靠传输的实现机制</h2><p>（这三种可靠传输实现机制的基本原理<strong>并不仅限于数据链路层</strong>，可以应用到计算机网络体系结构的各层协议中</p><h3 id="停止-等待协议SW（Stop-and-Wait）-x2F-自动请求重传ARQ（Automatic-Repeat-reQuest）"><a href="#停止-等待协议SW（Stop-and-Wait）-x2F-自动请求重传ARQ（Automatic-Repeat-reQuest）" class="headerlink" title="停止-等待协议SW（Stop-and-Wait）&#x2F;自动请求重传ARQ（Automatic Repeat reQuest）"></a>停止-等待协议SW（Stop-and-Wait）&#x2F;自动请求重传ARQ（Automatic Repeat reQuest）</h3><p><a href="https://imgtu.com/i/bMYKgA"><img src="https://s4.ax1x.com/2022/02/28/bMYKgA.png" alt="bMYKgA.png"></a></p><h4 id="确认与否认"><a href="#确认与否认" class="headerlink" title="确认与否认"></a>确认与否认</h4><ul><li>发送方给接收方发送数据分组，接收方收到后进行差错检测检测，若没有误码则接受该分组，给发送方发送确认分组（ACK）。发送方收到接收方的确认分组后，才能发送下一个数据分组。</li><li>若发现了误码，则丢弃该分组，并给发送方发送否认分组（NAK）。发送方收到否认分组后重传数据分组。因此<strong>发送方发送完成数据分组后，并不能立刻将该数据分组从缓存中删除，只有收到确认分组才可删除</strong>。</li></ul><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>（对于数据链路点对点信道而言不太容易出现这种情况，但对于多个网络通过多个路由器互联的复杂互联网而言，这种情况会经常出现。</p><ul><li>为避免发送方一直等待接收方ACK或NAK的状态，可以启用<strong>超时计时器</strong>，若超过计时器所设置的<strong>重传时间</strong>，则重传原先的数据分组，称为<strong>超时重传</strong>。</li><li>一般重传时间<strong>略大于从发送方到接收方的平均时间</strong>。</li></ul><h4 id="确认丢失"><a href="#确认丢失" class="headerlink" title="确认丢失"></a>确认丢失</h4><ul><li>若接收方发送的ACK在传输过程中丢失，会导致发送方的超时重传，从而导致分组重复</li><li>为避免分组重复，<strong>给每个分组带上序号</strong>。</li><li>对于停止-等待协议，由于每发送一个分组就停止等待，只要保证每发送一个新的数据分组，其<strong>编号与上一组不同</strong>即可，因此只用<strong>一个比特来编号即可</strong>。</li></ul><h4 id="确认迟到"><a href="#确认迟到" class="headerlink" title="确认迟到"></a>确认迟到</h4><p>（对于数据链路点对点信道而言不太容易出现这种情况，往返时间比较固定，不会出现确认迟到的情况。因此如果只<strong>在数据链路层实现该协议，可以不用给确认组编号</strong>。</p><ul><li>由于某些原因确认分组迟到了，导致超时重传。在重传的过程中发送方收到了迟到的确认分组，再次发送下一分组。而此时发送方接收到了重传的分组，再次发送确认分组，导致发送方误认为是对下一分组的确认。</li><li>为避免该种误判，需要<strong>对确认分组进行编号</strong>。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>数据链路层点对点往返时间比较确定，重传时间比较好设定</li><li>运输层由于端到端往返时间不确定，设置合适的重传时间有时并不容易</li></ul><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><ul><li>图中忽略了接收方对数据分组的处理时延，以及发送方对确认分组的处理时延</li><li>一般TA都远小于TD，可以忽略</li><li>当RTT远大于TD时（例如使用卫星链路），信道利用率会非常低。若出现重传，利用率会更低。</li><li>为克服SW协议信道利用率低的缺点，产生了GBN协议和SR协议。</li></ul><p><a href="https://imgtu.com/i/bMU28g"><img src="https://s4.ax1x.com/2022/02/28/bMU28g.png" alt="bMU28g.png"></a></p><h3 id="回退N帧协议GBN（Go-Back-N）"><a href="#回退N帧协议GBN（Go-Back-N）" class="headerlink" title="回退N帧协议GBN（Go-Back-N）"></a>回退N帧协议GBN（Go-Back-N）</h3><p>该协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数。如图所示：</p><ul><li>本例采用3个比特给分组编号，即序号0-7</li><li>发送窗口的尺寸WT的取值为：1 &lt;&#x3D; WT &lt;&#x3D; 2^3 - 1，本例取5</li><li>接收窗口的尺寸WR只能取1，与停止等待协议相同</li></ul><p><a href="https://imgtu.com/i/bMwnC8"><img src="https://s4.ax1x.com/2022/02/28/bMwnC8.png" alt="bMwnC8.png"></a></p><h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><ol><li>发送发将<strong>落在发送窗口内</strong>的0-4号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，没有出现乱序和误码，正确地到达了接收方</li><li>接收方按序接受数据，<strong>每接收一个，接收窗口就向前滑动一个位置</strong>，并给发送方<strong>发送针对所接收分组的确认分组</strong></li><li>确认分组经过互联网的传输，没有出现乱序和误码，正确地到达了发送方</li><li>发送方按序接受数据，<strong>每接收一个，发送窗口就向前滑动一个位置</strong>，这样就有新的序号落入发送窗口，<strong>发送方将收到确认分组的数据分组从缓存中删除</strong></li></ol><h4 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认"></a>累积确认</h4><p>接收方<strong>不一定</strong>要对收到的数据分组<strong>逐个发送确认</strong>，而是可以在收到几个数据分组后<strong>对按序到达的最后一个数据分组发送确认</strong>。ACKn表示序号为n及以前的所有数据分组都已正确接收。</p><ol><li>发送发将<strong>落在发送窗口内</strong>的0-4号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，没有出现乱序和误码，正确地到达了接收方</li><li>接收方按序接受数据，当接受完0-1号数据分组后，发送累计确认ACK1；接受完2-4号数据分组后，发送累计确认ACK4</li><li>假设ACK1丢失，ACK4正确到达</li><li>发送方接受ACK4之后，知道了序号为4及之前的数据分组已经被正确接收。于是移动窗口，删除缓存。</li></ol><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>此外，还能减少接收方的开销，减少对网络资源的占用</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不能向发送方及时反映出接收方已经正确接收的分组信息</li></ul><h4 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h4><ol><li>发送发将<strong>落在发送窗口内</strong>的5-6-7-0-1-2号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，<strong>5号数据分组出现误码</strong></li><li>接收方按序接受数据，发现5号数据分组的错误，于是<strong>丢弃该数据分组</strong>。<strong>后续到达的四个分组的序号与接收窗口中的序号不匹配</strong>，接收方也不能接受，将其丢弃，并<strong>对之前按序接收的最后一个数据分组进行确认</strong>，即发送ACK4。<strong>每丢弃一个数据分组，就发送一次ACK4</strong>。</li><li>四个ACK4经过互联网的传输，没有出现乱序和误码，正确地到达了发送方</li><li>发送方收到重复的ACK4时，知道了之前发送的数据分组出现差错，于是<strong>可以不等超过计时器超时就立即重传</strong>。至于收到几个重复确认就立刻重传，由具体实现决定。</li></ol><p>在本例中，尽管序号为6-7-0-1的数据分组正确到达接收方，但<strong>由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受，发送方还要重传这些数据分组</strong>，这就是所谓的Go-Back-N（回退N帧）</p><p>可见，<strong>当通信线路质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高</strong>。</p><h4 id="发送窗口尺寸超过上限"><a href="#发送窗口尺寸超过上限" class="headerlink" title="发送窗口尺寸超过上限"></a>发送窗口尺寸超过上限</h4><ol><li>发送发将<strong>落在发送窗口内</strong>的0-7号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，没有出现乱序和误码，正确地到达了接收方</li><li>接收方按序接受数据，<strong>每接收一个，接收窗口就向前滑动一个位置</strong>，并给发送方<strong>发送针对所接收分组的确认分组</strong></li><li>确认分组经过互联网的传输丢失，没有到达发送方</li><li>发送方<strong>超时重传</strong>，重复发送0-7号数据分组</li><li>接收方<strong>重复接收</strong>之前的0-7号数据分组。即接收方<strong>无法分辨新旧分组</strong>，进而产生<strong>分组重复</strong>这种数据差错。</li></ol><h4 id="回退N帧协议小结"><a href="#回退N帧协议小结" class="headerlink" title="回退N帧协议小结"></a>回退N帧协议小结</h4><p><a href="https://imgtu.com/i/bMrxpV"><img src="https://s4.ax1x.com/2022/02/28/bMrxpV.png" alt="bMrxpV.png"></a></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种<strong>连续ARQ协议</strong>。</li><li>在协议工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为<strong>滑动窗口协议</strong>。</li><li>由于回退N帧协议的特性，<strong>当通信线路质量不好时，其信道利用率并不比停止-等待协议高</strong>。</li></ul><h3 id="选择重传协议SR（Selective-Request）"><a href="#选择重传协议SR（Selective-Request）" class="headerlink" title="选择重传协议SR（Selective Request）"></a>选择重传协议SR（Selective Request）</h3><ul><li>回退N帧协议的接收窗口尺寸只能等于1，因此<strong>接受方只能按序接收正确到达的数据分组</strong>。</li><li>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按需接收而丢弃（尽管它们无乱序和误码）。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</li><li>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，<strong>接收窗口的尺寸不再等于1，而应大于1</strong>，以便<strong>接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组</strong>，等到所缺分组收齐后再一并送交上层。这就是<strong>选择重传协议</strong>。</li><li>选择重传协议为了使发送方仅重传出现差错的分组，接收方<strong>不能再采用累积确认</strong>，而需要对每个正确接收到的数据分组进行<strong>逐一确认</strong>。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>本例采用3个比特给分组编号，即序号0-7</li><li>发送窗口的尺寸WT的取值为：1 &lt;&#x3D; WT &lt;&#x3D; 2^(3 - 1)，本例取4</li><li>接收窗口的尺寸WR一般情况下和发送窗口尺寸WT相同，本例取4</li></ul><p><a href="https://imgtu.com/i/bMIxaV"><img src="https://s4.ax1x.com/2022/03/01/bMIxaV.png" alt="bMIxaV.png"></a></p><ol><li>发送发将<strong>落在发送窗口内</strong>的0-3号数据分组，依次连续发送出去</li><li>数据分组经过互联网的传输，但其中的2号数据分组出现丢失</li><li>只要<strong>序号落入接收窗口内且无误码</strong>的分组，接收方都会接收。此时接收窗口为0-1-2-3。</li><li>接收方接收0号和1号数据分组，并发送0号和1号确认分组。接收窗口向前滑动两个位置。这样就有4和5这两个新的信号落入接收窗口。</li><li>接收方接收3号数据分组，并发送三号确认分组，但<strong>接收窗口不能向前滑动，因为3号分组是未按序到达的数据分组</strong>。</li><li>确认分组经过互联网的传输，陆续到达了发送方</li><li>发送方按序接接收确认分组，<strong>每接收一个，发送窗口就向前滑动一个位置</strong>。发送方接收0号和1号确认分组，发送窗口向前滑动两个位置，这样就有4-5新的序号落入发送窗口。</li><li>发送方将序号落入发送窗口的4号和5号发送窗口的数据分组发送出去，并将已确认收到的0和1号数据分组从发送缓存中删除。</li><li>发送方接收3号确认分组，但<strong>发送窗口不能向前滑动，因为这是一个未按序到达的确认分组</strong>。但<strong>需要记录3号数据分组已收到确认</strong>，这样该数据分组就不会超时重发。</li><li>假设在4号和5号确认分组的传输过程中，发送方针对2号数据分组的<strong>重传计时器超时</strong>，发送方重新发送2号数据分组。</li><li>4号和5号数据分组到达接收方，接收方接收它们并发送4号和5号确认分组，但<strong>接收窗口不能向前滑动</strong>，因为是未按序到达的数据分组。但<strong>需要记录4号和5号数据分组已收到确认</strong>，这样就不会超时重发。</li><li>发送方之前重传的2号数据分组到达接收方，接收方接收该数据分组，并发送2号数据分组。由于之前3-4-5已标记收到，此时<strong>接收窗口可以向前滑动四个窗口</strong>，这样就有6-7-0-1这四个新的序号落入接收窗口。</li><li>2号确认分组经过互联网的传输到达发送方，发送方接收该确认分组。由于之前3-4-5已标记发送，此时<strong>发送窗口可以向前滑动四个窗口</strong>，这样就有6-7-0-1这四个新的序号落入发送窗口。</li><li>此时发送方可以继续将6-7-0-1这四个序号的数据分组发送出去。</li></ol><h4 id="发送窗口和接收窗口的尺寸问题"><a href="#发送窗口和接收窗口的尺寸问题" class="headerlink" title="发送窗口和接收窗口的尺寸问题"></a>发送窗口和接收窗口的尺寸问题</h4><p>发送方的发送窗口尺寸WT必须满足<strong>1 &lt; WT &lt;&#x3D; 2^(n-1)</strong> ，其中n是构成分组序号的比特数量。</p><ul><li>若WT &#x3D; 2，则<strong>与停止-等待协议相同</strong>。</li><li>若WT &gt; 2^(n-1)，则会导致接收方<strong>无法辨析新旧数据分组</strong>的问题。</li></ul><p>接收方的接收窗口尺寸WR必须满足<strong>1 &lt; WR &lt;&#x3D; WT</strong>。</p><ul><li>若WR &#x3D; 1，则<strong>回退N帧协议相同</strong>。</li><li>若WR &gt; WT，则<strong>没有意义</strong>。</li></ul><h5 id="发送窗口尺寸过大"><a href="#发送窗口尺寸过大" class="headerlink" title="发送窗口尺寸过大"></a>发送窗口尺寸过大</h5><ul><li>本例采用3个比特给分组编号，即序号0-7</li><li>发送窗口的尺寸WT的取值为：1 &lt;&#x3D; WT &lt;&#x3D; 2^(3 - 1)，本例取5</li><li>接收窗口的尺寸WR一般情况下和发送窗口尺寸WT相同，本例取5</li></ul><ol><li>发送发将<strong>落在发送窗口内</strong>的0-4号数据分组，依次连续发送出去</li><li>接收方接收0-4号数据分组，并发送0-4号确认分组。接收窗口向前滑动5个位置。这样就有5-6-7-0-1这5个新的信号落入接收窗口。</li><li>确认分组经过互联网的传输，陆续到达发送方，但其中<strong>0号确认分组丢失</strong>。</li><li>发送方按序接收确认分组，并记录1-4号数据分组已收到确认，<strong>发送窗口不能向前移动</strong>。</li><li>发送方针对0号数据分组的<strong>重传计时器超时</strong>，发送方重新发送0号数据分组。</li><li>0号确认分组经过互联网的传输到达发送方，其序号0落在窗口内，接收方接收。但<strong>接收方先前已经正确接收过该数据分组</strong>，现在再次接收，<strong>接收方无法辨析新旧分组</strong>，会导致出现<strong>重复传输</strong>的传输差错。</li></ol><h4 id="选择重传协议小结"><a href="#选择重传协议小结" class="headerlink" title="选择重传协议小结"></a>选择重传协议小结</h4><p><a href="https://imgtu.com/i/bM73UP"><img src="https://s4.ax1x.com/2022/03/01/bM73UP.png" alt="bM73UP.png"></a></p><h1 id="点对点协议PPP（Point-to-Point-Protocol）"><a href="#点对点协议PPP（Point-to-Point-Protocol）" class="headerlink" title="点对点协议PPP（Point-to-Point Protocol）"></a>点对点协议PPP（Point-to-Point Protocol）</h1><p>PPP协议为在点对点链路传输各种协议数据提供了一个标准方法，主要由以下三部分构成：</p><ul><li>对各种协议数据报的封装方法（封装成帧）</li><li>链路控制协议LCP：用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs：其中的每一个协议支持不同的网络层协议</li></ul><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p><a href="https://imgtu.com/i/bllc8A"><img src="https://s4.ax1x.com/2022/03/01/bllc8A.md.png" alt="bllc8A.md.png"></a></p><ul><li>标志（<strong>F</strong>lag）字段：PPP帧的定界符，取值为0x7E</li><li>地址（<strong>A</strong>ddress）字段：取值为0xFF，预留</li><li>控制（<strong>C</strong>ontrol）字段：取值为0x03，预留</li><li>协议（<strong>P</strong>rotocol）字段：指明帧的数据部分交送哪个协议处理<br><a href="https://imgtu.com/i/blQ1fA"><img src="https://s4.ax1x.com/2022/03/01/blQ1fA.md.png" alt="blQ1fA.md.png"></a></li><li>帧检查序列（<strong>F</strong>rame <strong>C</strong>heck <strong>S</strong>equence）：使用循环冗余校验CRC计算出的校验位，用于检查PPP帧是否存在误码</li></ul><p>其中预留的俩字段在创建之初都说以后有用，但是目前都没啥用（可能在韬光养晦 <del>（也有可能单纯地忘了</del></p><h2 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>面向字节的异步链路：使用字节填充法，插入转义字符</li><li>面向比特的同步链路：使用比特填充法，插入比特0</li></ul><p><a href="https://imgtu.com/i/bllYC9"><img src="https://s4.ax1x.com/2022/03/01/bllYC9.md.png" alt="bllYC9.md.png"></a></p><h3 id="字节填充法"><a href="#字节填充法" class="headerlink" title="字节填充法"></a>字节填充法</h3><p><a href="https://imgtu.com/i/bl0kQS"><img src="https://s4.ax1x.com/2022/03/01/bl0kQS.md.png" alt="bl0kQS.md.png"></a></p><h4 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h4><ul><li>出现的每一个<strong>7E</strong>（PPP的定界符）字节变成2字节序列（<strong>7D,5E</strong>）</li><li>出现的每一个<strong>7D</strong>（转义字符）字节变成2字节序列（<strong>7D,5D</strong>）</li><li>出现的每一个ASCII码控制字符（<strong>数值小于0x20的字符</strong>），则在该字符前面插入一个7D字节，同时将该字符的编码加上0x20</li></ul><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p>进行<strong>反变换</strong>即可恢复出原来帧的数据部分</p><h3 id="比特填充法"><a href="#比特填充法" class="headerlink" title="比特填充法"></a>比特填充法</h3><p><a href="https://imgtu.com/i/bl0x6U"><img src="https://s4.ax1x.com/2022/03/01/bl0x6U,md.png" alt="bl0x6U.md.png"></a></p><h4 id="发送方-2"><a href="#发送方-2" class="headerlink" title="发送方"></a>发送方</h4><p>对帧的数据部分进行扫描（一般由硬件实现）。只要发现<strong>5个连续的比特1</strong>，则立即<strong>填充1个比特0</strong>。</p><h4 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h4><p>对帧的数据部分进行扫描（一般由硬件实现）。只要发现<strong>5个连续的比特1</strong>，则<strong>把后面的1个比特0删除</strong>。</p><h2 id="差错检测-2"><a href="#差错检测-2" class="headerlink" title="差错检测"></a>差错检测</h2><p>接收方每收到一个PPP帧，就进行CRC检验。若CRC检验正确，就收下这个帧，反之则丢弃。使用PPP的数据链路层<strong>向上不提供可靠传输服务</strong>。</p><h2 id="工作状态（以拨号接入为例）"><a href="#工作状态（以拨号接入为例）" class="headerlink" title="工作状态（以拨号接入为例）"></a>工作状态（以拨号接入为例）</h2><ol><li>PPP的开始和结束状态都是“<strong>静止</strong>”状态，这时并不存在物理层的链接</li><li>当检测到调制解调器的载波信号，并建立物理层连接后，PPP就进入链路的“<strong>建立</strong>”状态</li><li>这时，链路控制协议LCP开始协商一些配置选项。若协商成功，则进入“<strong>鉴别</strong>”状态；若协商失败，则退回到“<strong>静止</strong>”状态。所协商的配置包括最大帧长、鉴别协议等。</li><li>可以不使用鉴别，也可以使用口令鉴别协议PAP，或挑战握手鉴别协议CHAP。若通信双方无需鉴别或鉴别身份成功，则进入“<strong>网络</strong>”状态；若鉴别失败，则进入“<strong>终止</strong>”状态。</li><li>进入“<strong>网络</strong>”状态后，进行NCP配置。配置完成后，进入“<strong>打开</strong>”状态。</li><li>PPP链路的两端通过互相交换网络层特定的NCP分组来进行NCP配置。如果链路上运行的是IP协议，则使用IP控制协议IPCP来对PPP链路的每一端配置IP模块（如配置IP地址</li><li>只要链路处于“<strong>打开</strong>”状态，就可以进行数据通信。当出现故障或链路的一端发出终止请求时，就进入“<strong>终止</strong>”状态。当载波停止后，则回到“<strong>静止状态</strong>”。</li></ol><p><a href="https://imgtu.com/i/b1fSUK"><img src="https://s4.ax1x.com/2022/03/01/b1fSUK.png" alt="b1fSUK.png"></a></p><h1 id="媒体接入控制MAC（Medium-Access-Control）"><a href="#媒体接入控制MAC（Medium-Access-Control）" class="headerlink" title="媒体接入控制MAC（Medium Access Control）"></a>媒体接入控制MAC（Medium Access Control）</h1><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即<strong>媒体接入控制MAC</strong>。</p><p><a href="https://imgtu.com/i/b15rrj"><img src="https://s4.ax1x.com/2022/03/02/b15rrj.png" alt="b15rrj.png"></a></p><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路交换机的交换式局域网在有线领域已经完全取代了共享式局域网。但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</p><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><h3 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h3><ul><li>复用：通过一条物理线路同时传输多条用户的信号</li></ul><p>当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用信道复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</p><p><a href="https://imgtu.com/i/bGKjIS"><img src="https://s4.ax1x.com/2022/03/02/bGKjIS.png" alt="bGKjIS.png"></a></p><h4 id="常见的信道复用技术："><a href="#常见的信道复用技术：" class="headerlink" title="常见的信道复用技术："></a>常见的信道复用技术：</h4><h5 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h5><p>将传输线路的频带资源划分成多个子频带，形成多个子信道。各子信道之间需要留出隔离频带，以免造成子信道之间的干扰。当多个信号输入一个多路复用器时，这个复用器将每一路信号调制到不同频率的载波上，接收端由相应的分用器通过滤波将各路信号分开，将合成的复用信号恢复成原始的多路信号。显然，<strong>频分复用的所有用户同时占用不同的频带资源并行通信</strong>。</p><p><a href="https://imgtu.com/i/bGQCfe"><img src="https://s4.ax1x.com/2022/03/02/bGQCfe.png" alt="bGQCfe.png"></a></p><h5 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h5><p>将传输线路的带宽资源按时隙轮流分配给不同的用户，每对用户只在所分配的时隙里使用线路传输数据。时分复用技术将时间划分成了一段段等长的时分复用帧，每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙。显然，<strong>时分复用的所有用户在不同的时间占用同样的频带宽度</strong>。</p><p><a href="https://imgtu.com/i/bGQTBt"><img src="https://s4.ax1x.com/2022/03/02/bGQTBt.png" alt="bGQTBt.png"></a></p><h5 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h5><p>波分复用其实就是光的频分复用。如图为8路传输速率均为2.5Gbit&#x2F;s的光载波，其波长均为1310nm。经光调制后，分别将波长变换到1550-1561.2nm，每个光载波相隔1.6nm。这8个波长很接近的光载波，经过光复用器（合波器）在一根光纤中传输。因此，在一根光纤上数据传输的总速率就达到了8*2.5Gbit&#x2F;s &#x3D; 20Gbit&#x2F;s。光信号传输一段距离后会衰减，因此对衰减了的光信号必须进行放大才能继续传输。</p><p><a href="https://imgtu.com/i/bGl5PU"><img src="https://s4.ax1x.com/2022/03/02/bGl5PU.png" alt="bGl5PU.png"></a></p><h5 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h5><p>码分复用CDM是另一种共享信道的方法。实际上该技术主要用于多址接入，人们更常用的名词是码分多址CDMA（Code Division Multiple Access）。同理，频分复用FDM和时分复用TDM同样可以用于多址接入，相应的名词为频分多址FDMA（Frequency Division Multiple Access）和时分多址TDMA（Time Division Multiple Access）。</p><p>本课程中不严格区分复用与多址的概念，可以简单理解如下：</p><ul><li>复用是将单一媒体的频带资源划分成多个子信道，这些信道之间相互独立，互不干扰。从媒体的整体频带资源上开，每个子信道只占用该媒体频带资源的一部分。</li><li>多址（更确切地应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的（对于无线广播或电视广播站就是这样）。</li><li>从某种程度上看，FDMA、TDMA、CDMA可以看成是FDM、TDM、CDM的应用。</li></ul><p>与FDM和TDM不同，CDM的每一个用户可以<strong>在同样的时间使用同样的频带进行通信</strong>。由于<strong>各用户使用经过特殊挑选的不同码型</strong>，因此用户之间<strong>不会造成干扰</strong>。</p><p>在CDMA中，每一个比特时间再划分为m个短的间隔，称为<strong>码片</strong>（Chip）。通常m的取值为64或128。使用CDMA的每一个站被指派一个唯一的<strong>m bit码片序列</strong>（Chip Sequence）：</p><ul><li>一个站如果要<strong>发送比特0</strong>，则<strong>发送其自身的m bit码片序列</strong></li><li>一个站如果要<strong>发送比特1</strong>，则<strong>发送其自身的m bit码片序列的二进制反码</strong></li><li>为方便起见，习惯将码片序列中的0写为-1，1写为+1</li><li>这种通信方式称为直接序列扩频DSSS</li></ul><p>码片序列的挑选原则：</p><ol><li>分配给每个站的<strong>码片序列必须各不相同</strong>，实际常采用伪随机码序列</li><li>分配给每个站的<strong>码片序列必须正交</strong>（规格化内积为0）</li></ol><ul><li>令向量S表示站S的码片序列，令向量T表示其他任何站的码片序列</li><li>两个不同站S和T的码片序列正交，就是向量S和T的规格化内积为0</li><li>$S\cdot T\equiv0<del>S\cdot \bar{T}\equiv0</del>S\cdot S\equiv 1~~ S\cdot\bar{S}\equiv -1$</li></ul><p>CDMA应用举例：</p><p><a href="https://imgtu.com/i/bGt4mQ"><img src="https://s4.ax1x.com/2022/03/02/bGt4mQ.png" alt="bGt4mQ.png"></a></p><h2 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h2><h3 id="CSMA-x2F-CD（Carrier-Sense-Multiple-Access-x2F-Collision-Detection）协议"><a href="#CSMA-x2F-CD（Carrier-Sense-Multiple-Access-x2F-Collision-Detection）协议" class="headerlink" title="CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection）协议"></a>CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection）协议</h3><p>多址接入（Multiple Access）：</p><ul><li>多个站连接在一条总线上，竞争使用总线</li></ul><p>载波监听（Csrrier Sense）：</p><ul><li>每一个站在发送帧之前先要检测一下总线上是否有其他站点正在发送帧（“先听后说”）</li><li>若检测总线空闲96比特时间，则发送这个帧</li><li>若检测到总线忙，则继续检测并等待总线转为96比特时间，然后发送这个帧</li></ul><p>碰撞检测（Collision Detection）：</p><ul><li>每一个正在发送帧的站边发送边检测碰撞（“边说边听”）</li><li>一旦发送总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送（“一旦冲突，立即听说，等待时机，重新再说”）</li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>现对CSMA&#x2F;CD举例说明。如下图，多址接入就是多个主机连接到一条总线上，各主机随机发送帧。</p><ol><li>主机C要发送帧，首先进行载波监听，检测到总线空闲96比特时间后，发送帧。</li><li>在主机C发送帧的过程中，主机B也要发送帧。主机B进行载波监听，发现总线忙，于是持续监听总线。一旦发现总线空闲96比特时间，则立即发送帧。</li><li>B边发送帧边检测碰撞，只要没检测到碰撞，则可继续发送帧的剩余部分。</li><li>主机B发送帧的过程中，主机C也要发送帧，主机C进行载波监听，发现总线空闲96比特时间后立即发送帧，产生碰撞。</li><li>在产生碰撞的时刻，主机B和C都在边发送边检测碰撞，但都检测不到碰撞。</li><li>碰撞信号沿总线传播，主机C比主机B更早检测到碰撞并停止发送，退避一段随机时间后，重新发送之前所发送的帧。当主机B检测到碰撞信号后，退避一段随机时间后，重新发送之前所发送的帧。</li></ol><p><a href="https://imgtu.com/i/bGdGnO"><img src="https://s4.ax1x.com/2022/03/02/bGdGnO.png" alt="bGdGnO.png"></a></p><h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><p><a href="https://imgtu.com/i/bG0wOf"><img src="https://s4.ax1x.com/2022/03/02/bG0wOf.png" alt="bG0wOf.png"></a></p><ul><li>主机最多经过$2\tau$（即$\delta\rightarrow 0$）的时长就可检测到本次发送是否遭受碰撞</li><li>因此，以太网的端到端往返传播时延$2\tau$称为<strong>争用期</strong>或<strong>碰撞窗口</strong></li><li>经过争用期这段时间还没检测到碰撞，才能肯定这次发送不会发生碰撞</li><li>每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间。</li><li>显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大。因此，<strong>共享式以太网不能连接太多的主机，使用的总线也不能太长</strong>。</li><li>10Mb&#x2F;s以太网把争用期定为512比特发送时间，即51.2μs，因此其总线长度不能超过5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过2500m。</li></ul><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p>最小帧长 &#x3D; 争用期 * 数据传输速率</p><p><a href="https://imgtu.com/i/bGDsRs"><img src="https://s4.ax1x.com/2022/03/02/bGDsRs.png" alt="bGDsRs.png"></a></p><ul><li><strong>以太网规定最小帧长为64字节</strong>，即512比特（512比特时间即为争用期）</li><li>如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节</li><li>以太网的<strong>最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞</strong></li><li>如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此<strong>凡长度小于64字节的帧都是由于碰撞而异常终止的无效帧</strong></li></ul><h4 id="最大帧长"><a href="#最大帧长" class="headerlink" title="最大帧长"></a>最大帧长</h4><p><a href="https://imgtu.com/i/bGyNs1"><img src="https://s4.ax1x.com/2022/03/02/bGyNs1.png" alt="bGyNs1.png"></a></p><p><del>（我的帧很大，你要忍一下</del></p><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p><a href="https://imgtu.com/i/bG6ETK"><img src="https://s4.ax1x.com/2022/03/02/bG6ETK.png" alt="bG6ETK.png"></a></p><ul><li>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可以<strong>使重传需要推迟的平均时间随重传次数而增大</strong>（也称为<strong>动态退避</strong>），因而<strong>减小发生碰撞的概率</strong>，有利于整个系统的稳定。</li><li><strong>当重传16次仍不能成功时</strong>，表明同时打算发送帧的主机太多，以至于连续发生碰撞，则<strong>丢弃该帧</strong>，并向高层报告。</li></ul><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><a href="https://imgtu.com/i/bGcpAf"><img src="https://s4.ax1x.com/2022/03/02/bGcpAf.png" alt="bGcpAf.png"></a></p><h4 id="帧发送流程"><a href="#帧发送流程" class="headerlink" title="帧发送流程"></a>帧发送流程</h4><p><a href="https://imgtu.com/i/bGc08e"><img src="https://s4.ax1x.com/2022/03/02/bGc08e.png" alt="bGc08e.png"></a></p><h4 id="帧接收流程"><a href="#帧接收流程" class="headerlink" title="帧接收流程"></a>帧接收流程</h4><p><a href="https://imgtu.com/i/bGcL5T"><img src="https://s4.ax1x.com/2022/03/02/bGcL5T.png" alt="bGcL5T.png"></a></p><h3 id="CSMA-x2F-CA协议"><a href="#CSMA-x2F-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h3>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-物理层</title>
      <link href="/2022/02/27/computerInternet-2/"/>
      <url>/2022/02/27/computerInternet-2/</url>
      
        <content type="html"><![CDATA[<p>小黎学完第一章啦<br>继续向第二章前进（嘿哈嘿哈</p><span id="more"></span><h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>物理层就是要解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务。（透明是指数据链路层看不见也无需看见物理层究竟使用的是什么方法来传输比特0和1的，它只管享受物理层提供的服务即可）</p><h2 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h2><ul><li>机械特性：指明接口所用接线器的<strong>形状</strong>和<strong>尺寸</strong>、<strong>引脚数目</strong>和<strong>排列</strong>、<strong>固定</strong>和<strong>锁定</strong>装置。</li><li>电气特性：指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。</li><li>功能特性：指明某条线上出现的某一电平的<strong>电压表示何种意义</strong>。</li><li>过程特性：指明对于不同功能的各种可能<strong>事件的出现顺序</strong>。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</li></ul><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>（传输媒体不属于计算机网络结构的任何一层</p><h2 id="传输媒体分类"><a href="#传输媒体分类" class="headerlink" title="传输媒体分类"></a>传输媒体分类</h2><ul><li>导引型传输媒体（电磁波被导引沿着固体媒体传播）：双绞线、同轴电缆、光纤、电力线</li><li>非导引型传输媒体（自由空间）：无线电波、微波、红外线、可见光</li></ul><p>（没太听进去，主要讲硬件部分，想看详细的可以看老师的原视频</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=64605483&bvid=BV1c4411d7jb&cid=114529069&page=15" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p>在<strong>远距离传输（如计算机网络）中数据采用串行传输，计算机内部的传输常采用并行传输</strong>，例如CPU与内存之间通过总线进行传输，常见的总线宽度有8位、16位、32位和64位。</p><h3 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h3><p>数据是一个比特一个比特一次发送的，因此在发送端和接收端之间，只需要一条数据传输线路即可</p><h3 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h3><p>一次发送n个比特而不是一个比特，因此在发送端和接收端之间需要有n条传输线路。并行传输速度是串行传输的n倍，但成本高。</p><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><h3 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h3><p>数据块以比特流的形式传输，字节之间没有间隔，接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1。</p><p>由于不同设备的时钟频率不可能完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差会导致接收端对比特信号判别错位，因此需要收发双方时钟同步。</p><h4 id="收发双方时钟同步的方法"><a href="#收发双方时钟同步的方法" class="headerlink" title="收发双方时钟同步的方法"></a>收发双方时钟同步的方法</h4><ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如曼切斯特编码）</li></ul><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>以字节为独立的传输单位，字节之间的时间间隔不固定。接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节前后分别加上起始位和结束位。</p><p>异步指<strong>字节之间异步</strong>，即字节之间的时间间隔不固定。字节中的每个比特仍然要同步，即各比特的持续时间相同。</p><h2 id="单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）</h2><p><a href="https://imgtu.com/i/bG2q9U"><img src="https://s4.ax1x.com/2022/03/02/bG2q9U.png" alt="bG2q9U.png"></a></p><h3 id="单向通信"><a href="#单向通信" class="headerlink" title="单向通信"></a>单向通信</h3><p>通信双方只有一个数据传输方向，只需要一条信道</p><h3 id="半双工通信"><a href="#半双工通信" class="headerlink" title="半双工通信"></a>半双工通信</h3><p>通信双方可以相互传输数据，但不能同时进行。需要两条信道，每个方向各一条</p><h3 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h3><p>通信双方可以同时发送和接受信息。需要两条信道，每个方向各一条。</p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>编码：在不改变信号性质的前提下，仅对数字基带信号的波形进行变换。编码后产生的信号为数字信号，可以在数字信道中传输。</p><p>调制：把数字基带信号的频率范围搬移到较高的频段，并转换为模拟信号。调制后产生的信号是模拟信号，可以在模拟信道中传输。</p><p><a href="https://imgtu.com/i/bnW410"><img src="https://s4.ax1x.com/2022/02/27/bnW410.png" alt="bnW410.png"></a></p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>在使用时间域的波形表示数字信号时，<strong>代表不同离散数值的基本波形</strong>。简单来说，码元就是构成信号的一段波形。</p><p><a href="https://imgtu.com/i/bnfiAH"><img src="https://s4.ax1x.com/2022/02/27/bnfiAH.png" alt="bnfiAH.png"></a></p><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><ul><li>不归零编码：在整个码元时间内不会出现零电平。<br>（接收方判断码元数目需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按照时钟信号的节拍来逐个接受码元。然而对于计算机网络<strong>宁愿利用这根传输线来传输数据信号而不是时钟信号</strong>。所以由于这种同步问题，计算机网络中的数据传输不采用这类编码。</li><li>归零编码：<strong>每个码元传输结束后信号都要归零</strong>。<br>所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。实际上，归零编码相当于把时钟信号用“归零”方式编码在了数据之内，这称为<strong>自同步</strong>信号。但归零编码中大部分的<strong>数据带宽</strong>都用来传输归零而浪费掉了。</li><li>曼彻斯特编码：在每个码元的中间时刻信号都会发生跳变。<br>中间时刻的跳变既表示时钟，又表示数据。</li><li>差分曼切斯特编码：在每个码元的中间时刻信号都会发生跳变<br>跳变仅表示时钟，码元开始处电平是否发生变化表示数据</li></ul><p><a href="https://imgtu.com/i/bn48XV"><img src="https://s4.ax1x.com/2022/02/27/bn48XV.png" alt="bn48XV.png"></a></p><h2 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h2><ul><li>调幅（AM）：无载波输出表示比特0，有载波输出表示比特1</li><li>调频（FM）：频率f1的波形表示比特0，频率f2的波形表示比特1</li><li>调相（PM）：初相位0度的波形表示比特0，初相位180度表示比特1</li></ul><p><a href="https://imgtu.com/i/bn5V3R"><img src="https://s4.ax1x.com/2022/02/27/bn5V3R.png" alt="bn5V3R.png"></a></p><h2 id="混合调制举例：正交振幅调制QAM"><a href="#混合调制举例：正交振幅调制QAM" class="headerlink" title="混合调制举例：正交振幅调制QAM"></a>混合调制举例：正交振幅调制QAM</h2><p>很明显，使用基本调制方法1个码元只能包含1个比特信息，为了使一个码元包含更多信息可以采用混合调制的方法。</p><p>因为<strong>频率和相位是相关的</strong>，即频率是相位关于时间的变化率。所以<strong>一次只能调制频率和相位两个中的一个</strong>。通常情况下相位和振幅可以结合起来一起调制，称为<strong>正交振幅调制QAM</strong></p><h3 id="QAM-16"><a href="#QAM-16" class="headerlink" title="QAM-16"></a>QAM-16</h3><p>所调制出的波形可以有12种相位，每种相位有1或2种振幅可选，可调制出16种码元（波形），每种码元可以表示4个比特（log2(16)&#x3D;4）。</p><p><a href="https://imgtu.com/i/bnoPfJ"><img src="https://s4.ax1x.com/2022/02/27/bnoPfJ.md.png" alt="bnoPfJ.md.png"></a></p><p>每个码元表示的比特不可随便定义，应采用<strong>格雷码</strong>，使任意两个相邻码元只有一个比特位不同，可以减少传输失真导致的错位数目。例如下图原本都是表示比特0，由于传输过程中导致失真，并未都落在在星座图的理想位置。</p><p><a href="https://imgtu.com/i/bnTQET"><img src="https://s4.ax1x.com/2022/02/27/bnTQET.md.png" alt="bnTQET.md.png"></a></p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p>在假定的理想条件下，<strong>为了避免码间串扰，码元传输速率是有上限的</strong>。</p><ul><li>理想低通信道的最高码元传输速率 &#x3D; 2W Baud &#x3D; 2W 码元&#x2F;s</li><li>理想带通信道的最高码元传输速率 &#x3D; W Baud &#x3D; W 码元&#x2F;s</li><li>实际信道所能传输的码元速率要明显低于奈氏准则给出的上限值</li></ul><p>码元传输速率（波特率、调制速率、波形速率、符号速率）与比特率有一定关系：</p><ul><li>当1个码元只携带1比特的信息量时，则波特率（码元&#x2F;s）与比特率（比特&#x2F;s）在数值上相等；</li><li>当1个码元携带n比特的信息量时，则波特率（码元&#x2F;s）转换成比特率（比特&#x2F;s）数值要乘以n。</li></ul><p>要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量，这需要<strong>多元制</strong>。</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p><p><a href="https://imgtu.com/i/bnHMhF"><img src="https://s4.ax1x.com/2022/02/27/bnHMhF.md.png" alt="bnHMhF.md.png"></a></p><ul><li>信道带宽或信道中<strong>信噪比</strong>越大，信息的极限传输速率越高</li><li>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少，因为在实际信道中，信号还要受到其他一些损伤，例如各种脉冲干扰、信号在传输中的衰减和失真等，这些因素在香农公式中并未考虑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理层 </tag>
            
            <tag> 香农公式 </tag>
            
            <tag> 奈氏准则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-概论</title>
      <link href="/2022/02/26/computerInternet-1/"/>
      <url>/2022/02/26/computerInternet-1/</url>
      
        <content type="html"><![CDATA[<p>学校里没机会上计算机网络的课（因为名额满了就不分给咱学院了），只好自学了…<br>不过也没啥，大学不就是大家来自学的意思嘛（bushi<br>网课是网上推荐较多的，bilibili上面湖科大的视频<br>希望能坚持看完吧…</p><span id="more"></span><h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><h2 id="网络、互联网和因特网"><a href="#网络、互联网和因特网" class="headerlink" title="网络、互联网和因特网"></a>网络、互联网和因特网</h2><ul><li>网络由若干个结点和这些结点的链路组成</li><li>多个网络还可以通过路由器互连，这样就构成了一个覆盖范围更大的网络，即互联网，因此，互联网是“网络的网络”。</li><li>因特网是世界上最大的互联网络。</li></ul><h2 id="因特网服务提供者ISP-（Internet-Service-Provider）"><a href="#因特网服务提供者ISP-（Internet-Service-Provider）" class="headerlink" title="因特网服务提供者ISP （Internet Service Provider）"></a>因特网服务提供者ISP （Internet Service Provider）</h2><p>（比如我国的中国电信、移动和联通</p><h2 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h2><p>因特网所有的RFC(Request For Comments)技术文档都可以从因特网上免费下载(<a href="http://www.ietf.org/rfc.html">http://www.ietf.org/rfc.html</a>)</p><h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><ul><li>边缘部分：由所有连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享</li><li>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ul><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><h2 id="电路交换-Circuit-Switching"><a href="#电路交换-Circuit-Switching" class="headerlink" title="电路交换(Circuit Switching)"></a>电路交换(Circuit Switching)</h2><ul><li>电话交换机接通电话线的方式称为电路交换</li><li>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源</li><li>电路交换的三个步骤：建立连接（分配通信资源）；通话（一直占用通信资源）；释放连接（归还通信资源）</li><li>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低，因为<strong>计算机数据是突发式地出现在传输线路上的</strong>。</li></ul><p><a href="https://imgtu.com/i/bmoYqK"><img src="https://s4.ax1x.com/2022/02/27/bmoYqK.png" alt="bmoYqK.png"></a></p><h2 id="分组交换-Packet-Switching"><a href="#分组交换-Packet-Switching" class="headerlink" title="分组交换(Packet Switching)"></a>分组交换(Packet Switching)</h2><p>将表示消息的数据块称为一个报文，在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。<strong>在每一个数据段前面，加上一些由必要的控制信息组成的首部</strong>后，就构成了一个分组，也可简称为<strong>包</strong>。相应地，首部也可称为<strong>包头</strong>。</p><p><strong>首部包含了分组的目的地址</strong>，否则分组传输路径中的各分组交换机（路由器）就不知道如何转发分组了。分组交换机收到一个分组后，先暂时将分组存储下来，再检查其首部，按照首部中的目的地址进行查表转发，找到合适的转发接口，通过该接口将分组转发给下一个分组交换机。主机收到数据后，去除首部，再将其还原。</p><p>三方任务：</p><ul><li>发送方：构造分组、发送分组</li><li>分组交换机（路由器）：缓存分组、转发分组</li><li>接收方：接收分组、还原报文</li></ul><p><a href="https://imgtu.com/i/bmowPH"><img src="https://s4.ax1x.com/2022/02/27/bmowPH.png" alt="bmowPH.png"></a></p><h2 id="报文交换-Message-Switching"><a href="#报文交换-Message-Switching" class="headerlink" title="报文交换(Message Switching)"></a>报文交换(Message Switching)</h2><p>报文交换的交换结点也采用分组转发的方式，但报文交换对报文的大小没有限制，这就要求交换结点有较大的缓存空间。报文交换主要用于早期的电报通信网，目前较少使用，通常被较为先进的分组交换所取代。</p><h2 id="三种交换方式对比"><a href="#三种交换方式对比" class="headerlink" title="三种交换方式对比"></a>三种交换方式对比</h2><p><a href="https://imgtu.com/i/bmosMt"><img src="https://s4.ax1x.com/2022/02/27/bmosMt.png" alt="bmosMt.png"></a></p><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p><strong>通信之前建立连接</strong>，建立好连接后使用该连接进行数据传送，数据传送结束后释放连接，归还通信资源。一旦建立连接，中间各节点交换机就是直通形式的，比特流可以直达终点。</p><p>优点：</p><ul><li>通信时延小：通信线路为通信双方用户专用，数据直达，因此通信时延小，在连续传输大量数据时，优点明显</li><li>有序传输：双方只有一条专用线路，数据只在这一线路传输，不存在失序问题</li><li>没有冲突：不会出现争用物理信道问题</li><li>适用范围广：可以传输模拟和数字信号</li><li>实时性强</li><li>控制简单</li></ul><p>缺点：</p><ul><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差：只要所连接的物理通路任意一点出现故障，就必须重新拨号建立新的连接</li><li>难以规格化：不同类型、规格、速率的终端很难进行相互通信，也难以在通信过程中进行差错控制</li></ul><h3 id="报文交换："><a href="#报文交换：" class="headerlink" title="报文交换："></a>报文交换：</h3><p><strong>随时可以发送报文，不需要事先建立连接。</strong>整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。报文需要在各结点交换机上进行存储转发。由于不限制报文的大小，因此需要各结点交换机都具有较大的缓存空间。</p><p>优点：</p><ul><li>无需建立连接：不存在建立通路的时延</li><li>动态分配线路</li><li>提高线路可靠性：如果某条传输路径发生故障，会重新选择另一条路径传输数据，提高了传输可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul><p>缺点：</p><ul><li>引起了转发时延</li><li>需要较大的存储缓存空间</li><li>需要传输额外的信息量</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><strong>随时可以发送分组，不需要事先建立连接。</strong>构成原始报文的分组，依次在各结点交换机上存储转发。<strong>各结点交换机在发送分组的同时，还缓存接收到的分组。</strong>构成原始报文的分组在各结点交换机上进行存储转发，相比报文交换减少了转发时延，还可以避免过长的报文长时间占用链路，同时也<strong>有利于进行差错控制</strong>。</p><p>优点：</p><ul><li>无需建立连接</li><li>线路利用率高</li><li>简化存储管理：分组长度固定，缓冲区大小固定，管理容易</li><li>加速传输：由于分组逐个传输，后一个分组的存储和前一个分组的转发可以同时进行</li><li>减少出错概率和重发数据量：分组比报文小，出错概率必然减小，即便分组出错也只需重传出错的部分，而不是重传整个报文</li></ul><p>缺点：</p><ul><li>引起转发时延</li><li>需要传输额外的信息量</li><li>对于数据报服务，存在失序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程。</li></ul><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><p>计算机网络的最简单定义：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong></p><ul><li>互联：计算机之前可以通过有线或无线的方式进行数据通信</li><li>自治：指独立的计算机，拥有自己的硬件和软件，可以单独运行使用</li><li>集合：至少需要两台计算机</li></ul><p>计算机网络较好的定义：计算机网络主要是由一些<strong>通用的、可编程的硬件互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的日益增长的应用</strong>。</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件</li><li>计算机网络并非专们用来传送数据，而是能够支持多种应用。</li></ul><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ul><li>按交换技术分类：电路交换网络、报文交换网络、分组交换网络</li><li>按使用者分类：公用网（公众网）、专用网</li><li>按传输介质分类：有限网络、无线网络</li><li>按覆盖范围分类：广域网WAN、城域网MAN、局域网LAN、个域网PAN</li><li>按拓扑结构分类：总线型网络、星型网络、环型网络、网状型网络</li></ul><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率。常用数据率单位如下：</p><ul><li>bit&#x2F;s (b&#x2F;s, bps)</li><li>kb&#x2F;s &#x3D; 10^3 b&#x2F;s (bps), KB &#x3D; 2^10B, B &#x3D; 8b</li><li>Mb&#x2F;s &#x3D; 10^6 b&#x2F;s (bps), MB &#x3D; 2^20B, B &#x3D; 8b</li><li>Gb&#x2F;s &#x3D; 10^9 b&#x2F;s (bps), GB &#x3D; 2^30B, B &#x3D; 8b</li><li>Tb&#x2F;s &#x3D; 10^12 b&#x2F;s (bps), TB &#x3D; 2^40B, B &#x3D; 8b</li></ul><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>带宽在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围，基本单位为Hz</p><p>带宽在计算机网络中的意义：表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率，基本单位为b&#x2F;s</p><p>带宽的两种表述之间有着密切联系：<strong>一条通信线路的频带宽度越宽，其所传输数据的最高数据率越高。</strong></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量表示在<strong>单位时间内通过某个网络（或信道、接口）的数据量</strong>。</p><p>被经常用于对现实世界中网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量<strong>受网络的带宽或额定速率的限制</strong>。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>网络时延由三部分组成：发送时延、传播时延、处理时延</p><p>发送时延 &#x3D; 分组长度（b）&#x2F;发送速率（b&#x2F;s），发送速率受网卡的发送速率、信道带宽和接口速率影响，取三者最小值。</p><p>传播时延 &#x3D; 信道长度（m）&#x2F;电磁波传播速率（m&#x2F;s），电磁波传播速率受传播介质影响，自由空间为3e8，铜线为2.3e8，光纤为2e8</p><p>处理时延一般不方便计算。处理时延忽略不计时，无法判断哪种时延占主导，需要具体情况具体分析。</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>传播时延与带宽的乘积</p><p>若发送端持续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特。</p><p>链路的时延带宽积又称为以比特为单位的链路长度。</p><h2 id="往返时间RTT-Round-Trip-Time"><a href="#往返时间RTT-Round-Trip-Time" class="headerlink" title="往返时间RTT(Round-Trip Time)"></a>往返时间RTT(Round-Trip Time)</h2><p>从源主机发送分组开始，直到源主机收到来自目的主机的确认分组为止所需要的时间。</p><p>在以太网、卫星链路、无线局域网的传播过程中，卫星链路所带来的传播时延比较大（卫星距离远）。</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：表示某信道有百分之几的时间是被利用的（有数据通过）。</p><p>网络利用率：全网络的信道利用率的加权平均。</p><p>根据排队论，<strong>当某信道的利用率增大时，该信道引起的时延也会迅速增加</strong>，因此<strong>信道利用率并非越高越好</strong>。如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用D&#x3D;D0&#x2F;(1-U)公式来表示D、D0和利用率U之间的关系：当网络利用率到达50%时，时延加倍；当网络利用率超过50%时，时延急剧增大；当网络利用率接近100%时，时延趋近于无穷。因此，一些拥有较大主干网的ISP通常会控制其信道利用率不超过50%，如果超过就要准备扩容增大带宽。</p><p>也不能使信道利用率太低，会浪费通信资源。应使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在合理范围内。</p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>即分组丢失率，是指在一定时间范围内传输过程中<strong>丢失的分组数量与总分组数量的比率</strong>。丢包率可具体分为接口丢包率、结点丢包率、链路丢包率、路径丢包率和网络丢包率等。</p><p>分组丢失主要有两种情况：</p><ul><li>分组在传输过程中出现误码，被结点丢弃；</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时可能造成网络拥塞。</li></ul><p>因此丢包率反映了网络的拥塞情况：</p><ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ul><h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="常见的计算机体系结构"><a href="#常见的计算机体系结构" class="headerlink" title="常见的计算机体系结构"></a>常见的计算机体系结构</h2><ul><li>开放系统互连参考模型（OSI）：<br>是一个七层协议的体系结构，从下往上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。是法律上的国际标准。</li><li>TCP&#x2F;IP体系结构：<br>是一个四层协议的体系结构，从下往上依次为网络接口层、网际层、运输层、应用层。是事实上的国际标准。</li></ul><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的物理层和数据链路层合并为网络结构层，并去掉了会话层和表示层。此外，由于TCP&#x2F;IP在网络层使用的协议是IP协议（网际协议），故网络层常被称为网际层。</p><p>用户主机的操作系统和用于网络互连的路由器中通常带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族，但路由器一般只包含网络接口层和网际层。TCP&#x2F;IP体系结构的网络接口层并没有规定具体内容，目的互连全世界不同的接口，因此本质上TCP&#x2F;IP体系结构只有上面的三层。</p><ul><li>网际层：核心协议为IP协议</li><li>运输层：TCP和UDP为两个重要协议</li><li>应用层：包含大量应用层协议，例如HTTP、SMTP、DNS、RTP</li></ul><p>IP协议可以将不同的网络接口互连，并向其上的TCP和UDP协议提供网络互连服务。而TCP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议（HTTP、SMTP）提供可靠传输的服务；UDP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议（DNS、RTP）提供不可靠传输的服务。</p><p>IP协议作为TCP&#x2F;IP体系结构中的核心协议，一方面负责互连不同的网络接口（IP over everything），另一方面为各种网络应用提供服务（Everything over IP）。</p><p><a href="https://imgtu.com/i/bmojJJ"><img src="https://s4.ax1x.com/2022/02/27/bmojJJ.png" alt="bmojJJ.png"></a></p><ul><li>原理体系结构：<br>是一个五层协议的体系结构，从下往上依次为物理层、数据链路层、网际层、运输层、应用层。将TCP&#x2F;IP体系结构的网络接口层又重新划分为了物理层和数据链路层，更有利于对计算机网络原理的学习。</li></ul><p><a href="https://imgtu.com/i/bmTPeK"><img src="https://s4.ax1x.com/2022/02/27/bmTPeK.png" alt="bmTPeK.png"></a></p><h1 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h1><p>将实现计算机网络所需要解决的主要问题划归到各个层</p><ul><li>物理层：使两台计算机通过信号传输比特0或1<br>采用怎样的传输媒体（介质）<br>采用怎样的物理接口<br>使用怎样的信号比特0和1</li><li>数据链路层：实现分组在一个网络上传输<br>如何标识网络中各主机（主机编址问题，例如MAC地址）<br>如何从信号所表示的一连串比特流中区分出地址和数据（分组的封装格式问题）<br>如何协调各主机争用总线</li><li>网络层：实现分组在网络间传输<br>如何标识各网络以及网络中的各主机（网络和主机共同编址的问题，例如IP地址）<br>路由器如何转发分组，如何进行路由选择</li><li>运输层：实现进程之间基于网络的通信<br>如何解决进程之间基于网络通信的问题<br>出现传输错误时如何处理</li><li>应用层：<br>通过应用进程间的交互来完成特定的网络应用</li></ul><p><a href="https://imgtu.com/i/bmTVWd"><img src="https://s4.ax1x.com/2022/02/27/bmTVWd.png" alt="bmTVWd.png"></a></p><h1 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h1><p>（老师讲得很好，视频讲解很清晰，所以直接贴视频吧</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=64605483&bvid=BV1c4411d7jb&cid=112162125&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h1 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h1><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li>实体： 任何可发送或接收的硬件或软件进程</li><li>对等实体：收发双方相同层次中的实体</li></ul><p><a href="https://imgtu.com/i/bmTuOP"><img src="https://s4.ax1x.com/2022/02/27/bmTuOP.png" alt="bmTuOP.png"></a></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li>协议：控制两个对等实体进行逻辑通信的规则的集合<br>逻辑通信实际中并不存在，只是假设出来的一种通信，目的在于方便我们单独研究体系结构某一层时不用考虑其他层</li><li>协议的三要素：语法、语义、同步</li></ul><p><a href="https://imgtu.com/i/bmT3Fg"><img src="https://s4.ax1x.com/2022/02/27/bmT3Fg.png" alt="bmT3Fg.png"></a></p><h3 id="语法-定义所交换信息的格式"><a href="#语法-定义所交换信息的格式" class="headerlink" title="语法:定义所交换信息的格式"></a>语法:定义所交换信息的格式</h3><p>例如下图为IP数据报的格式，其中的小格子称为字段或域，数字表示字段的长度，单位为位（也就是比特）。语法就是定义了这些小格子的长度和顺序，即语法定义了所交换信息由哪些字段以及何种顺序构成。</p><p><a href="https://imgtu.com/i/bmTclR"><img src="https://s4.ax1x.com/2022/02/27/bmTclR.png" alt="bmTclR.png"></a></p><h3 id="语义-定义收发双方所要完成的操作"><a href="#语义-定义收发双方所要完成的操作" class="headerlink" title="语义:定义收发双方所要完成的操作"></a>语义:定义收发双方所要完成的操作</h3><h3 id="同步-定义收发双方的时序关系"><a href="#同步-定义收发双方的时序关系" class="headerlink" title="同步:定义收发双方的时序关系"></a>同步:定义收发双方的时序关系</h3><p>例如TCP采用“三报文握手”建立连接的过程，要想进行运输层TCP实体间的逻辑通信，首先必须建立连接，从连接建立过程可以看出TCP客户端与TCP服务器之间的时序关系，以及各自的状态转换。只有双方建立连接后，才能进行TCP数据传输。</p><p><a href="https://imgtu.com/i/bm7a3d"><img src="https://s4.ax1x.com/2022/02/27/bm7a3d.png" alt="bm7a3d.png"></a></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul><li>在协议的控制下，<strong>两个对等实体间的逻辑通信使得本层能向上一层提供服务</strong>。<br>例如物理层对等实体在物理层协议的控制下向数据链路层提供服务。</li><li>要实现本层协议，<strong>还需要使用下面一层所提供的服务</strong>。<br>例如数据链路层对等实体享受物理层提供的服务，并在数据链路层协议的控制下进行逻辑通信，给网络层提供服务。</li><li>协议是<strong>“水平的”</strong>，服务是<strong>“垂直的”</strong>。</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下层的协议对上层的实体是<strong>“透明”</strong>的。<br>（例如我们享受使用手机打游戏，但是并不知道这个游戏咋做出来的</li></ul><p><a href="https://imgtu.com/i/bm7R3j"><img src="https://s4.ax1x.com/2022/02/27/bm7R3j.png" alt="bm7R3j.png"></a></p><ul><li>服务访问点：在<strong>同一系统中相邻两层的实体交换信息的逻辑接口</strong>，用于区分不同的服务类型。<br>数据链路层的服务访问点为帧的“类型”字段<br>网络层的服务访问点为IP数据报首部中的“协议字段”<br>运输层的服务访问点为“端口号”</li><li>服务原语：<strong>上层使用下层所提供的服务必须通过与下层交换一些命令</strong>，这些命令称为服务原语。</li><li>协议数据单元PDU：<strong>对等层次之间传送的数据包</strong>称为该层的协议数据单元。<br>物理层对等实体逻辑通信的数据包称为比特流<br>数据链路层对等实体逻辑通信的数据包为帧<br>网络层对等实体逻辑通信的数据包称为分组。如果使用IP协议，也称为IP数据报<br>运输层对等实体逻辑通信的数据包一般根据协议而定，使用TCP协议则称为TCP报文段；使用UDP协议则称为UDP用户数据报<br>应用层对等实体逻辑通信数据包一般称为应用报文<br>上述各层数据包可以统称为协议数据单元PDU</li><li>服务数据单元SDU：同一系统内，<strong>层与层之间交换的数据包</strong>称为服务数据单元</li><li>多个SDU可以合成一个PDU，一个SDU也可划分为几个PDU</li></ul><p><a href="https://imgtu.com/i/bm7qC4"><img src="https://s4.ax1x.com/2022/02/27/bm7qC4.png" alt="bm7qC4.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路交换 </tag>
            
            <tag> 分组交换 </tag>
            
            <tag> 报文交换 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> 服务 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11特性</title>
      <link href="/2022/02/25/c++11/"/>
      <url>/2022/02/25/c++11/</url>
      
        <content type="html"><![CDATA[<ul><li>提高运行效率的语言特性：右值引用、泛化常量表达式</li><li>原有语法的增强：初始化列表、统⼀的初始化语法、类型推导、范围for循环、Lambda表达式、final和override、构造函数委托</li><li>语言能力的提升：空指针nullptr、default和delete、⻓整数、静态assert</li><li>c++标准库的更新：智能指针、正则表达式、哈希表等</li></ul><span id="more"></span><h1 id="提高运行效率"><a href="#提高运行效率" class="headerlink" title="提高运行效率"></a>提高运行效率</h1><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>C++03及之前的标准中，右值是不允许被改变的，实践中也通常使⽤<code>const T&amp;</code>的⽅式传递右值。然⽽这是效率低下的做法，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">Person p = <span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>上述获取右值并初始化<code>p</code>的过程包含了<code>Person</code>的3个构造过程和2个析构过程，这是C++⼴受诟病的⼀点，但C++11 的右值引⽤特性允许我们对右值进⾏修改。借此可以实现<strong>move语义</strong>，即从右值中直接拿数据过来初始化或修改左值，⽽不需要重新构造左值后再析构右值。⼀个move构造函数是这样声明的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; rhs)&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="泛化常量表达式"><a href="#泛化常量表达式" class="headerlink" title="泛化常量表达式"></a>泛化常量表达式</h2><h1 id="原有语法的增强"><a href="#原有语法的增强" class="headerlink" title="原有语法的增强"></a>原有语法的增强</h1><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><h2 id="统一的初始化语法"><a href="#统一的初始化语法" class="headerlink" title="统一的初始化语法"></a>统一的初始化语法</h2><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h2 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h2><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式实际上就是提供了⼀个类似匿名函数的特性，⽽匿名函数则是在需要⼀个函数，但是⼜不想费⼒去命名⼀个函数的情况下去使⽤的。利⽤lambda表达式可以编写内嵌的匿名函数，⽤以替换独⽴函数或者函数对象，并且使代码更可读。</p><p>从本质上来讲，lambda表达式只是⼀种语法糖，因为所有其能完成的⼯作都可以⽤其它稍微复杂的代码来实现，但是它简便的语法却给C++带来了深远的影响。从⼴义上说，lamdba表达式产⽣的是函数对象。在类中，可以<strong>重载函数调⽤运算符<code>()</code><strong>，此时类的对象可以将具有类似函数的⾏为，我们称这些对象为</strong>函数对象（Function Object）</strong>或者<strong>仿函数（Functor）</strong>。相⽐ lambda表达式，函数对象有⾃⼰独特的优势。</p><p>lambda表达式⼀般都是从⽅括号[]开始，结束于花括号{}，花括号⾥⾯就像定义函数那样，包含了lamdba表达式体，⼀个最简单的例⼦如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义简单的lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> basicLambda = [] &#123; cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="built_in">basicLambda</span>(); <span class="comment">// 输出：Hello, world!</span></span><br></pre></td></tr></table></figure><p>（hello world百用不厌嗷兄弟们</p><p>上⾯是最简单的lambda表达式，没有参数。如果需要参数，那么就要像函数那样，放在圆括号⾥⾯，如果有返回值，返回类型要放在-&gt;后⾯，即拖尾返回类型，当然你也可以忽略返回类型，<strong>lambda会帮你⾃动推断出返回类型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指明返回类型，托尾返回类型</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// ⾃动推断返回类型</span></span><br><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 输出：7</span></span><br><span class="line"><span class="type">int</span> product = <span class="built_in">multiply</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure><p>最前边的<code>[]</code>是lambda表达式的⼀个很重要的功能，就是闭包。先说明⼀下lambda表达式的⼤致原理：每当你定义⼀个lambda表达式后，编译器会⾃动⽣成⼀个匿名类（这个类重载了<code>()</code>运算符），我们称为闭包类型（closure type）。那么在运⾏时，这个lambda表达式就会返回⼀个匿名的闭包实例，其是⼀个右值。所以，上⾯lambda表达式的结果就是⼀个个闭包实例。<strong>闭包的⼀个强⼤之处是可以通过传值或者引⽤的⽅式捕捉其封装作⽤域内的变量</strong>，前⾯的⽅括号就是⽤来定义捕捉模式以及变量，⼜将其称为 lambda 捕捉块。例⼦如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_x = [x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;</span><br><span class="line">    <span class="comment">// 复制捕捉x,lambda表达式⽆法修改此变量</span></span><br><span class="line">    <span class="keyword">auto</span> multiply_x = [&amp;x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a * x; &#125;;</span><br><span class="line">    <span class="comment">// 引⽤捕捉x，lambda表达式可以修改此变量</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_x</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">multiply_x</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出：20 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获的⽅式可以是引⽤也可以是复制，但是具体说来会有以下⼏种情况来捕获其所在作⽤域中的变量：</p><ul><li><code>[]</code>：默认不捕获任何变量；</li><li><code>[=]</code>：默认以值捕获所有变量；</li><li><code>[&amp;]</code>：默认以引⽤捕获所有变量；</li><li><code>[a]</code>：仅以值捕获a，其它变量不捕获；</li><li><code>[&amp;a]</code>：仅以引⽤捕获a，其它变量不捕获；</li><li><code>[=, &amp;a]</code>：默认以值捕获所有变量，但a是例外，通过引⽤捕获；</li><li><code>[&amp;, a]</code>：默认以引⽤捕获所有变量，但是a是例外，通过值捕获；</li><li><code>[this]</code>：通过引⽤捕获当前对象（其实是复制指针）；</li><li><code>[*this]</code>：通过传值⽅式捕获当前对象；</li></ul><p>⽽<strong>lambda表达式⼀个更重要的应⽤是其可以⽤于函数的参数，通过这种⽅式可以实现回调函数。</strong>其实最常⽤的是在STL算法中，⽐如要统计⼀个数组中满⾜特定条件的元素数量，通过lambda表达式给出条件，传递给<code>count_if</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(v.<span class="built_in">beigin</span>(), v.<span class="built_in">end</span>(), [val](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; val; &#125;);</span><br><span class="line"><span class="comment">// v中⼤于3的元素数量</span></span><br></pre></td></tr></table></figure><p>最后给出lambda表达式的完整语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[capture-list] (params) <span class="built_in">mutable</span>(optional) <span class="built_in">constexpr</span>(optional)(c++<span class="number">17</span>) exception attribute -&gt; ret &#123; body &#125;</span><br><span class="line"><span class="comment">// 可选的简化语法</span></span><br><span class="line">[capture-list] (params) -&gt; ret &#123;body&#125; </span><br><span class="line">[capture-list] (params) &#123;body&#125; </span><br><span class="line">[capture-list] &#123;body&#125;</span><br></pre></td></tr></table></figure><ul><li>capture-list：捕捉列表，前⾯已经讲过，不能省略；</li><li>params：参数列表，可以省略（但是后⾯必须紧跟函数体）；</li><li>mutable：可选，将lambda表达式标记为mutable后，函数体就可以修改传值⽅式捕获的变量；</li><li>constexpr：可选，C++17，可以指定lambda表达式是⼀个常量函数；</li><li>exception：可选，指定lambda表达式可以抛出的异常；</li><li>attribute：可选，指定lambda表达式的特性；</li><li>ret：可选，返回值类型；</li><li>body：函数执⾏体。</li></ul><h2 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h2><h2 id="构造函数委托"><a href="#构造函数委托" class="headerlink" title="构造函数委托"></a>构造函数委托</h2><h1 id="语言能力提升"><a href="#语言能力提升" class="headerlink" title="语言能力提升"></a>语言能力提升</h1><h2 id="空指针nullptr"><a href="#空指针nullptr" class="headerlink" title="空指针nullptr"></a>空指针nullptr</h2><p>nullptr的出现是为了替代原有的NULL。在某种意义上来说，传统C++会把NULL和0视为相同，取决于编译器如何定义NULL：有些编译器会将NULL定义为<code>((void*)0)</code>，有些则直接定义为0。C++不允许将<code>void*</code>隐式转换到其他类型，但如果NULL被定义为<code>((void*)0)</code>，那么当编译<code>char *ch = NULL</code>时，NULL只能被定义为0。但是依然会产生问题，将导致C++中重载特性发生混乱。考虑如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这两个函数来说，如果NULL为0那么<code>func(NULL)</code>将会去调用<code>func(int)</code>，导致代码违反直观。</p><p>为了解决该问题，C++11引入关键字<code>nullptr</code>专门用于区分空指针和0。<code>nullptr</code>的类型为<code>nullptr_t</code>，能够隐式地转换为任何指针或成员指针的类型，也能和他们进行相等或不等的比较。<br>（所以养成用<code>nullptr</code>取代<code>NULL</code>的好习惯噢</p><h2 id="default和delete"><a href="#default和delete" class="headerlink" title="default和delete"></a>default和delete</h2><h2 id="长整数"><a href="#长整数" class="headerlink" title="长整数"></a>长整数</h2><h2 id="静态assert"><a href="#静态assert" class="headerlink" title="静态assert"></a>静态assert</h2><h1 id="c-标准库更新"><a href="#c-标准库更新" class="headerlink" title="c++标准库更新"></a>c++标准库更新</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2>]]></content>
      
      
      <categories>
          
          <category> 小黎与C++的互相拉扯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 右值引用 </tag>
            
            <tag> 泛化常量表达式 </tag>
            
            <tag> 初始化列表 </tag>
            
            <tag> 初始化语法 </tag>
            
            <tag> 类型推导 </tag>
            
            <tag> 范围for循环 </tag>
            
            <tag> lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x&amp;(x-1)的使用</title>
      <link href="/2022/02/25/x&amp;(x-1)/"/>
      <url>/2022/02/25/x&amp;(x-1)/</url>
      
        <content type="html"><![CDATA[<ul><li>计算数的二进制1的个数</li><li>判断是否为2的次方数</li></ul><span id="more"></span><h1 id="将x转为二进制，计算1的数目"><a href="#将x转为二进制，计算1的数目" class="headerlink" title="将x转为二进制，计算1的数目"></a>将x转为二进制，计算1的数目</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每执行一次<code>x = x &amp; (x-1)</code>，会将<code>x</code>用二进制表示时最右边的一个1变为0，因为<code>x-1</code>会将该二进制最右边的一个1变为0。</p><h1 id="判断数x是否为2的次方数"><a href="#判断数x是否为2的次方数" class="headerlink" title="判断数x是否为2的次方数"></a>判断数x是否为2的次方数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  x &amp;&amp; (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理同上，此外要注意<code>==</code>的优先级高于<code>&amp;</code>，且<code>x</code>不能为0。</p>]]></content>
      
      
      <categories>
          
          <category> 小黎和二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 与运算 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
