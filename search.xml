<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络网课笔记-物理层</title>
      <link href="/2022/02/27/computerInternet-2/"/>
      <url>/2022/02/27/computerInternet-2/</url>
      
        <content type="html"><![CDATA[<p>小黎学完第一章啦<br>继续向第二章前进（嘿哈嘿哈</p><span id="more"></span><h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>物理层就是要解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务。（透明是指数据链路层看不见也无需看见物理层究竟使用的是什么方法来传输比特0和1的，它只管享受物理层提供的服务即可）</p><h2 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h2><ul><li>机械特性：指明接口所用接线器的<strong>形状</strong>和<strong>尺寸</strong>、<strong>引脚数目</strong>和<strong>排列</strong>、<strong>固定</strong>和<strong>锁定</strong>装置。</li><li>电气特性：指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。</li><li>功能特性：指明某条线上出现的某一电平的<strong>电压表示何种意义</strong>。</li><li>过程特性：指明对于不同功能的各种可能<strong>事件的出现顺序</strong>。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</li></ul><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>（传输媒体不属于计算机网络结构的任何一层</p><h2 id="传输媒体分类"><a href="#传输媒体分类" class="headerlink" title="传输媒体分类"></a>传输媒体分类</h2><ul><li>导引型传输媒体（电磁波被导引沿着固体媒体传播）：双绞线、同轴电缆、光纤、电力线</li><li>非导引型传输媒体（自由空间）：无线电波、微波、红外线、可见光</li></ul><p>（没太听进去，主要讲硬件部分，想看详细的可以看老师的原视频</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=64605483&bvid=BV1c4411d7jb&cid=114529069&page=15" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p>在<strong>远距离传输（如计算机网络）中数据采用串行传输，计算机内部的传输常采用并行传输</strong>，例如CPU与内存之间通过总线进行传输，常见的总线宽度有8位、16位、32位和64位。</p><h3 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h3><p>数据是一个比特一个比特一次发送的，因此在发送端和接收端之间，只需要一条数据传输线路即可</p><h3 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h3><p>一次发送n个比特而不是一个比特，因此在发送端和接收端之间需要有n条传输线路。并行传输速度是串行传输的n倍，但成本高。</p><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><h3 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h3><p>数据块以比特流的形式传输，字节之间没有间隔，接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1。</p><p>由于不同设备的时钟频率不可能完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差会导致接收端对比特信号判别错位，因此需要收发双方时钟同步。</p><h4 id="收发双方时钟同步的方法"><a href="#收发双方时钟同步的方法" class="headerlink" title="收发双方时钟同步的方法"></a>收发双方时钟同步的方法</h4><ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如曼切斯特编码）</li></ul><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>以字节为独立的传输单位，字节之间的时间间隔不固定。接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节前后分别加上起始位和结束位。</p><p>异步指<strong>字节之间异步</strong>，即字节之间的时间间隔不固定。字节中的每个比特仍然要同步，即各比特的持续时间相同。</p><h2 id="单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）、双向同时通信（全双工）</h2><h3 id="单向通信"><a href="#单向通信" class="headerlink" title="单向通信"></a>单向通信</h3><p>通信双方只有一个数据传输方向，只需要一条信道</p><h3 id="半双工通信"><a href="#半双工通信" class="headerlink" title="半双工通信"></a>半双工通信</h3><p>通信双方可以相互传输数据，但不能同时进行。需要两条信道，每个方向各一条</p><h3 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h3><p>通信双方可以同时放松和接受信息。需要两条信道，每个方向各一条。</p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>编码：在不改变信号性质的前提下，仅对数字基带信号的波形进行变换。编码后产生的信号为数字信号，可以在数字信道中传输。</p><p>调制：把数字基带信号的频率范围搬移到较高的频段，并转换为模拟信号。调制后产生的信号是模拟信号，可以在模拟信道中传输。</p><p><a href="https://imgtu.com/i/bnW410"><img src="https://s4.ax1x.com/2022/02/27/bnW410.png" alt="bnW410.png"></a></p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>在使用时间域的波形表示数字信号时，<strong>代表不同离散数值的基本波形</strong>。简单来说，码元就是构成信号的一段波形。</p><p><a href="https://imgtu.com/i/bnfiAH"><img src="https://s4.ax1x.com/2022/02/27/bnfiAH.png" alt="bnfiAH.png"></a></p><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><ul><li>不归零编码：在整个码元时间内不会出现零电平。<br>（接收方判断码元数目需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按照时钟信号的节拍来逐个接受码元。然而对于计算机网络<strong>宁愿利用这根传输线来传输数据信号而不是时钟信号</strong>。所以由于这种同步问题，计算机网络中的数据传输不采用这类编码。</li><li>归零编码：<strong>每个码元传输结束后信号都要归零</strong>。<br>所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。实际上，归零编码相当于把时钟信号用“归零”方式编码在了数据之内，这称为<strong>自同步</strong>信号。但归零编码中大部分的<strong>数据带宽</strong>都用来传输归零而浪费掉了。</li><li>曼彻斯特编码：在每个码元的中间时刻信号都会发生跳变。<br>中间时刻的跳变既表示时钟，又表示数据。</li><li>差分曼切斯特编码：在每个码元的中间时刻信号都会发生跳变<br>跳变仅表示时钟，码元开始处电平是否发生变化表示数据</li></ul><p><a href="https://imgtu.com/i/bn48XV"><img src="https://s4.ax1x.com/2022/02/27/bn48XV.png" alt="bn48XV.png"></a></p><h2 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h2><ul><li>调幅（AM）：无载波输出表示比特0，有载波输出表示比特1</li><li>调频（FM）：频率f1的波形表示比特0，频率f2的波形表示比特1</li><li>调相（PM）：初相位0度的波形表示比特0，初相位180度表示比特1</li></ul><p><a href="https://imgtu.com/i/bn5V3R"><img src="https://s4.ax1x.com/2022/02/27/bn5V3R.png" alt="bn5V3R.png"></a></p><h2 id="混合调制举例：正交振幅调制QAM"><a href="#混合调制举例：正交振幅调制QAM" class="headerlink" title="混合调制举例：正交振幅调制QAM"></a>混合调制举例：正交振幅调制QAM</h2><p>很明显，使用基本调制方法1个码元只能包含1个比特信息，为了使一个码元包含更多信息可以采用混合调制的方法。</p><p>因为<strong>频率和相位是相关的</strong>，即频率是相位关于时间的变化率。所以<strong>一次只能调制频率和相位两个中的一个</strong>。通常情况下相位和振幅可以结合起来一起调制，称为<strong>正交振幅调制QAM</strong></p><h3 id="QAM-16"><a href="#QAM-16" class="headerlink" title="QAM-16"></a>QAM-16</h3><p>所调制出的波形可以有12种相位，每种相位有1或2种振幅可选，可调制出16种码元（波形），每种码元可以表示4个比特（log2(16)&#x3D;4）。</p><p><a href="https://imgtu.com/i/bnoPfJ"><img src="https://s4.ax1x.com/2022/02/27/bnoPfJ.png" alt="bnoPfJ.png"></a></p><p>每个码元表示的比特不可随便定义，应采用<strong>格雷码</strong>，使任意两个相邻码元只有一个比特位不同，可以减少传输失真导致的错位数目。例如下图原本都是表示比特0，由于传输过程中导致失真，并未都落在在星座图的理想位置。</p><p><a href="https://imgtu.com/i/bnTQET"><img src="https://s4.ax1x.com/2022/02/27/bnTQET.png" alt="bnTQET.png"></a></p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p>在假定的理想条件下，<strong>为了避免码间串扰，码元传输速率是有上限的</strong>。</p><ul><li>理想低通信道的最高码元传输速率 &#x3D; 2W Baud &#x3D; 2W 码元&#x2F;s</li><li>理想带通信道的最高码元传输速率 &#x3D; W Baud &#x3D; W 码元&#x2F;s</li><li>实际信道所能传输的码元速率要明显低于奈氏准则给出的上限值</li></ul><p>码元传输速率（波特率、调制速率、波形速率、符号速率）与比特率有一定关系：</p><ul><li>当1个码元只携带1比特的信息量时，则波特率（码元&#x2F;s）与比特率（比特&#x2F;s）在数值上相等；</li><li>当1个码元携带n比特的信息量时，则波特率（码元&#x2F;s）转换成比特率（比特&#x2F;s）数值要乘以n。</li></ul><p>要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量，这需要<strong>多元制</strong>。</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p><p><a href="https://imgtu.com/i/bnHMhF"><img src="https://s4.ax1x.com/2022/02/27/bnHMhF.png" alt="bnHMhF.png"></a></p><ul><li>信道带宽或信道中<strong>信噪比</strong>越大，信息的极限传输速率越高</li><li>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少，因为在实际信道中，信号还要受到其他一些损伤，例如各种脉冲干扰、信号在传输中的衰减和失真等，这些因素在香农公式中并未考虑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网课笔记-概论</title>
      <link href="/2022/02/26/computerInternet-1/"/>
      <url>/2022/02/26/computerInternet-1/</url>
      
        <content type="html"><![CDATA[<p>学校里没机会上计算机网络的课（因为名额满了就不分给咱学院了），只好自学了…<br>不过也没啥，大学不就是大家来自学的意思嘛（bushi<br>网课是网上推荐较多的，bilibili上面湖科大的视频<br>希望能坚持看完吧…</p><span id="more"></span><h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><h2 id="网络、互联网和因特网"><a href="#网络、互联网和因特网" class="headerlink" title="网络、互联网和因特网"></a>网络、互联网和因特网</h2><ul><li>网络由若干个结点和这些结点的链路组成</li><li>多个网络还可以通过路由器互连，这样就构成了一个覆盖范围更大的网络，即互联网，因此，互联网是“网络的网络”。</li><li>因特网是世界上最大的互联网络。</li></ul><h2 id="因特网服务提供者ISP-（Internet-Service-Provider）"><a href="#因特网服务提供者ISP-（Internet-Service-Provider）" class="headerlink" title="因特网服务提供者ISP （Internet Service Provider）"></a>因特网服务提供者ISP （Internet Service Provider）</h2><p>（比如我国的中国电信、移动和联通</p><h2 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h2><p>因特网所有的RFC(Request For Comments)技术文档都可以从因特网上免费下载(<a href="http://www.ietf.org/rfc.html">http://www.ietf.org/rfc.html</a>)</p><h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><ul><li>边缘部分：由所有连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享</li><li>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ul><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><h2 id="电路交换-Circuit-Switching"><a href="#电路交换-Circuit-Switching" class="headerlink" title="电路交换(Circuit Switching)"></a>电路交换(Circuit Switching)</h2><ul><li>电话交换机接通电话线的方式称为电路交换</li><li>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源</li><li>电路交换的三个步骤：建立连接（分配通信资源）；通话（一直占用通信资源）；释放连接（归还通信资源）</li><li>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低，因为<strong>计算机数据是突发式地出现在传输线路上的</strong>。</li></ul><p><a href="https://imgtu.com/i/bmoYqK"><img src="https://s4.ax1x.com/2022/02/27/bmoYqK.png" alt="bmoYqK.png"></a></p><h2 id="分组交换-Packet-Switching"><a href="#分组交换-Packet-Switching" class="headerlink" title="分组交换(Packet Switching)"></a>分组交换(Packet Switching)</h2><p>将表示消息的数据块称为一个报文，在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。<strong>在每一个数据段前面，加上一些由必要的控制信息组成的首部</strong>后，就构成了一个分组，也可简称为<strong>包</strong>。相应地，首部也可称为<strong>包头</strong>。</p><p><strong>首部包含了分组的目的地址</strong>，否则分组传输路径中的各分组交换机（路由器）就不知道如何转发分组了。分组交换机收到一个分组后，先暂时将分组存储下来，再检查其首部，按照首部中的目的地址进行查表转发，找到合适的转发接口，通过该接口将分组转发给下一个分组交换机。主机收到数据后，去除首部，再将其还原。</p><p>三方任务：</p><ul><li>发送方：构造分组、发送分组</li><li>分组交换机（路由器）：缓存分组、转发分组</li><li>接收方：接收分组、还原报文</li></ul><p><a href="https://imgtu.com/i/bmowPH"><img src="https://s4.ax1x.com/2022/02/27/bmowPH.png" alt="bmowPH.png"></a></p><h2 id="报文交换-Message-Switching"><a href="#报文交换-Message-Switching" class="headerlink" title="报文交换(Message Switching)"></a>报文交换(Message Switching)</h2><p>报文交换的交换结点也采用分组转发的方式，但报文交换对报文的大小没有限制，这就要求交换结点有较大的缓存空间。报文交换主要用于早期的电报通信网，目前较少使用，通常被较为先进的分组交换所取代。</p><h2 id="三种交换方式对比"><a href="#三种交换方式对比" class="headerlink" title="三种交换方式对比"></a>三种交换方式对比</h2><p><a href="https://imgtu.com/i/bmosMt"><img src="https://s4.ax1x.com/2022/02/27/bmosMt.png" alt="bmosMt.png"></a></p><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p><strong>通信之前建立连接</strong>，建立好连接后使用该连接进行数据传送，数据传送结束后释放连接，归还通信资源。一旦建立连接，中间各节点交换机就是直通形式的，比特流可以直达终点。</p><p>优点：</p><ul><li>通信时延小：通信线路为通信双方用户专用，数据直达，因此通信时延小，在连续传输大量数据时，优点明显</li><li>有序传输：双方只有一条专用线路，数据只在这一线路传输，不存在失序问题</li><li>没有冲突：不会出现争用物理信道问题</li><li>适用范围广：可以传输模拟和数字信号</li><li>实时性强</li><li>控制简单</li></ul><p>缺点：</p><ul><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差：只要所连接的物理通路任意一点出现故障，就必须重新拨号建立新的连接</li><li>难以规格化：不同类型、规格、速率的终端很难进行相互通信，也难以在通信过程中进行差错控制</li></ul><h3 id="报文交换："><a href="#报文交换：" class="headerlink" title="报文交换："></a>报文交换：</h3><p><strong>随时可以发送报文，不需要事先建立连接。</strong>整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。报文需要在各结点交换机上进行存储转发。由于不限制报文的大小，因此需要各结点交换机都具有较大的缓存空间。</p><p>优点：</p><ul><li>无需建立连接：不存在建立通路的时延</li><li>动态分配线路</li><li>提高线路可靠性：如果某条传输路径发生故障，会重新选择另一条路径传输数据，提高了传输可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul><p>缺点：</p><ul><li>引起了转发时延</li><li>需要较大的存储缓存空间</li><li>需要传输额外的信息量</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><strong>随时可以发送分组，不需要事先建立连接。</strong>构成原始报文的分组，依次在各结点交换机上存储转发。<strong>各结点交换机在发送分组的同时，还缓存接收到的分组。</strong>构成原始报文的分组在各结点交换机上进行存储转发，相比报文交换减少了转发时延，还可以避免过长的报文长时间占用链路，同时也<strong>有利于进行差错控制</strong>。</p><p>优点：</p><ul><li>无需建立连接</li><li>线路利用率高</li><li>简化存储管理：分组长度固定，缓冲区大小固定，管理容易</li><li>加速传输：由于分组逐个传输，后一个分组的存储和前一个分组的转发可以同时进行</li><li>减少出错概率和重发数据量：分组比报文小，出错概率必然减小，即便分组出错也只需重传出错的部分，而不是重传整个报文</li></ul><p>缺点：</p><ul><li>引起转发时延</li><li>需要传输额外的信息量</li><li>对于数据报服务，存在失序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程。</li></ul><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><p>计算机网络的最简单定义：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong></p><ul><li>互联：计算机之前可以通过有线或无线的方式进行数据通信</li><li>自治：指独立的计算机，拥有自己的硬件和软件，可以单独运行使用</li><li>集合：至少需要两台计算机</li></ul><p>计算机网络较好的定义：计算机网络主要是由一些<strong>通用的、可编程的硬件互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的日益增长的应用</strong>。</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件</li><li>计算机网络并非专们用来传送数据，而是能够支持多种应用。</li></ul><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ul><li>按交换技术分类：电路交换网络、报文交换网络、分组交换网络</li><li>按使用者分类：公用网（公众网）、专用网</li><li>按传输介质分类：有限网络、无线网络</li><li>按覆盖范围分类：广域网WAN、城域网MAN、局域网LAN、个域网PAN</li><li>按拓扑结构分类：总线型网络、星型网络、环型网络、网状型网络</li></ul><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率。常用数据率单位如下：</p><ul><li>bit&#x2F;s (b&#x2F;s, bps)</li><li>kb&#x2F;s &#x3D; 10^3 b&#x2F;s (bps), KB &#x3D; 2^10B, B &#x3D; 8b</li><li>Mb&#x2F;s &#x3D; 10^6 b&#x2F;s (bps), MB &#x3D; 2^20B, B &#x3D; 8b</li><li>Gb&#x2F;s &#x3D; 10^9 b&#x2F;s (bps), GB &#x3D; 2^30B, B &#x3D; 8b</li><li>Tb&#x2F;s &#x3D; 10^12 b&#x2F;s (bps), TB &#x3D; 2^40B, B &#x3D; 8b</li></ul><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>带宽在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围，基本单位为Hz</p><p>带宽在计算机网络中的意义：表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率，基本单位为b&#x2F;s</p><p>带宽的两种表述之间有着密切联系：<strong>一条通信线路的频带宽度越宽，其所传输数据的最高数据率越高。</strong></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量表示在<strong>单位时间内通过某个网络（或信道、接口）的数据量</strong>。</p><p>被经常用于对现实世界中网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量<strong>受网络的带宽或额定速率的限制</strong>。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>网络时延由三部分组成：发送时延、传播时延、处理时延</p><p>发送时延 &#x3D; 分组长度（b）&#x2F;发送速率（b&#x2F;s），发送速率受网卡的发送速率、信道带宽和接口速率影响，取三者最小值。</p><p>传播时延 &#x3D; 信道长度（m）&#x2F;电磁波传播速率（m&#x2F;s），电磁波传播速率受传播介质影响，自由空间为3e8，铜线为2.3e8，光纤为2e8</p><p>处理时延一般不方便计算。处理时延忽略不计时，无法判断哪种时延占主导，需要具体情况具体分析。</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>传播时延与带宽的乘积</p><p>若发送端持续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特。</p><p>链路的时延带宽积又称为以比特为单位的链路长度。</p><h2 id="往返时间RTT-Round-Trip-Time"><a href="#往返时间RTT-Round-Trip-Time" class="headerlink" title="往返时间RTT(Round-Trip Time)"></a>往返时间RTT(Round-Trip Time)</h2><p>从源主机发送分组开始，直到源主机收到来自目的主机的确认分组为止所需要的时间。</p><p>在以太网、卫星链路、无线局域网的传播过程中，卫星链路所带来的传播时延比较大（卫星距离远）。</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：表示某信道有百分之几的时间是被利用的（有数据通过）。</p><p>网络利用率：全网络的信道利用率的加权平均。</p><p>根据排队论，<strong>当某信道的利用率增大时，该信道引起的时延也会迅速增加</strong>，因此<strong>信道利用率并非越高越好</strong>。如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用D&#x3D;D0&#x2F;(1-U)公式来表示D、D0和利用率U之间的关系：当网络利用率到达50%时，时延加倍；当网络利用率超过50%时，时延急剧增大；当网络利用率接近100%时，时延趋近于无穷。因此，一些拥有较大主干网的ISP通常会控制其信道利用率不超过50%，如果超过就要准备扩容增大带宽。</p><p>也不能使信道利用率太低，会浪费通信资源。应使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在合理范围内。</p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>即分组丢失率，是指在一定时间范围内传输过程中<strong>丢失的分组数量与总分组数量的比率</strong>。丢包率可具体分为接口丢包率、结点丢包率、链路丢包率、路径丢包率和网络丢包率等。</p><p>分组丢失主要有两种情况：</p><ul><li>分组在传输过程中出现误码，被结点丢弃；</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时可能造成网络拥塞。</li></ul><p>因此丢包率反映了网络的拥塞情况：</p><ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ul><h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="常见的计算机体系结构"><a href="#常见的计算机体系结构" class="headerlink" title="常见的计算机体系结构"></a>常见的计算机体系结构</h2><ul><li>开放系统互连参考模型（OSI）：<br>是一个七层协议的体系结构，从下往上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。是法律上的国际标准。</li><li>TCP&#x2F;IP体系结构：<br>是一个四层协议的体系结构，从下往上依次为网络接口层、网际层、运输层、应用层。是事实上的国际标准。</li></ul><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的物理层和数据链路层合并为网络结构层，并去掉了会话层和表示层。此外，由于TCP&#x2F;IP在网络层使用的协议是IP协议（网际协议），故网络层常被称为网际层。</p><p>用户主机的操作系统和用于网络互连的路由器中通常带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族，但路由器一般只包含网络接口层和网际层。TCP&#x2F;IP体系结构的网络接口层并没有规定具体内容，目的互连全世界不同的接口，因此本质上TCP&#x2F;IP体系结构只有上面的三层。</p><ul><li>网际层：核心协议为IP协议</li><li>运输层：TCP和UDP为两个重要协议</li><li>应用层：包含大量应用层协议，例如HTTP、SMTP、DNS、RTP</li></ul><p>IP协议可以将不同的网络接口互连，并向其上的TCP和UDP协议提供网络互连服务。而TCP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议（HTTP、SMTP）提供可靠传输的服务；UDP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议（DNS、RTP）提供不可靠传输的服务。</p><p>IP协议作为TCP&#x2F;IP体系结构中的核心协议，一方面负责互连不同的网络接口（IP over everything），另一方面为各种网络应用提供服务（Everything over IP）。</p><p><a href="https://imgtu.com/i/bmojJJ"><img src="https://s4.ax1x.com/2022/02/27/bmojJJ.png" alt="bmojJJ.png"></a></p><ul><li>原理体系结构：<br>是一个五层协议的体系结构，从下往上依次为物理层、数据链路层、网际层、运输层、应用层。将TCP&#x2F;IP体系结构的网络接口层又重新划分为了物理层和数据链路层，更有利于对计算机网络原理的学习。</li></ul><p><a href="https://imgtu.com/i/bmTPeK"><img src="https://s4.ax1x.com/2022/02/27/bmTPeK.png" alt="bmTPeK.png"></a></p><h1 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h1><p>将实现计算机网络所需要解决的主要问题划归到各个层</p><ul><li>物理层：使两台计算机通过信号传输比特0或1<br>采用怎样的传输媒体（介质）<br>采用怎样的物理接口<br>使用怎样的信号比特0和1</li><li>数据链路层：实现分组在一个网络上传输<br>如何标识网络中各主机（主机编址问题，例如MAC地址）<br>如何从信号所表示的一连串比特流中区分出地址和数据（分组的封装格式问题）<br>如何协调各主机争用总线</li><li>网络层：实现分组在网络间传输<br>如何标识各网络以及网络中的各主机（网络和主机共同编址的问题，例如IP地址）<br>路由器如何转发分组，如何进行路由选择</li><li>运输层：实现进程之间基于网络的通信<br>如何解决进程之间基于网络通信的问题<br>出现传输错误时如何处理</li><li>应用层：<br>通过应用进程间的交互来完成特定的网络应用</li></ul><p><a href="https://imgtu.com/i/bmTVWd"><img src="https://s4.ax1x.com/2022/02/27/bmTVWd.png" alt="bmTVWd.png"></a></p><h1 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h1><p>（老师讲得很好，视频讲解很清晰，所以直接贴视频吧</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=64605483&bvid=BV1c4411d7jb&cid=112162125&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h1 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h1><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li>实体： 任何可发送或接收的硬件或软件进程</li><li>对等实体：收发双方相同层次中的实体</li></ul><p><a href="https://imgtu.com/i/bmTuOP"><img src="https://s4.ax1x.com/2022/02/27/bmTuOP.png" alt="bmTuOP.png"></a></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li>协议：控制两个对等实体进行逻辑通信的规则的集合<br>逻辑通信实际中并不存在，只是假设出来的一种通信，目的在于方便我们单独研究体系结构某一层时不用考虑其他层</li><li>协议的三要素：语法、语义、同步</li></ul><p><a href="https://imgtu.com/i/bmT3Fg"><img src="https://s4.ax1x.com/2022/02/27/bmT3Fg.png" alt="bmT3Fg.png"></a></p><h3 id="语法-定义所交换信息的格式"><a href="#语法-定义所交换信息的格式" class="headerlink" title="语法:定义所交换信息的格式"></a>语法:定义所交换信息的格式</h3><p>例如下图为IP数据报的格式，其中的小格子称为字段或域，数字表示字段的长度，单位为位（也就是比特）。语法就是定义了这些小格子的长度和顺序，即语法定义了所交换信息由哪些字段以及何种顺序构成。</p><p><a href="https://imgtu.com/i/bmTclR"><img src="https://s4.ax1x.com/2022/02/27/bmTclR.png" alt="bmTclR.png"></a></p><h3 id="语义-定义收发双方所要完成的操作"><a href="#语义-定义收发双方所要完成的操作" class="headerlink" title="语义:定义收发双方所要完成的操作"></a>语义:定义收发双方所要完成的操作</h3><h3 id="同步-定义收发双方的时序关系"><a href="#同步-定义收发双方的时序关系" class="headerlink" title="同步:定义收发双方的时序关系"></a>同步:定义收发双方的时序关系</h3><p>例如TCP采用“三报文握手”建立连接的过程，要想进行运输层TCP实体间的逻辑通信，首先必须建立连接，从连接建立过程可以看出TCP客户端与TCP服务器之间的时序关系，以及各自的状态转换。只有双方建立连接后，才能进行TCP数据传输。</p><p><a href="https://imgtu.com/i/bm7a3d"><img src="https://s4.ax1x.com/2022/02/27/bm7a3d.png" alt="bm7a3d.png"></a></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul><li>在协议的控制下，<strong>两个对等实体间的逻辑通信使得本层能向上一层提供服务</strong>。<br>例如物理层对等实体在物理层协议的控制下向数据链路层提供服务。</li><li>要实现本层协议，<strong>还需要使用下面一层所提供的服务</strong>。<br>例如数据链路层对等实体享受物理层提供的服务，并在数据链路层协议的控制下进行逻辑通信，给网络层提供服务。</li><li>协议是<strong>“水平的”</strong>，服务是<strong>“垂直的”</strong>。</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下层的协议对上层的实体是<strong>“透明”</strong>的。<br>（例如我们享受使用手机打游戏，但是并不知道这个游戏咋做出来的</li></ul><p><a href="https://imgtu.com/i/bm7R3j"><img src="https://s4.ax1x.com/2022/02/27/bm7R3j.png" alt="bm7R3j.png"></a></p><ul><li>服务访问点：在<strong>同一系统中相邻两层的实体交换信息的逻辑接口</strong>，用于区分不同的服务类型。<br>数据链路层的服务访问点为帧的“类型”字段<br>网络层的服务访问点为IP数据报首部中的“协议字段”<br>运输层的服务访问点为“端口号”</li><li>服务原语：<strong>上层使用下层所提供的服务必须通过与下层交换一些命令</strong>，这些命令称为服务原语。</li><li>协议数据单元PDU：<strong>对等层次之间传送的数据包</strong>称为该层的协议数据单元。<br>物理层对等实体逻辑通信的数据包称为比特流<br>数据链路层对等实体逻辑通信的数据包为帧<br>网络层对等实体逻辑通信的数据包称为分组。如果使用IP协议，也称为IP数据报<br>运输层对等实体逻辑通信的数据包一般根据协议而定，使用TCP协议则称为TCP报文段；使用UDP协议则称为UDP用户数据报<br>应用层对等实体逻辑通信数据包一般称为应用报文<br>上述各层数据包可以统称为协议数据单元PDU</li><li>服务数据单元SDU：同一系统内，<strong>层与层之间交换的数据包</strong>称为服务数据单元</li><li>多个SDU可以合成一个PDU，一个SDU也可划分为几个PDU</li></ul><p><a href="https://imgtu.com/i/bm7qC4"><img src="https://s4.ax1x.com/2022/02/27/bm7qC4.png" alt="bm7qC4.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 小黎与计网的爱恨情仇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 电路交换 </tag>
            
            <tag> 分组交换 </tag>
            
            <tag> 报文交换 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> 服务 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11特性</title>
      <link href="/2022/02/25/c++11/"/>
      <url>/2022/02/25/c++11/</url>
      
        <content type="html"><![CDATA[<ul><li>提高运行效率的语言特性：右值引用、泛化常量表达式</li><li>原有语法的增强：初始化列表、统⼀的初始化语法、类型推导、范围for循环、Lambda表达式、final和override、构造函数委托</li><li>语言能力的提升：空指针nullptr、default和delete、⻓整数、静态assert</li><li>c++标准库的更新：智能指针、正则表达式、哈希表等</li></ul><span id="more"></span><h1 id="提高运行效率"><a href="#提高运行效率" class="headerlink" title="提高运行效率"></a>提高运行效率</h1><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>C++03及之前的标准中，右值是不允许被改变的，实践中也通常使⽤<code>const T&amp;</code>的⽅式传递右值。然⽽这是效率低下的做法，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">Person p = <span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>上述获取右值并初始化<code>p</code>的过程包含了<code>Person</code>的3个构造过程和2个析构过程，这是C++⼴受诟病的⼀点，但C++11 的右值引⽤特性允许我们对右值进⾏修改。借此可以实现<strong>move语义</strong>，即从右值中直接拿数据过来初始化或修改左值，⽽不需要重新构造左值后再析构右值。⼀个move构造函数是这样声明的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; rhs)&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="泛化常量表达式"><a href="#泛化常量表达式" class="headerlink" title="泛化常量表达式"></a>泛化常量表达式</h2><h1 id="原有语法的增强"><a href="#原有语法的增强" class="headerlink" title="原有语法的增强"></a>原有语法的增强</h1><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><h2 id="统一的初始化语法"><a href="#统一的初始化语法" class="headerlink" title="统一的初始化语法"></a>统一的初始化语法</h2><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h2 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h2><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式实际上就是提供了⼀个类似匿名函数的特性，⽽匿名函数则是在需要⼀个函数，但是⼜不想费⼒去命名⼀个函数的情况下去使⽤的。利⽤lambda表达式可以编写内嵌的匿名函数，⽤以替换独⽴函数或者函数对象，并且使代码更可读。</p><p>从本质上来讲，lambda表达式只是⼀种语法糖，因为所有其能完成的⼯作都可以⽤其它稍微复杂的代码来实现，但是它简便的语法却给C++带来了深远的影响。从⼴义上说，lamdba表达式产⽣的是函数对象。在类中，可以<strong>重载函数调⽤运算符<code>()</code><strong>，此时类的对象可以将具有类似函数的⾏为，我们称这些对象为</strong>函数对象（Function Object）</strong>或者<strong>仿函数（Functor）</strong>。相⽐ lambda表达式，函数对象有⾃⼰独特的优势。</p><p>lambda表达式⼀般都是从⽅括号[]开始，结束于花括号{}，花括号⾥⾯就像定义函数那样，包含了lamdba表达式体，⼀个最简单的例⼦如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义简单的lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> basicLambda = [] &#123; cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="built_in">basicLambda</span>(); <span class="comment">// 输出：Hello, world!</span></span><br></pre></td></tr></table></figure><p>（hello world百用不厌嗷兄弟们</p><p>上⾯是最简单的lambda表达式，没有参数。如果需要参数，那么就要像函数那样，放在圆括号⾥⾯，如果有返回值，返回类型要放在-&gt;后⾯，即拖尾返回类型，当然你也可以忽略返回类型，<strong>lambda会帮你⾃动推断出返回类型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指明返回类型，托尾返回类型</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// ⾃动推断返回类型</span></span><br><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 输出：7</span></span><br><span class="line"><span class="type">int</span> product = <span class="built_in">multiply</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure><p>最前边的<code>[]</code>是lambda表达式的⼀个很重要的功能，就是闭包。先说明⼀下lambda表达式的⼤致原理：每当你定义⼀个lambda表达式后，编译器会⾃动⽣成⼀个匿名类（这个类重载了<code>()</code>运算符），我们称为闭包类型（closure type）。那么在运⾏时，这个lambda表达式就会返回⼀个匿名的闭包实例，其是⼀个右值。所以，上⾯lambda表达式的结果就是⼀个个闭包实例。<strong>闭包的⼀个强⼤之处是可以通过传值或者引⽤的⽅式捕捉其封装作⽤域内的变量</strong>，前⾯的⽅括号就是⽤来定义捕捉模式以及变量，⼜将其称为 lambda 捕捉块。例⼦如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_x = [x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;</span><br><span class="line">    <span class="comment">// 复制捕捉x,lambda表达式⽆法修改此变量</span></span><br><span class="line">    <span class="keyword">auto</span> multiply_x = [&amp;x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a * x; &#125;;</span><br><span class="line">    <span class="comment">// 引⽤捕捉x，lambda表达式可以修改此变量</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_x</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">multiply_x</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出：20 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获的⽅式可以是引⽤也可以是复制，但是具体说来会有以下⼏种情况来捕获其所在作⽤域中的变量：</p><ul><li><code>[]</code>：默认不捕获任何变量；</li><li><code>[=]</code>：默认以值捕获所有变量；</li><li><code>[&amp;]</code>：默认以引⽤捕获所有变量；</li><li><code>[a]</code>：仅以值捕获a，其它变量不捕获；</li><li><code>[&amp;a]</code>：仅以引⽤捕获a，其它变量不捕获；</li><li><code>[=, &amp;a]</code>：默认以值捕获所有变量，但a是例外，通过引⽤捕获；</li><li><code>[&amp;, a]</code>：默认以引⽤捕获所有变量，但是a是例外，通过值捕获；</li><li><code>[this]</code>：通过引⽤捕获当前对象（其实是复制指针）；</li><li><code>[*this]</code>：通过传值⽅式捕获当前对象；</li></ul><p>⽽<strong>lambda表达式⼀个更重要的应⽤是其可以⽤于函数的参数，通过这种⽅式可以实现回调函数。</strong>其实最常⽤的是在STL算法中，⽐如要统计⼀个数组中满⾜特定条件的元素数量，通过lambda表达式给出条件，传递给<code>count_if</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(v.<span class="built_in">beigin</span>(), v.<span class="built_in">end</span>(), [val](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; val; &#125;);</span><br><span class="line"><span class="comment">// v中⼤于3的元素数量</span></span><br></pre></td></tr></table></figure><p>最后给出lambda表达式的完整语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[capture-list] (params) <span class="built_in">mutable</span>(optional) <span class="built_in">constexpr</span>(optional)(c++<span class="number">17</span>) exception attribute -&gt; ret &#123; body &#125;</span><br><span class="line"><span class="comment">// 可选的简化语法</span></span><br><span class="line">[capture-list] (params) -&gt; ret &#123;body&#125; </span><br><span class="line">[capture-list] (params) &#123;body&#125; </span><br><span class="line">[capture-list] &#123;body&#125;</span><br></pre></td></tr></table></figure><ul><li>capture-list：捕捉列表，前⾯已经讲过，不能省略；</li><li>params：参数列表，可以省略（但是后⾯必须紧跟函数体）；</li><li>mutable：可选，将lambda表达式标记为mutable后，函数体就可以修改传值⽅式捕获的变量；</li><li>constexpr：可选，C++17，可以指定lambda表达式是⼀个常量函数；</li><li>exception：可选，指定lambda表达式可以抛出的异常；</li><li>attribute：可选，指定lambda表达式的特性；</li><li>ret：可选，返回值类型；</li><li>body：函数执⾏体。</li></ul><h2 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h2><h2 id="构造函数委托"><a href="#构造函数委托" class="headerlink" title="构造函数委托"></a>构造函数委托</h2><h1 id="语言能力提升"><a href="#语言能力提升" class="headerlink" title="语言能力提升"></a>语言能力提升</h1><h2 id="空指针nullptr"><a href="#空指针nullptr" class="headerlink" title="空指针nullptr"></a>空指针nullptr</h2><p>nullptr的出现是为了替代原有的NULL。在某种意义上来说，传统C++会把NULL和0视为相同，取决于编译器如何定义NULL：有些编译器会将NULL定义为<code>((void*)0)</code>，有些则直接定义为0。C++不允许将<code>void*</code>隐式转换到其他类型，但如果NULL被定义为<code>((void*)0)</code>，那么当编译<code>char *ch = NULL</code>时，NULL只能被定义为0。但是依然会产生问题，将导致C++中重载特性发生混乱。考虑如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这两个函数来说，如果NULL为0那么<code>func(NULL)</code>将会去调用<code>func(int)</code>，导致代码违反直观。</p><p>为了解决该问题，C++11引入关键字<code>nullptr</code>专门用于区分空指针和0。<code>nullptr</code>的类型为<code>nullptr_t</code>，能够隐式地转换为任何指针或成员指针的类型，也能和他们进行相等或不等的比较。<br>（所以养成用<code>nullptr</code>取代<code>NULL</code>的好习惯噢</p><h2 id="default和delete"><a href="#default和delete" class="headerlink" title="default和delete"></a>default和delete</h2><h2 id="长整数"><a href="#长整数" class="headerlink" title="长整数"></a>长整数</h2><h2 id="静态assert"><a href="#静态assert" class="headerlink" title="静态assert"></a>静态assert</h2><h1 id="c-标准库更新"><a href="#c-标准库更新" class="headerlink" title="c++标准库更新"></a>c++标准库更新</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2>]]></content>
      
      
      <categories>
          
          <category> 小黎与C++的互相拉扯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 右值引用 </tag>
            
            <tag> 泛化常量表达式 </tag>
            
            <tag> 初始化列表 </tag>
            
            <tag> 初始化语法 </tag>
            
            <tag> 类型推导 </tag>
            
            <tag> 范围for循环 </tag>
            
            <tag> lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x&amp;(x-1)的使用</title>
      <link href="/2022/02/25/x&amp;(x-1)/"/>
      <url>/2022/02/25/x&amp;(x-1)/</url>
      
        <content type="html"><![CDATA[<ul><li>计算数的二进制1的个数</li><li>判断是否为2的次方数</li></ul><span id="more"></span><h1 id="将x转为二进制，计算1的数目"><a href="#将x转为二进制，计算1的数目" class="headerlink" title="将x转为二进制，计算1的数目"></a>将x转为二进制，计算1的数目</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每执行一次<code>x = x &amp; (x-1)</code>，会将<code>x</code>用二进制表示时最右边的一个1变为0，因为<code>x-1</code>会将该二进制最右边的一个1变为0。</p><h1 id="判断数x是否为2的次方数"><a href="#判断数x是否为2的次方数" class="headerlink" title="判断数x是否为2的次方数"></a>判断数x是否为2的次方数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  x &amp;&amp; (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理同上，此外要注意<code>==</code>的优先级高于<code>&amp;</code>，且<code>x</code>不能为0。</p>]]></content>
      
      
      <categories>
          
          <category> 小黎和二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 与运算 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
